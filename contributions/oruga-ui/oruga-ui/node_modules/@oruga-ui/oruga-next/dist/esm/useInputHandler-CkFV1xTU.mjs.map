{"version":3,"file":"useInputHandler-CkFV1xTU.mjs","sources":["../../src/composables/useInputHandler.ts"],"sourcesContent":["import {\n    nextTick,\n    ref,\n    computed,\n    type ExtractPropTypes,\n    type MaybeRefOrGetter,\n    type Component,\n} from \"vue\";\nimport { injectField } from \"@/components/field/useFieldShare\";\nimport { unrefElement } from \"./unrefElement\";\nimport { getOption } from \"@/utils/config\";\nimport { isSSR } from \"@/utils/ssr\";\n\n// This should cover all types of HTML elements that have properties related to\n// HTML constraint validation, e.g. .form and .validity.\nconst validatableFormElementTypes = isSSR\n    ? []\n    : [\n          HTMLButtonElement,\n          HTMLFieldSetElement,\n          HTMLInputElement,\n          HTMLObjectElement,\n          HTMLOutputElement,\n          HTMLSelectElement,\n          HTMLTextAreaElement,\n      ];\n\nexport type ValidatableFormElement = InstanceType<\n    (typeof validatableFormElementTypes)[number]\n>;\n\nfunction asValidatableFormElement(el: unknown): ValidatableFormElement | null {\n    return validatableFormElementTypes.some((t) => el instanceof t)\n        ? (el as ValidatableFormElement)\n        : null;\n}\n\n/**\n * Form input handler functionalities\n */\nexport function useInputHandler(\n    /** input ref element - can be a html element or a vue component*/\n    inputRef: MaybeRefOrGetter<ValidatableFormElement | Component>,\n    /** emitted input events */\n    emits: {\n        /** on input focus event */\n        (e: \"focus\", value: Event): void;\n        /** on input blur event */\n        (e: \"blur\", value: Event): void;\n        /** on input invalid event */\n        (e: \"invalid\", value: Event): void;\n    },\n    /** validation configuration props */\n    props: Readonly<\n        ExtractPropTypes<{\n            useHtml5Validation?: boolean;\n            validationMessage?: string;\n        }>\n    >,\n) {\n    // inject parent field component if used inside one\n    const { parentField } = injectField();\n\n    const element = computed<ValidatableFormElement>(() => {\n        const el = unrefElement<Component | HTMLElement>(inputRef);\n        if (!el) {\n            console.warn(\"useInputHandler: inputRef contains no element\");\n            return undefined;\n        }\n        if (el.getAttribute(\"data-oruga-input\"))\n            // if element is the input element\n            return el as ValidatableFormElement;\n\n        const inputs = el.querySelector(\"[data-oruga-input]\");\n\n        if (!inputs) {\n            console.warn(\n                \"useInputHandler: Underlaying Oruga input component not found\",\n            );\n            return undefined;\n        }\n        // return underlaying the input element\n        return inputs as ValidatableFormElement;\n    });\n\n    // --- Input Focus Feature ---\n\n    const isFocused = ref(false);\n\n    /** Focus the underlaying input element. */\n    function setFocus(): void {\n        nextTick(() => {\n            if (element.value) element.value.focus();\n        });\n    }\n\n    /** Click the underlaying input element. */\n    function doClick(): void {\n        nextTick(() => {\n            if (element.value) element.value.click();\n        });\n    }\n\n    function onBlur(event?: Event): void {\n        isFocused.value = false;\n        if (parentField?.value) parentField.value.setFocus(false);\n        emits(\"blur\", event);\n        checkHtml5Validity();\n    }\n\n    function onFocus(event?: Event): void {\n        isFocused.value = true;\n        if (parentField?.value) parentField.value.setFocus(true);\n        emits(\"focus\", event);\n    }\n\n    // --- Validation Feature ---\n\n    const isValid = ref(true);\n\n    function setFieldValidity(variant, message): void {\n        nextTick(() => {\n            if (parentField?.value) {\n                // Set type only if not defined\n                if (!parentField.value.props.variant) {\n                    parentField.value.setVariant(variant);\n                }\n                // Set message only if not defined\n                if (!parentField.value.props.message) {\n                    parentField.value.setMessage(message);\n                }\n            }\n        });\n    }\n\n    /**\n     * Check HTML5 validation, set isValid property.\n     * If validation fail, send 'danger' type,\n     * and error message to parent if it's a Field.\n     */\n    function checkHtml5Validity(): boolean {\n        if (!props.useHtml5Validation) return;\n\n        if (!element.value) return;\n        if (element.value.validity.valid) {\n            setFieldValidity(null, null);\n            isValid.value = true;\n        } else {\n            setInvalid();\n            isValid.value = false;\n        }\n\n        return isValid.value;\n    }\n\n    function setInvalid(): void {\n        const variant = \"danger\";\n        const message =\n            props.validationMessage || element.value.validationMessage;\n        setFieldValidity(variant, message);\n    }\n\n    function onInvalid(event: Event): void {\n        checkHtml5Validity();\n        const validatable = asValidatableFormElement(event.target);\n        if (validatable && parentField?.value && props.useHtml5Validation) {\n            // We provide our own error message on the field, so we should suppress the browser's default tooltip.\n            // We still want to focus the form's first invalid input, though.\n            event.preventDefault();\n            let isFirstInvalid = false;\n            if (validatable.form != null) {\n                const formElements = validatable.form.elements;\n                for (let i = 0; i < formElements.length; ++i) {\n                    const element = asValidatableFormElement(\n                        formElements.item(i),\n                    );\n                    if (element?.willValidate && !element.validity.valid) {\n                        isFirstInvalid = validatable === element;\n                        break;\n                    }\n                }\n            }\n            if (isFirstInvalid) {\n                const fieldElement = parentField.value.$el;\n                const invalidHandler = getOption(\"invalidHandler\");\n                if (invalidHandler instanceof Function) {\n                    invalidHandler(validatable, fieldElement);\n                } else {\n                    // We'll scroll to put the whole field in view, not just the element that triggered the event,\n                    // which should mean that the message will be visible onscreen.\n                    // scrollIntoViewIfNeeded() is a non-standard method (but a very common extension).\n                    // If we can't use it, we'll just fall back to focusing the field.\n                    const canScrollToField = fieldElement\n                        ? fieldElement.scrollIntoView != undefined\n                        : false;\n                    validatable.focus({ preventScroll: canScrollToField });\n                    if (canScrollToField) {\n                        fieldElement.scrollIntoView({ block: \"nearest\" });\n                    }\n                }\n            }\n        }\n        emits(\"invalid\", event);\n    }\n\n    return {\n        isFocused,\n        isValid,\n        setFocus,\n        doClick,\n        onFocus,\n        onBlur,\n        checkHtml5Validity,\n        onInvalid,\n    };\n}\n"],"names":["element"],"mappings":"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"}