var Sl = Object.defineProperty;
var Fl = (e, n, a) => n in e ? Sl(e, n, { enumerable: !0, configurable: !0, writable: !0, value: a }) : e[n] = a;
var Sa = (e, n, a) => (Fl(e, typeof n != "symbol" ? n + "" : n, a), a);
import { ref as L, toRaw as We, toValue as pt, getCurrentInstance as Dt, effectScope as Al, isRef as Ke, watch as ce, getCurrentScope as wl, onScopeDispose as Dl, nextTick as De, computed as l, onMounted as st, onBeforeUnmount as It, defineComponent as ye, useSlots as xt, h as na, Comment as xl, Text as $l, resolveComponent as Ut, openBlock as f, createElementBlock as P, normalizeClass as M, unref as s, renderSlot as _, createTextVNode as Pe, toDisplayString as ue, createCommentVNode as J, Fragment as he, createBlock as ne, withCtx as se, createElementVNode as le, provide as Ia, inject as za, onUnmounted as Ha, normalizeStyle as _e, resolveDynamicComponent as Ge, withDirectives as $e, mergeProps as be, vModelDynamic as Bl, vModelText as Ol, Teleport as ua, mergeModels as Ue, useModel as it, createVNode as me, Transition as et, vShow as ze, useAttrs as da, withKeys as Ce, withModifiers as ve, renderList as xe, readonly as Pl, vModelCheckbox as La, vModelSelect as Ml, createSlots as qt, render as Xt, toHandlers as ca, onBeforeMount as Rl, normalizeProps as Ot, guardReactiveProps as Pt, vModelRadio as Vl, toHandlerKey as Tl } from "vue";
/*! Oruga v0.8.6 | MIT License | github.com/oruga-ui/oruga */
const Ye = () => Math.random().toString(36).substring(2, 15);
function Il(e) {
  return e < 0 ? -1 : e > 0 ? 1 : 0;
}
const zl = Math.sign || Il, Yt = (e, n) => (e % n + n) % n;
function Fa(e, n, a) {
  return Math.max(n, Math.min(a, e));
}
const at = (e) => e && typeof e == "object" && !Array.isArray(e), ot = (e) => e != null, St = (e) => typeof e < "u" && e !== null ? e : "", Ft = (e) => ot(e) ? isNaN(e) ? e : e + "px" : null;
function ea(e, n, a) {
  return e ? !a || typeof a != "function" ? e.indexOf(n) : e.findIndex((t, o, i) => a(t, i)) : -1;
}
function Tt(e, n) {
  if (!e && n || e && !n)
    return !1;
  if (e === n)
    return !0;
  if (at(e) && at(n)) {
    const a = Object.keys(e), t = Object.keys(n);
    if (a.length !== t.length)
      return !1;
    for (const o of a) {
      const i = e[o], u = n[o], d = at(i) && at(u);
      if (d && !Tt(i, u) || !d && i !== u)
        return !1;
    }
    return !0;
  }
  return Array.isArray(e) && Array.isArray(n) ? !(e.length !== n.length || !e.every((a, t) => a === n[t])) : !1;
}
function Hl(e) {
  return Object.assign({}, e);
}
function yt(e, n, a = !1) {
  return !at(e) || !at(n) ? n : a ? Na(e, n) : Object.assign(e, n);
}
function Na(e, n) {
  return !at(e) || !at(n) ? n : (Object.getOwnPropertyNames(n).forEach((a) => {
    const t = e[a], o = n[a];
    Array.isArray(t) && Array.isArray(o) ? e[a] = t.concat(o) : at(t) && at(o) ? e[a] = Na(
      Object.assign({}, t),
      o
    ) : e[a] = o;
  }), e);
}
function Me(e, n, a) {
  const t = n.split(".").reduce(
    (o, i) => typeof o < "u" ? o[i] : void 0,
    e
  );
  return typeof t < "u" ? t : a;
}
function Ea(e, n, a) {
  const t = n.split(".");
  if (t.length === 1) {
    e[n] = a;
    return;
  }
  const o = t[0];
  return typeof e[o] > "u" && (e[o] = {}), Ea(e[o], t.slice(1).join("."), a);
}
function oa(e) {
  typeof e.remove < "u" ? e.remove() : typeof e.parentNode < "u" && e.parentNode !== null && e.parentNode.removeChild(e);
}
function Ll(e) {
  return e && e.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, "\\$&");
}
function Aa(e) {
  return e && e.normalize("NFD").replace(/[\u0300-\u036f]/g, "");
}
const vt = {
  Android: () => typeof window < "u" && !!window.navigator.userAgent.match(/Android/i),
  BlackBerry: () => typeof window < "u" && !!window.navigator.userAgent.match(/BlackBerry/i),
  iOS: () => typeof window < "u" && !!window.navigator.userAgent.match(/iPhone|iPad|iPod/i),
  Opera: () => typeof window < "u" && !!window.navigator.userAgent.match(/Opera Mini/i),
  Windows: () => typeof window < "u" && !!window.navigator.userAgent.match(/IEMobile/i),
  any: () => vt.Android() || vt.BlackBerry() || vt.iOS() || vt.Opera() || vt.Windows()
}, ja = L({});
function Nl(e, n) {
  ja.value[e] = n;
}
function El() {
  return ja.value;
}
let zt;
const Wa = (e) => {
  zt = e;
}, jl = (e, n) => {
  e.use(n);
}, Ae = (e, n) => {
  e.component(n.name, n);
}, Ht = (e, n, a) => {
  Wa(e);
  const t = El();
  Nl(n, a), e._context.provides && e._context.provides.oruga || e.provide("oruga", t), e.config.globalProperties.$oruga || (e.config.globalProperties.$oruga = t);
}, Gt = L({
  iconPack: "mdi",
  useHtml5Validation: !0,
  statusIcon: !0,
  transformClasses: void 0
}), Ya = (e) => {
  Gt.value = e;
}, Kt = () => Hl(We(Gt.value)), r = (e, n) => Me(Gt.value, e, n), Wl = (e, n) => {
  Ea(Gt.value, e, n);
}, Yl = {
  getOption: r,
  getOptions: Kt,
  setOption: Wl,
  setOptions(e) {
    Ya(yt(Kt(), e, !0));
  }
}, Kl = {
  install(e, n) {
    Wa(e), Ya(yt(Kt(), n, !0));
  }
}, Ul = {
  sizes: {
    default: "mdi-24px",
    small: null,
    medium: "mdi-36px",
    large: "mdi-48px"
  },
  iconPrefix: "mdi-"
}, kt = () => {
  const n = r("iconComponent") ? "" : "fa-";
  return {
    sizes: {
      default: null,
      small: null,
      medium: "lg",
      large: "2xl"
    },
    iconPrefix: n,
    internalIcons: {
      check: "check",
      information: "info-circle",
      alert: "exclamation-triangle",
      "alert-circle": "exclamation-circle",
      "arrow-up": "arrow-up",
      "chevron-right": "angle-right",
      "chevron-left": "angle-left",
      "chevron-down": "angle-down",
      "chevron-up": "angle-up",
      eye: "eye",
      "eye-off": "eye-slash",
      "caret-down": "caret-down",
      "caret-up": "caret-up",
      "close-circle": "times-circle",
      close: "times",
      loading: "circle-notch"
    }
  };
}, ql = () => {
  let e = {
    mdi: Ul,
    fa: kt(),
    fas: kt(),
    far: kt(),
    fad: kt(),
    fab: kt(),
    fal: kt()
  };
  const n = r("customIconPacks");
  return n && (e = yt(e, n, !0)), e;
}, Xl = ql;
function Xe(e) {
  const n = pt(e);
  return (n == null ? void 0 : n.$el) ?? n;
}
const Ee = (e) => e ? e.flatMap(
  (n) => Object.keys(n).filter((a) => a && n[a])
) : [];
function h(...e) {
  const n = Dt();
  if (!n)
    throw new Error(
      "defineClasses must be called within a component setup function."
    );
  const a = Al(), t = L([]);
  return t.value = e.map((o, i) => {
    const u = o[0], d = o[1], m = o[2], c = o[3];
    function v() {
      const p = Gl(
        n,
        u,
        d,
        pt(m)
      ), C = !ot(c) || pt(c);
      return { [p]: C };
    }
    return ot(m) && Ke(m) && a.run(() => {
      ce(
        () => pt(m),
        (p, C) => {
          if (p === C)
            return;
          const B = v();
          t.value[i] = B;
        }
      );
    }), ot(c) && Ke(c) && a.run(() => {
      ce(
        () => pt(c),
        (p, C) => {
          if (p === C)
            return;
          const B = t.value[i];
          Object.keys(B).forEach(
            (A) => B[A] = p
          ), t.value[i] = B;
        }
      );
    }), v();
  }), wl() && Dl(() => {
    a && a.stop();
  }), t;
}
function Gl(e, n, a, t = "") {
  var g;
  const o = e.props, i = (g = e.proxy) == null ? void 0 : g.$options.configField;
  if (!i)
    throw new Error("component must define the 'configField' option.");
  const u = o.override === !0 ? {} : Kt(), d = o.override || Me(u, "override", !1), m = Me(
    u,
    `${i}.override`,
    d
  ), c = Me(
    u,
    `${i}.${n}.override`,
    m
  ), v = Me(
    u,
    "transformClasses",
    void 0
  ), p = Me(
    u,
    `${i}.transformClasses`,
    void 0
  );
  let C = Me(
    u,
    `${i}.${n}.class`,
    ""
  ) || Me(u, `${i}.${n}`, ""), B = Me(o, n, "");
  if (Array.isArray(B) && (B = B.join(" ")), typeof B == "function") {
    const y = Da(e);
    B = B(t, y);
  } else
    B = wa(B, t);
  if (Array.isArray(C) && (C = C.join(" ")), typeof C == "function") {
    const y = Da(e);
    C = C(t, y);
  } else
    C = wa(C, t);
  a.includes("{*}") ? a = a.replace(
    /\{\*\}/g,
    St(t)
  ) : a = a + St(t);
  let A = `${c ? "" : a} ${St(C)} ${St(B)}`.trim().replace(/\s\s+/g, " ");
  return p ? A = p(A) : v && (A = v(A)), A;
}
function wa(e, n) {
  return St(e).split(" ").filter((a) => a.length > 0).map((a) => a + St(n)).join(" ");
}
const Da = (e) => {
  let n = e.proxy.$props;
  return Object.keys(n).filter((a) => a.endsWith("Props")).forEach((a) => n = { ...n, ...n[a] }), { props: n };
};
function qe(e, n, a, t) {
  const o = (t == null ? void 0 : t.eventName) || `update:${e.toString()}`;
  if (t != null && t.passive) {
    const i = L(n[e]);
    let u = !1;
    return ce(
      () => n[e],
      (d) => {
        u || (u = !0, i.value = d, De(() => u = !1));
      }
    ), ce(
      i,
      (d) => {
        (!u && d !== n[e] || t.deep) && a(o, d);
      },
      { deep: t.deep }
    ), i;
  } else
    return l({
      get() {
        return n[e];
      },
      set(i) {
        a(o, i);
      }
    });
}
function dt(e, n, a) {
  return qe("modelValue", e, n, a);
}
function Ze(e, n, a = document, t) {
  let o;
  const i = () => {
    if (!a)
      return;
    const d = Xe(a), m = at(t) ? { ...t } : t;
    d.addEventListener(e, n, m), o = () => d.removeEventListener(e, n, m);
  }, u = () => {
    typeof o == "function" && o();
  };
  return t != null && t.immediate ? i() : (st(() => i()), It(() => u())), u;
}
const Be = typeof window < "u", Jl = typeof window > "u";
function ct(e) {
  var m;
  const n = L(!1), a = L(), t = Dt();
  if (!t)
    throw new Error(
      "useMatchMedia must be called within a component setup function."
    );
  const o = t.props, i = (m = t.proxy) == null ? void 0 : m.$options.configField;
  if (!i)
    throw new Error("component must define the 'configField' option.");
  let u = o.mobileBreakpoint;
  if (!u) {
    const c = r(
      "mobileBreakpoint",
      e || "1023px"
    );
    u = r(`${i}.mobileBreakpoint`, c);
  }
  a.value = Be ? window.matchMedia(`(max-width: ${u})`) : void 0, a.value ? (n.value = a.value.matches, Ze("change", d, a.value)) : n.value = !1;
  function d(c) {
    n.value = c.matches;
  }
  return { isMobile: n };
}
const Ql = ye({
  name: "OFieldBody",
  configField: "field",
  props: {
    classes: {
      type: Array,
      default: void 0
    }
  },
  setup(e) {
    const { parentField: n } = Lt(), a = xt();
    return () => {
      let t = !0;
      const o = a.default(), i = o.length === 1 && Array.isArray(o[0].children) ? o[0].children : o;
      return na(
        "div",
        { class: e.classes },
        i.map((u) => {
          let d;
          return u.type === xl || u.type === $l ? u : (t && (d = n.value.fieldMessage, t = !1), na(
            Ut("OField"),
            {
              variant: n.value.fieldVariant,
              message: d
            },
            () => [u]
          ));
        })
      );
    };
  }
}), Zl = ["for"], _l = ["for"], Ka = /* @__PURE__ */ ye({
  isOruga: !0,
  name: "OField",
  configField: "field",
  __name: "Field",
  props: {
    /** Override existing theme classes completely */
    override: { type: Boolean, default: void 0 },
    /**
     * Color of the field and help message, also adds a matching icon.
     * Used by Input, Select and Autocomplete.
     * @values primary, info, success, warning, danger, and any other custom color
     */
    variant: { type: String, default: void 0 },
    /** Field label */
    label: { type: String, default: void 0 },
    /**
     * Vertical size of input
     * @values small, medium, large
     */
    labelSize: {
      type: String,
      default: () => r("field.labelsize")
    },
    /** Same as native for set on the label */
    labelFor: { type: String, default: void 0 },
    /** Help message text */
    message: { type: String, default: void 0 },
    /**
     * Direct child components/elements of Field will be grouped horizontally
     * (see which ones at the top of the page).
     */
    grouped: { type: Boolean, default: !1 },
    /** Allow controls to fill up multiple lines, making it responsive */
    groupMultiline: { type: Boolean, default: !1 },
    /** Group label and control on the same line for horizontal forms */
    horizontal: { type: Boolean, default: !1 },
    /** Field automatically attach controls together */
    addons: { type: Boolean, default: !0 },
    /** Mobile breakpoint as max-width value */
    mobileBreakpoint: {
      type: String,
      default: () => r("field.mobileBreakpoint")
    },
    // class props (will not be displayed in the docs)
    /** Class of the root element */
    rootClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class to align label and control in horizontal forms */
    horizontalClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class when fields are grouped together */
    groupedClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class when fields fill up multiple lines */
    groupMultilineClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class for field label */
    labelClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class for field label size */
    labelSizeClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class for field label when horizontal */
    labelHorizontalClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class for field body */
    bodyClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** "Class for field body when horizontal */
    bodyHorizontalClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class for components automatically attached together when inside a field */
    addonsClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class for the field message */
    messageClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the message field variant */
    variantMessageClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the label field variant */
    variantLabelClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of file component when on mobile */
    mobileClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class for the focused field */
    focusedClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class for the filled field */
    filledClass: {
      type: [String, Array, Function],
      default: void 0
    }
  },
  setup(e) {
    const n = e, { isMobile: a } = ct(n.mobileBreakpoint), t = L(n.variant);
    ce(
      () => n.variant,
      (b) => t.value = b
    );
    const o = L(n.message);
    ce(
      () => n.message,
      (b) => o.value = b
    );
    const i = L(!1), u = L(!1), { parentField: d } = Lt();
    ce(
      () => o.value,
      (b) => {
        var D;
        (D = d == null ? void 0 : d.value) != null && D.hasInnerField && (d.value.fieldVariant || d.value.setVariant(t.value), d.value.fieldMessage || d.value.setMessage(b));
      }
    );
    const m = xt(), c = l(() => n.label || !!m.label), v = l(
      () => {
        var b;
        return !!(!((b = d == null ? void 0 : d.value) != null && b.hasInnerField) && o.value) || !!m.message;
      }
    ), p = l(
      () => n.grouped || n.groupMultiline || C()
    );
    function C() {
      if (!n.addons || n.horizontal)
        return !1;
      let b = 0;
      const D = m.default();
      return D && (b = (D.length === 1 && Array.isArray(D[0].children) ? D[0].children : D).filter((G) => !!G).length), b > 1 && n.addons && !n.horizontal;
    }
    const B = L();
    function A(b) {
      i.value = b;
    }
    function g(b) {
      u.value = b;
    }
    function y(b) {
      t.value = b;
    }
    function I(b) {
      o.value = b;
    }
    const k = l(() => ({
      $el: B.value,
      props: n,
      hasInnerField: p.value,
      hasMessage: v.value,
      fieldVariant: t.value,
      fieldMessage: o.value,
      setFocus: A,
      setFilled: g,
      setVariant: y,
      setMessage: I
    }));
    en(k);
    const z = h(
      ["rootClass", "o-field"],
      [
        "horizontalClass",
        "o-field--horizontal",
        null,
        l(() => !!n.horizontal)
      ],
      ["mobileClass", "o-field--mobile", null, a],
      ["focusedClass", "o-field--focused", null, i],
      ["filledClass", "o-field--filled", null, u]
    ), R = h(
      ["messageClass", "o-field__message"],
      [
        "variantMessageClass",
        "o-field__message-",
        t,
        l(() => !!t.value)
      ]
    ), H = h(
      ["labelClass", "o-field__label"],
      [
        "labelSizeClass",
        "o-field__label-",
        l(() => n.labelSize),
        l(() => !!n.labelSize)
      ],
      [
        "variantLabelClass",
        "o-field__label-",
        t,
        l(() => !!t.value)
      ]
    ), j = h([
      "labelHorizontalClass",
      "o-field__horizontal-label"
    ]), U = h(["bodyClass", "o-field__body"]), Q = h([
      "bodyHorizontalClass",
      "o-field__horizontal-body"
    ]), V = h(
      ["rootClass", "o-field"],
      [
        "groupMultilineClass",
        "o-field--grouped-multiline",
        null,
        l(() => n.groupMultiline)
      ],
      ["groupedClass", "o-field--grouped", null, l(() => n.grouped)],
      [
        "addonsClass",
        "o-field--addons",
        null,
        l(() => !n.grouped && C())
      ]
    );
    return (b, D) => (f(), P("div", {
      ref_key: "rootRef",
      ref: B,
      "data-oruga": "field",
      class: M(s(z))
    }, [
      e.horizontal ? (f(), P("div", {
        key: 0,
        class: M(s(j))
      }, [
        c.value ? (f(), P("label", {
          key: 0,
          for: e.labelFor,
          class: M(s(H))
        }, [
          _(b.$slots, "label", {}, () => [
            Pe(ue(e.label), 1)
          ])
        ], 10, Zl)) : J("", !0)
      ], 2)) : (f(), P(he, { key: 1 }, [
        c.value ? (f(), P("label", {
          key: 0,
          for: e.labelFor,
          class: M(s(H))
        }, [
          _(b.$slots, "label", {}, () => [
            Pe(ue(e.label), 1)
          ])
        ], 10, _l)) : J("", !0)
      ], 64)),
      e.horizontal ? (f(), ne(Ql, {
        key: 2,
        classes: s(Q)
      }, {
        default: se(() => [
          _(b.$slots, "default")
        ]),
        _: 3
      }, 8, ["classes"])) : p.value ? (f(), P("div", {
        key: 3,
        class: M(s(U))
      }, [
        le("div", {
          class: M(s(V))
        }, [
          _(b.$slots, "default")
        ], 2)
      ], 2)) : _(b.$slots, "default", { key: 4 }),
      v.value && !e.horizontal ? (f(), P("p", {
        key: 5,
        class: M(s(R))
      }, [
        _(b.$slots, "message", {}, () => [
          Pe(ue(o.value), 1)
        ])
      ], 2)) : J("", !0)
    ], 2));
  }
}), Ua = Symbol();
function en(e) {
  Ia(Ua, e);
}
function Lt() {
  const e = za(Ua, void 0), n = l(() => {
    if (e != null && e.value)
      if (e.value.fieldVariant) {
        if (typeof e.value.fieldVariant == "string")
          return e.value.fieldVariant;
        if (Array.isArray(e.value.fieldVariant)) {
          for (const o in e.value.fieldVariant)
            if (e.value.fieldVariant[o])
              return o;
        }
      } else
        return;
    else
      return;
  }), a = l(
    () => e.value ? "" : e.value.fieldMessage || e.value.hasMessage
  ), t = l(() => r("statusVariantIcon", {
    success: "check",
    danger: "alert-circle",
    info: "information",
    warning: "alert"
  })[n.value] || "");
  return {
    parentField: e,
    statusVariant: n,
    statusVariantIcon: t,
    statusMessage: a
  };
}
const tn = Jl ? [] : [
  HTMLButtonElement,
  HTMLFieldSetElement,
  HTMLInputElement,
  HTMLObjectElement,
  HTMLOutputElement,
  HTMLSelectElement,
  HTMLTextAreaElement
];
function xa(e) {
  return tn.some((n) => e instanceof n) ? e : null;
}
function rt(e, n, a) {
  const { parentField: t } = Lt(), o = l(() => {
    const g = Xe(e);
    if (!g) {
      console.warn("useInputHandler: inputRef contains no element");
      return;
    }
    if (g.getAttribute("data-oruga-input"))
      return g;
    const y = g.querySelector("[data-oruga-input]");
    if (!y) {
      console.warn(
        "useInputHandler: Underlaying Oruga input component not found"
      );
      return;
    }
    return y;
  }), i = L(!1);
  function u() {
    De(() => {
      o.value && o.value.focus();
    });
  }
  function d() {
    De(() => {
      o.value && o.value.click();
    });
  }
  function m(g) {
    i.value = !1, t != null && t.value && t.value.setFocus(!1), n("blur", g), C();
  }
  function c(g) {
    i.value = !0, t != null && t.value && t.value.setFocus(!0), n("focus", g);
  }
  const v = L(!0);
  function p(g, y) {
    De(() => {
      t != null && t.value && (t.value.props.variant || t.value.setVariant(g), t.value.props.message || t.value.setMessage(y));
    });
  }
  function C() {
    if (a.useHtml5Validation && o.value)
      return o.value.validity.valid ? (p(null, null), v.value = !0) : (B(), v.value = !1), v.value;
  }
  function B() {
    const g = "danger", y = a.validationMessage || o.value.validationMessage;
    p(g, y);
  }
  function A(g) {
    C();
    const y = xa(g.target);
    if (y && (t != null && t.value) && a.useHtml5Validation) {
      g.preventDefault();
      let I = !1;
      if (y.form != null) {
        const k = y.form.elements;
        for (let z = 0; z < k.length; ++z) {
          const R = xa(
            k.item(z)
          );
          if (R != null && R.willValidate && !R.validity.valid) {
            I = y === R;
            break;
          }
        }
      }
      if (I) {
        const k = t.value.$el, z = r("invalidHandler");
        if (z instanceof Function)
          z(y, k);
        else {
          const R = k ? k.scrollIntoView != null : !1;
          y.focus({ preventScroll: R }), R && k.scrollIntoView({ block: "nearest" });
        }
      }
    }
    n("invalid", g);
  }
  return {
    isFocused: i,
    isValid: v,
    setFocus: u,
    doClick: d,
    onFocus: c,
    onBlur: m,
    checkHtml5Validity: C,
    onInvalid: A
  };
}
function ia(e, n, a) {
  let t;
  return (...o) => {
    const i = () => {
      t = null, a || e.apply(this, o);
    }, u = a && !t;
    clearTimeout(t), t = setTimeout(i, n), u && e.apply(this, o);
  };
}
function bt(e, n) {
  var p;
  const a = Dt();
  if (!a)
    throw new Error(
      "useProviderChild must be called within a component setup function."
    );
  const t = (p = a.proxy) == null ? void 0 : p.$options.configField, o = n != null && n.key ? n.key : t, i = L([]), u = L(1), d = l(
    () => i.value.slice().sort((C, B) => C.index - B.index)
  );
  function m(C) {
    const B = i.value.length, A = v(), g = { index: B, data: C, identifier: A };
    return i.value.push(g), e != null && e.value && De(() => {
      const y = i.value.map((z) => `[data-id="${o}-${z.identifier}"]`).join(","), I = e.value.querySelectorAll(y), k = Array.from(I).map(
        (z) => z.getAttribute("data-id").replace(`${o}-`, "")
      );
      i.value.forEach(
        (z) => z.index = k.indexOf(`${z.identifier}`)
      );
    }), g;
  }
  function c(C) {
    i.value = i.value.filter((B) => B !== C);
  }
  function v() {
    return String(u.value++);
  }
  return Ia("$o-" + o, {
    registerItem: m,
    unregisterItem: c,
    data: n == null ? void 0 : n.data
  }), {
    childItems: i,
    sortedItems: d
  };
}
function gt(e = { needParent: !0 }) {
  var m;
  const n = Dt();
  if (!n)
    throw new Error(
      "useProviderChild must be called within a component setup function."
    );
  const a = (m = n.proxy) == null ? void 0 : m.$options.configField, t = e != null && e.key ? e.key : a, o = za(
    "$o-" + t,
    void 0
  ), i = typeof e.needParent > "u" || e.needParent, u = typeof e.register > "u" || e.register;
  if (i && !o)
    throw new Error(
      `You should wrap ${n.proxy.$options.name} in a ${t} component`
    );
  const d = L();
  return o && u && (d.value = o.registerItem(e.data)), Ha(() => {
    o && d.value && o.unregisterItem(d.value);
  }), { parent: o == null ? void 0 : o.data, item: d };
}
function Jt(e, n, a, t = { cancelOptions: ["escape", "outside"] }) {
  const o = Dt();
  if (!o)
    throw new Error(
      "useProgrammaticComponent must be called within a component setup function."
    );
  const i = qe("active", n, a), u = l(
    () => typeof n.cancelable == "boolean" ? n.cancelable ? t.cancelOptions : [] : n.cancelable
  );
  function d() {
    return typeof e == "function" ? e() : e.value;
  }
  const m = l(
    () => typeof n.container == "string" ? document.querySelector(n.container) : n.container || document.body
  );
  st(() => {
    if (n.programmatic) {
      n.programmatic.instances && n.programmatic.instances.add(o);
      const C = d();
      m.value.appendChild(C), i.value = !0;
    }
  }), Be && Ze("keyup", c, m.value);
  function c(C) {
    i.value && (C.key === "Escape" || C.key === "Esc") && v("escape");
  }
  function v(C) {
    !n.cancelable || !i.value || u.value.indexOf(C) < 0 || (n.onCancel.apply(null), p({ action: "cancel", method: C }));
  }
  function p(...C) {
    o.emit("close"), n.onClose.apply(null, C), n.programmatic ? (n.programmatic.instances && n.programmatic.instances.remove(o), n.programmatic.resolve && n.programmatic.resolve.apply(null, C), setTimeout(() => {
      if (o.props.active = !1, o.emit("update:active", !1), typeof t.destroyOnHide > "u" || t.destroyOnHide)
        if (Be)
          window.requestAnimationFrame(() => {
            const B = d();
            B && oa(B);
          });
        else {
          const B = d();
          B && oa(B);
        }
    })) : (o.props.active = !1, o.emit("update:active", !1));
  }
  return { close: p, cancel: v, isActive: i, container: m };
}
function fa(e, n, a = []) {
  if (!window)
    return;
  const t = (u) => a.some((d) => {
    if (typeof d == "string")
      return Array.from(
        window.document.querySelectorAll(d)
      ).some(
        (m) => m === u.target || u.composedPath().includes(m)
      );
    {
      const m = Xe(d);
      return m && (u.target === m || u.composedPath().includes(m));
    }
  });
  return Ze("click", (u) => {
    const d = Xe(e);
    !d || d === u.target || u.composedPath().includes(d) || t(u) || n(u);
  }, window, {
    immediate: !0,
    passive: !0
  });
}
function an(e) {
  if (e.style.position === "fixed" || !e)
    return document.documentElement;
  let n = !1, a = e.parentElement;
  for (; !n && ot(a) && a !== document.documentElement; ) {
    const { overflow: t, overflowY: o } = getComputedStyle(a), { scrollHeight: i, clientHeight: u } = a;
    if (n = /(auto|scroll)/.test(`${t}${o}`) && i > u, n)
      break;
    a = a.parentElement;
  }
  return a;
}
const Re = /* @__PURE__ */ ye({
  isOruga: !0,
  name: "OIcon",
  configField: "icon",
  __name: "Icon",
  props: {
    /** Override existing theme classes completely */
    override: { type: Boolean, default: void 0 },
    /** Icon component name */
    component: {
      type: String,
      default: () => r("iconComponent")
    },
    /**
     * Icon pack to use
     * @values mdi, fa, fas and any other custom icon pack
     */
    pack: {
      type: String,
      default: () => r("iconPack", "mdi")
    },
    /**
     * 	Color of the icon
     *  @values primary, info, success, warning, danger, and any other custom color
     */
    variant: {
      type: String,
      default: () => r("icon.variant")
    },
    /** Icon name */
    icon: { type: String, default: void 0 },
    /**
     * Icon size
     * @values small, medium, large
     */
    size: {
      type: String,
      default: () => r("icon.size")
    },
    /**
     * Overrides icon font size
     * @values Depends on library: null (smallest), fa-sm, fa-lg, fa-xl, mdi-18px, mdi-24px, mdi-36px, mdi-48px
     */
    customSize: { type: String, default: void 0 },
    /**
     * Add class to icon font.
     * See icon library documentation for custom classes.
     */
    customClass: { type: String, default: void 0 },
    /** When true makes icon clickable */
    clickable: { type: Boolean, default: !1 },
    /** Enable spin effect on icon */
    spin: { type: Boolean, default: !1 },
    /** Rotation 0-360 */
    rotation: { type: [Number, String], default: void 0 },
    /**
     * This is used internally
     * @ignore
     */
    both: { type: Boolean, default: !1 },
    // class props (will not be displayed in the docs)
    /** Class of the root element */
    rootClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the icon when clickable */
    clickableClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the element when spin */
    spinClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the icon size */
    sizeClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the icon variant */
    variantClass: {
      type: [String, Array, Function],
      default: void 0
    }
  },
  setup(e) {
    const n = e, a = l(() => {
      const p = {};
      return n.rotation && (p.transform = `rotate(${n.rotation}deg)`), p;
    }), t = l(() => Xl()[n.pack]), o = l(
      () => {
        var p;
        return (p = t.value) != null && p.iconPrefix ? t.value.iconPrefix : "";
      }
    ), i = l(() => {
      var p;
      if ((p = t.value) != null && p.sizes) {
        if (n.size && t.value.sizes[n.size] !== void 0)
          return t.value.sizes[n.size];
        if (t.value.sizes.default)
          return t.value.sizes.default;
      }
      return null;
    }), u = l(
      () => `${o.value}${c(n.icon)}`
    ), d = l(() => n.customSize || i.value), m = l(() => {
      if (!n.variant)
        return;
      let p = "";
      return typeof n.variant == "string" ? p = n.variant : p = Object.keys(n.variant).filter(
        (C) => n.variant[C]
      )[0], p;
    });
    function c(p) {
      var C, B;
      return n.both && (C = t.value) != null && C.internalIcons && (B = t.value) != null && B.internalIcons[p] ? t.value.internalIcons[p] : p;
    }
    const v = h(
      ["rootClass", "o-icon"],
      [
        "clickableClass",
        "o-icon--clickable",
        null,
        l(() => n.clickable)
      ],
      ["spinClass", "o-icon--spin", null, l(() => n.spin)],
      [
        "sizeClass",
        "o-icon--",
        l(() => n.size),
        l(() => !!n.size)
      ],
      [
        "variantClass",
        "o-icon--",
        m,
        l(() => !!m.value)
      ]
    );
    return (p, C) => (f(), P("span", {
      class: M(s(v)),
      "data-oruga": "icon",
      style: _e(a.value)
    }, [
      e.component ? (f(), ne(Ge(e.component), {
        key: 0,
        icon: [e.pack, u.value],
        size: d.value,
        class: M([e.customClass])
      }, null, 8, ["icon", "size", "class"])) : (f(), P("i", {
        key: 1,
        class: M([e.pack, u.value, d.value, e.customClass])
      }, null, 2))
    ], 6));
  }
}), ln = ["data-oruga-input", "type", "maxlength", "autocomplete", "placeholder", "disabled", "aria-labelledby"], nn = ["maxlength", "placeholder", "disabled", "aria-labelledby"], At = /* @__PURE__ */ ye({
  isOruga: !0,
  name: "OInput",
  configField: "input",
  inheritAttrs: !1,
  __name: "Input",
  props: {
    /** Override existing theme classes completely */
    override: { type: Boolean, default: void 0 },
    /** @model */
    modelValue: { type: [String, Number], default: "" },
    /**
     * Input type, like native
     * @values Any native input type, and textarea
     */
    type: { type: String, default: "text" },
    /**
     * Size of the control
     * @values small, medium, large
     */
    size: {
      type: String,
      default: () => r("input.size")
    },
    /**
     * Color of the control
     * @values primary, info, success, warning, danger, and any other custom color
     */
    variant: {
      type: String,
      default: () => r("input.variant")
    },
    /** Input placeholder */
    placeholder: { type: String, default: void 0 },
    /** Makes input full width when inside a grouped or addon field */
    expanded: { type: Boolean, default: !1 },
    /** Makes the element rounded */
    rounded: { type: Boolean, default: !1 },
    /** Same as native disabled */
    disabled: { type: Boolean, default: !1 },
    /** Adds the reveal password functionality */
    passwordReveal: { type: Boolean, default: !1 },
    /** Same as native maxlength, plus character counter */
    maxlength: { type: [Number, String], default: void 0 },
    /** Show character counter when maxlength prop is passed */
    counter: {
      type: Boolean,
      default: () => r("input.counter", !1)
    },
    /** Automatically adjust height in textarea */
    autosize: { type: Boolean, default: !1 },
    /**
     * Icon pack to use
     * @values mdi, fa, fas and any other custom icon pack
     */
    iconPack: {
      type: String,
      default: () => r("input.iconPack", void 0)
    },
    /** Icon to be shown */
    icon: {
      type: String,
      default: () => r("input.icon", void 0)
    },
    /** Makes the icon clickable */
    iconClickable: { type: Boolean, default: !1 },
    /** Icon to be added on the right side */
    iconRight: {
      type: String,
      default: () => r("input.iconRight", void 0)
    },
    /** Make the icon right clickable */
    iconRightClickable: { type: Boolean, default: !1 },
    /** Variant of right icon */
    iconRightVariant: { type: String, default: void 0 },
    /** Add a button/icon to clear the inputed text */
    clearable: {
      type: Boolean,
      default: () => r("input.clearable", !1)
    },
    /** Icon name to be added on the clear button */
    clearIcon: {
      type: String,
      default: () => r("input.clearIcon", "close-circle")
    },
    /** Show status icon using field and variant prop */
    statusIcon: {
      type: Boolean,
      default: () => r("statusIcon", !0)
    },
    /** Native options to use in HTML5 validation */
    autocomplete: {
      type: String,
      default: () => r("input.autocomplete", "off")
    },
    /** Accessibility label to establish relationship between the checkbox and control label */
    ariaLabelledby: { type: String, default: () => Ye() },
    /** Enable html 5 native validation */
    useHtml5Validation: {
      type: Boolean,
      default: () => r("useHtml5Validation", !0)
    },
    /** The message which is shown when a validation error occurs */
    validationMessage: { type: String, default: void 0 },
    // class props (will not be displayed in the docs)
    /** Class of the root element */
    rootClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of input when expanded */
    expandedClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of input when type textarea */
    textareaClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the left icon space inside the input */
    iconLeftSpaceClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the right icon space inside the input */
    iconRightSpaceClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the native input element */
    inputClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of input when rounded */
    roundedClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of input when disabled */
    disabledClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the left icon */
    iconLeftClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the right icon */
    iconRightClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class to display when a right icon is used */
    hasIconRightClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the counter element */
    counterClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the input size */
    sizeClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the input variant */
    variantClass: {
      type: [String, Array, Function],
      default: void 0
    }
  },
  emits: ["update:modelValue", "input", "focus", "blur", "invalid", "icon-click", "icon-right-click"],
  setup(e, { expose: n, emit: a }) {
    const t = e, o = a, i = L(), u = L(), d = l(
      () => t.type === "textarea" ? u.value : i.value
    ), {
      checkHtml5Validity: m,
      onBlur: c,
      onFocus: v,
      onInvalid: p,
      setFocus: C,
      isValid: B,
      isFocused: A
    } = rt(d, o, t), { parentField: g, statusVariant: y, statusVariantIcon: I } = Lt(), k = dt(t, o, {
      passive: !0
    }), z = l(
      () => typeof k.value == "string" ? k.value.length : typeof k.value == "number" ? k.value.toString().length : 0
    );
    st(() => {
      ce(
        () => k.value,
        (K) => {
          g != null && g.value && g.value.setFilled(!!K), t.autosize && H(), B.value || De(() => m());
        },
        { immediate: !0 }
      );
    });
    const R = L("auto");
    function H() {
      R.value = "auto", De(() => {
        if (u.value) {
          const K = u.value.scrollHeight;
          R.value = K + "px";
        }
      });
    }
    const j = l(
      () => t.autosize ? {
        resize: "none",
        height: R.value,
        overflow: "hidden"
      } : {}
    );
    function U(K) {
      o("input", k.value, K);
    }
    const Q = l(() => !!(t.passwordReveal || t.statusIcon && I.value || t.clearable && k.value && t.clearIcon || t.iconRight)), V = l(() => t.passwordReveal ? S.value : t.clearable && k.value && t.clearIcon ? t.clearIcon : t.iconRight ? t.iconRight : I.value), b = l(
      () => t.passwordReveal || t.iconRight ? t.iconRightVariant || t.variant || null : y.value
    );
    function D(K, ie) {
      o(K, ie), De(() => C());
    }
    function W(K) {
      t.passwordReveal ? w() : t.clearable && (k.value = ""), t.iconRightClickable && D("icon-right-click", K);
    }
    const G = L(!1), E = l(() => t.passwordReveal ? G.value ? "text" : "password" : t.type), S = l(
      () => G.value ? "eye-off" : "eye"
    );
    function w() {
      G.value = !G.value, De(() => C());
    }
    const $ = h(
      ["rootClass", "o-input__wrapper"],
      [
        "expandedClass",
        "o-input__wrapper--expanded",
        null,
        l(() => t.expanded)
      ],
      [
        "hasIconRightClass",
        "o-input__wrapper--has-icon-right",
        null,
        Q
      ]
    ), N = h(
      ["inputClass", "o-input"],
      ["roundedClass", "o-input--rounded", null, l(() => t.rounded)],
      [
        "sizeClass",
        "o-input--",
        l(() => t.size),
        l(() => !!t.size)
      ],
      [
        "variantClass",
        "o-input--",
        l(() => y.value || t.variant),
        l(() => !!y.value || !!t.variant)
      ],
      [
        "disabledClass",
        "o-input--disabled",
        null,
        l(() => t.disabled)
      ],
      [
        "textareaClass",
        "o-input__textarea",
        null,
        l(() => t.type === "textarea")
      ],
      [
        "iconLeftSpaceClass",
        "o-input--iconspace-left",
        null,
        l(() => !!t.icon)
      ],
      ["iconRightSpaceClass", "o-input--iconspace-right", null, Q]
    ), ae = h(["iconLeftClass", "o-input__icon-left"]), O = h([
      "iconRightClass",
      "o-input__icon-right"
    ]), x = h(["counterClass", "o-input__counter"]);
    return n({ focus: C }), (K, ie) => (f(), P("div", {
      "data-oruga": "input",
      class: M(s($))
    }, [
      e.type !== "textarea" ? $e((f(), P("input", be({ key: 0 }, K.$attrs, {
        ref_key: "inputRef",
        ref: i,
        "onUpdate:modelValue": ie[0] || (ie[0] = (fe) => Ke(k) ? k.value = fe : null),
        "data-oruga-input": E.value,
        type: E.value,
        class: s(N),
        maxlength: e.maxlength,
        autocomplete: e.autocomplete,
        placeholder: e.placeholder,
        disabled: e.disabled,
        "aria-labelledby": e.ariaLabelledby,
        onBlur: ie[1] || (ie[1] = //@ts-ignore
        (...fe) => s(c) && s(c)(...fe)),
        onFocus: ie[2] || (ie[2] = //@ts-ignore
        (...fe) => s(v) && s(v)(...fe)),
        onInvalid: ie[3] || (ie[3] = //@ts-ignore
        (...fe) => s(p) && s(p)(...fe)),
        onInput: U
      }), null, 16, ln)), [
        [Bl, s(k)]
      ]) : $e((f(), P("textarea", be({ key: 1 }, K.$attrs, {
        ref_key: "textareaRef",
        ref: u,
        "onUpdate:modelValue": ie[4] || (ie[4] = (fe) => Ke(k) ? k.value = fe : null),
        "data-oruga-input": "textarea",
        class: s(N),
        maxlength: e.maxlength,
        style: j.value,
        placeholder: e.placeholder,
        disabled: e.disabled,
        "aria-labelledby": e.ariaLabelledby,
        onBlur: ie[5] || (ie[5] = //@ts-ignore
        (...fe) => s(c) && s(c)(...fe)),
        onFocus: ie[6] || (ie[6] = //@ts-ignore
        (...fe) => s(v) && s(v)(...fe)),
        onInvalid: ie[7] || (ie[7] = //@ts-ignore
        (...fe) => s(p) && s(p)(...fe)),
        onInput: U
      }), null, 16, nn)), [
        [Ol, s(k)]
      ]),
      e.icon ? (f(), ne(Re, {
        key: 2,
        class: M(s(ae)),
        clickable: e.iconClickable,
        icon: e.icon,
        pack: e.iconPack,
        size: e.size,
        onClick: ie[8] || (ie[8] = (fe) => D("icon-click", fe))
      }, null, 8, ["class", "clickable", "icon", "pack", "size"])) : J("", !0),
      Q.value ? (f(), ne(Re, {
        key: 3,
        class: M(s(O)),
        clickable: e.passwordReveal || e.clearable || e.iconRightClickable,
        icon: V.value,
        pack: e.iconPack,
        size: e.size,
        variant: b.value,
        both: "",
        onClick: W
      }, null, 8, ["class", "clickable", "icon", "pack", "size", "variant"])) : J("", !0),
      e.maxlength && e.counter && s(A) && e.type !== "number" ? (f(), P("small", {
        key: 4,
        class: M(s(x))
      }, ue(z.value) + " / " + ue(e.maxlength), 3)) : J("", !0)
    ], 2));
  }
}), qa = /* @__PURE__ */ ye({
  inheritAttrs: !1,
  __name: "PositionWrapper",
  props: {
    teleport: {
      type: [Boolean, String, Object],
      required: !0
    },
    trigger: {
      type: Object,
      default: void 0
    },
    content: {
      type: Object,
      default: void 0
    },
    /**
     * Position of the component relative to the trigger
     * @values auto, top, bottom, left, right, top-right, top-left, bottom-left, bottom-right
     */
    position: {
      type: String,
      validator: (e) => [
        "auto",
        "top",
        "bottom",
        "left",
        "right",
        "top-right",
        "top-left",
        "bottom-left",
        "bottom-right"
      ].indexOf(e) > -1,
      default: void 0
    },
    /** Used for calculation position auto */
    defaultPosition: {
      type: String,
      validator: (e) => ["top", "bottom", "left", "right"].indexOf(e) > -1,
      default: "top"
    },
    /** disable the position calculation */
    disabled: { type: Boolean, default: !1 },
    /** update positioning on teleport */
    disablePositioning: { type: Boolean, default: !0 }
  },
  emits: ["update:position"],
  setup(e, { emit: n }) {
    const a = {
      top: "bottom",
      bottom: "top",
      right: "left",
      left: "right"
    }, t = e, o = n, i = l(
      () => typeof t.teleport == "boolean" ? "body" : t.teleport
    ), u = l(
      () => typeof t.teleport == "boolean" || !t.teleport ? !t.teleport : !1
    ), d = t.position, m = L(void 0), c = L(null);
    Be && window.ResizeObserver && (c.value = new window.ResizeObserver(C)), ce(
      [() => t.disabled, () => t.content],
      () => {
        t.disabled ? p() : v();
      },
      { immediate: !0 }
    ), ce(
      [
        () => t.trigger,
        () => t.content,
        () => t.disablePositioning,
        () => t.disabled
      ],
      () => {
        De(() => C());
      },
      { immediate: !0 }
    ), It(() => p());
    function v() {
      Be && !m.value && t.content && (m.value = an(Xe(t.content)), m.value && m.value !== document.documentElement ? (m.value.addEventListener(
        "scroll",
        C,
        { passive: !0 }
      ), window.ResizeObserver && c.value.observe(m.value)) : (document.addEventListener("scroll", C, {
        passive: !0
      }), window.addEventListener("resize", C)));
    }
    function p() {
      var y;
      Be && (window.ResizeObserver && ((y = c.value) == null || y.disconnect()), window.removeEventListener("resize", C), document.removeEventListener("scroll", C), m.value = void 0);
    }
    function C() {
      if (t.disabled)
        return;
      let y = t.position;
      if (d === "auto" && (y = B(), y != t.position && o("update:position", y)), !t.teleport)
        return;
      const I = Xe(t.content), k = Xe(t.trigger);
      if (I && k) {
        const z = k.getBoundingClientRect();
        let R = z.top + window.scrollY, H = z.left + window.scrollX;
        y.includes("bottom") ? R += k.clientHeight : y.includes("top") && (R -= I.clientHeight), y === "left" ? H -= I.clientWidth : y === "right" ? H += k.clientWidth : y.includes("-right") && (H += k.clientWidth - I.clientWidth), (y === "top" || y === "bottom") && (H += k.clientWidth / 2), (y === "left" || y === "right") && (R += k.clientHeight / 2), t.disablePositioning ? (I.style.position = "relative", I.style.top = `${R}px`, I.style.left = `${H}px`) : (I.style.position = "", I.style.top = "", I.style.left = "");
      }
    }
    function B() {
      let y = t.defaultPosition;
      if (!t.content || !t.trigger || !m.value)
        return y;
      const I = new DOMRect(
        m.value.offsetLeft,
        m.value.offsetTop,
        m.value.clientWidth,
        m.value.clientHeight
      ), k = Xe(t.content).getBoundingClientRect(), z = Xe(t.trigger).getBoundingClientRect(), R = g(z), H = g(k), j = (W) => {
        const G = R[W], E = H[a[W]];
        return new DOMRect(
          k.x + (G.x - E.x),
          k.y + (G.y - E.y),
          k.width,
          k.height
        );
      }, U = a[t.defaultPosition], Q = t.defaultPosition === "top" || t.defaultPosition === "bottom" ? "left" : "top", V = a[Q], b = [
        t.defaultPosition,
        U,
        Q,
        V
      ];
      let D = 0;
      for (const W of b) {
        const G = A(
          I,
          j(W)
        );
        G > D && (D = G, y = W);
      }
      return y;
    }
    function A(y, I) {
      const k = Math.max(y.left, I.left), z = Math.min(y.right, I.right), R = Math.max(y.top, I.top), H = Math.min(y.bottom, I.bottom);
      return Math.max(z - k, 0) * Math.max(H - R, 0);
    }
    const g = (y) => ({
      top: { x: (y.left + y.right) * 0.5, y: y.top },
      bottom: { x: (y.left + y.right) * 0.5, y: y.bottom },
      left: { x: y.left, y: (y.top + y.bottom) * 0.5 },
      right: { x: y.right, y: (y.top + y.bottom) * 0.5 }
    });
    return (y, I) => (f(), ne(ua, {
      to: i.value,
      disabled: u.value
    }, [
      u.value ? _(y.$slots, "default", { key: 0 }) : (f(), P("div", be({ key: 1 }, y.$attrs, { style: { position: "absolute", left: "0px", top: "0px" } }), [
        _(y.$slots, "default")
      ], 16))
    ], 8, ["to", "disabled"]));
  }
}), Nt = (e, n = !1) => e ? n ? e.querySelectorAll('*[tabindex="-1"]') : e.querySelectorAll(`a[href]:not([tabindex="-1"]),
                                     area[href],
                                     input:not([disabled]),
                                     select:not([disabled]),
                                     textarea:not([disabled]),
                                     button:not([disabled]),
                                     iframe,
                                     object,
                                     embed,
                                     *[tabindex]:not([tabindex="-1"]),
                                     *[contenteditable]`) : null;
let sa;
const on = (e, { value: n = !0 }) => {
  if (n) {
    let a = Nt(e), t = Nt(e, !0);
    a && a.length > 0 && (sa = (o) => {
      a = Nt(e), t = Nt(e, !0);
      const i = a[0], u = a[a.length - 1];
      o.target === i && o.shiftKey && o.key === "Tab" ? (o.preventDefault(), u.focus()) : (o.target === u || Array.from(t).indexOf(o.target) >= 0) && !o.shiftKey && o.key === "Tab" && (o.preventDefault(), i.focus());
    }, e.addEventListener("keydown", sa));
  }
}, sn = (e) => {
  e.removeEventListener("keydown", sa);
}, rn = {
  beforeMount: on,
  beforeUnmount: sn
}, Xa = rn, un = ["aria-hidden"], va = /* @__PURE__ */ ye({
  isOruga: !0,
  name: "ODropdown",
  configField: "dropdown",
  __name: "Dropdown",
  props: /* @__PURE__ */ Ue({
    /** Override existing theme classes completely */
    override: { type: Boolean, default: void 0 },
    /** @model */
    modelValue: {
      type: [String, Number, Boolean, Object, Array],
      default: void 0
    },
    /** The active state of the dropdown, use v-model:active to make it two-way binding. */
    active: { type: Boolean, default: !1 },
    /** Trigger label, unnecessary when trgger slot is used */
    label: { type: String, default: void 0 },
    /** Dropdown is disabled */
    disabled: { type: Boolean, default: !1 },
    /** Dropdown content (items) are shown inline, trigger is removed */
    inline: { type: Boolean, default: !1 },
    /** Dropdown content will be scrollable */
    scrollable: { type: Boolean, default: !1 },
    /** Max height of dropdown content */
    maxHeight: {
      type: [String, Number],
      default: () => r("dropdown.maxHeight", 200)
    },
    /**
     * Position of the dropdown relative to the trigger
     * @values auto, top, bottom, left, right, top-right, top-left, bottom-left, bottom-right
     */
    position: {
      type: String,
      default: () => r("dropdown.position", "bottom-left"),
      validator: (e) => [
        "auto",
        "top",
        "bottom",
        "left",
        "right",
        "top-right",
        "top-left",
        "bottom-left",
        "bottom-right"
      ].indexOf(e) > -1
    },
    /** Dropdown content (items) are shown into a modal on mobile */
    mobileModal: {
      type: Boolean,
      default: () => r("dropdown.mobileModal", !0)
    },
    /** Custom animation (transition name) */
    animation: {
      type: String,
      default: () => r("dropdown.animation", "fade")
    },
    /** Allows multiple selections */
    multiple: { type: Boolean, default: !1 },
    /** Trap focus inside the dropdown. */
    trapFocus: {
      type: Boolean,
      default: () => r("dropdown.trapFocus", !0)
    },
    /** Makes the component check if menu reached scroll start or end and emit scroll events. */
    checkScroll: {
      type: Boolean,
      default: () => r("dropdown.checkScroll", !1)
    },
    /** Dropdown will be expanded (full-width) */
    expanded: { type: Boolean, default: !1 },
    /** HTML element ID of the dropdown menu element */
    menuId: { type: String, default: null },
    /** Tabindex of the dropdown menu element */
    menuTabindex: { type: Number, default: null },
    /** Dropdown menu tag name */
    menuTag: {
      type: [String, Object, Function],
      default: () => r("dropdown.menuTag", "div")
    },
    /** Dropdown trigger tag name */
    triggerTag: {
      type: [String, Object, Function],
      default: () => r("dropdown.triggerTag", "div")
    },
    /**
     * Dropdown will be triggered by any events
     * @values click, hover, contextmenu, focus
     */
    triggers: {
      type: Array,
      default: () => r("dropdown.triggers", ["click"]),
      validator: (e) => e.filter(
        (n) => ["click", "hover", "contextmenu", "focus"].indexOf(n) > -1
      ).length === e.length
    },
    /** Dropdown delay before it appears (number in ms) */
    delay: { type: Number, default: void 0 },
    /**
     * Dropdown close options (pressing escape, clicking the content or outside)
     * @values true, false, escape, outside, content
     */
    closeable: {
      type: [Array, Boolean],
      default: () => r("dropdown.closeable", ["escape", "outside", "content"])
    },
    /** Set the tabindex attribute on the dropdown trigger div (-1 to prevent selection via tab key) */
    tabindex: { type: Number, default: 0 },
    /**
     * Role attribute to be passed to the list container for better accessibility.
     * Use menu only in situations where your dropdown is related to a navigation menu.
     * @values list, listbox, menu, dialog
     */
    ariaRole: {
      type: String,
      default: r("dropdown.ariaRole", "list"),
      validator: (e) => ["list", "listbox", "menu", "dialog"].indexOf(e) > -1
    },
    /** Mobile breakpoint as max-width value */
    mobileBreakpoint: {
      type: String,
      default: () => r("dropdown.mobileBreakpoint")
    },
    /**
     * Append the component to another part of the DOM.
     * Set `true` to append the component to the body.
     * In addition, any CSS selector string or an actual DOM node can be used.
     */
    teleport: {
      type: [Boolean, String, Object],
      default: () => r("dropdown.teleport", !1)
    },
    // class props (will not be displayed in the docs)
    /** Class of the root element */
    rootClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class when the dropdown is teleported */
    teleportClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the trigger element */
    triggerClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of dropdown menu when inline */
    inlineClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the overlay when on mobile */
    menuMobileOverlayClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the dropdown menu */
    menuClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of dropdown menu position */
    menuPositionClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of dropdown menu when active */
    menuActiveClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of dropdown when on mobile */
    mobileClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of dropdown when disabled */
    disabledClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of dropdown when expanded */
    expandedClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class for the root element indicating position of dropdown */
    positionClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class for the root element indicating whether the dropdown is open */
    activeClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class for the root element when the dropdown is hoverable */
    hoverableClass: {
      type: [String, Array, Function],
      default: void 0
    }
  }, {
    modelValue: {},
    modelModifiers: {},
    active: { type: Boolean },
    activeModifiers: {}
  }),
  emits: /* @__PURE__ */ Ue(["update:modelValue", "update:active", "change", "close", "scroll-start", "scroll-end"], ["update:modelValue", "update:active"]),
  setup(e, { expose: n, emit: a }) {
    const t = e, o = a, i = it(e, "modelValue"), u = it(e, "active"), d = L(t.position);
    ce(
      () => t.position,
      (x) => d.value = x
    );
    const { isMobile: m } = ct(t.mobileBreakpoint), c = l(
      () => m.value && t.mobileModal && !t.inline
    ), v = l(() => t.mobileModal && vt.any()), p = l(() => ({
      maxHeight: t.scrollable ? Ft(t.maxHeight) : null,
      overflow: t.scrollable ? "auto" : null
    })), C = l(() => t.triggers.indexOf("hover") >= 0), B = L(), A = L(), g = [];
    let y;
    ce(
      u,
      (x) => {
        x && Be ? setTimeout(() => {
          I.value.indexOf("outside") >= 0 && g.push(
            fa(B, k, [
              A
            ])
          ), I.value.indexOf("escape") >= 0 && g.push(
            Ze("keyup", z, document, {
              immediate: !0
            })
          );
        }) : x || (g.forEach((K) => K()), g.length = 0);
      },
      { immediate: !0 }
    ), Ha(() => {
      g.forEach((x) => x()), g.length = 0;
    });
    const I = l(
      () => typeof t.closeable == "boolean" ? t.closeable ? ["escape", "outside", "content"] : [] : t.closeable
    );
    function k() {
      !u.value || t.inline || I.value.indexOf("outside") < 0 || (o("close", "outside"), u.value = !1);
    }
    function z(x) {
      if (u.value && (x.key === "Escape" || x.key === "Esc")) {
        if (I.value.indexOf("escape") < 0)
          return;
        o("close", "escape"), u.value = !1;
      }
    }
    function R() {
      t.triggers.indexOf("click") < 0 || b();
    }
    function H(x) {
      t.triggers.indexOf("contextmenu") < 0 || (x.preventDefault(), D());
    }
    function j() {
      t.triggers.indexOf("focus") < 0 || D();
    }
    const U = L(!1);
    function Q() {
      !v.value && t.triggers.indexOf("hover") >= 0 && (U.value = !0, D());
    }
    function V() {
      !v.value && U.value && (U.value = !1, W());
    }
    function b() {
      t.disabled || (u.value ? u.value = !u.value : De(() => u.value = !u.value));
    }
    function D() {
      t.disabled || (t.delay ? y = setTimeout(() => {
        u.value = !0, y = null;
      }, t.delay) : u.value = !0);
    }
    function W() {
      I.value.indexOf("content") < 0 || (o("close", "content"), u.value = !t.closeable, y && t.closeable && clearTimeout(y));
    }
    Be && t.checkScroll && Ze("scroll", G, B);
    function G() {
      const x = Xe(B.value);
      x.clientHeight !== x.scrollHeight && (x.scrollTop + x.clientHeight >= x.scrollHeight ? o("scroll-end") : x.scrollTop <= 0 && o("scroll-start"));
    }
    function E(x) {
      if (t.multiple ? (i.value && Array.isArray(i.value) ? i.value.indexOf(x) === -1 ? i.value = [...i.value, x] : i.value = i.value.filter((K) => K !== x) : i.value = [x], De(() => o("change", i.value))) : i.value !== x && (i.value = x, De(() => o("change", i.value))), !t.multiple) {
        if (I.value.indexOf("content") < 0)
          return;
        o("close", "content"), u.value = !1, U.value = !1;
      }
    }
    const S = l(() => ({
      props: t,
      selected: i.value,
      selectItem: E
    }));
    bt(B, { data: S });
    const w = h(
      ["rootClass", "o-drop"],
      ["disabledClass", "o-drop--disabled", null, l(() => t.disabled)],
      ["expandedClass", "o-drop--expanded", null, l(() => t.expanded)],
      ["inlineClass", "o-drop--inline", null, l(() => t.inline)],
      [
        "mobileClass",
        "o-drop--mobile",
        null,
        l(() => c.value && !C.value)
      ],
      [
        "positionClass",
        "o-drop--position-",
        d,
        l(() => !!d.value)
      ],
      [
        "activeClass",
        "o-drop--active",
        null,
        l(() => u.value || t.inline)
      ],
      ["hoverableClass", "o-drop--hoverable", null, C]
    ), $ = h(["triggerClass", "o-drop__trigger"]), N = h([
      "teleportClass",
      "o-drop--teleport",
      null,
      l(() => !!t.teleport)
    ]), ae = h([
      "menuMobileOverlayClass",
      "o-drop__overlay"
    ]), O = h(
      ["menuClass", "o-drop__menu"],
      [
        "menuPositionClass",
        "o-drop__menu--",
        d,
        l(() => !!d.value)
      ],
      [
        "menuActiveClass",
        "o-drop__menu--active",
        null,
        l(() => u.value || t.inline)
      ]
    );
    return n({ $trigger: A, $content: B }), (x, K) => (f(), P("div", {
      "data-oruga": "dropdown",
      class: M(s(w)),
      onMouseleave: V,
      onFocusout: V
    }, [
      e.inline ? J("", !0) : (f(), ne(Ge(e.triggerTag), {
        key: 0,
        ref_key: "triggerRef",
        ref: A,
        tabindex: e.disabled ? null : e.tabindex,
        class: M(s($)),
        "aria-haspopup": e.ariaRole === "list" ? !0 : e.ariaRole,
        onClick: R,
        onContextmenu: H,
        onMouseenter: Q,
        onFocusCapture: j
      }, {
        default: se(() => [
          _(x.$slots, "trigger", { active: u.value }, () => [
            Pe(ue(e.label), 1)
          ])
        ]),
        _: 3
      }, 40, ["tabindex", "class", "aria-haspopup"])),
      me(qa, {
        position: d.value,
        "onUpdate:position": K[0] || (K[0] = (ie) => d.value = ie),
        teleport: e.teleport,
        class: M([...s(w), ...s(N)]),
        trigger: A.value,
        content: B.value,
        disabled: !u.value,
        "default-position": "bottom",
        "disable-positioning": !c.value
      }, {
        default: se(() => [
          me(et, { name: e.animation }, {
            default: se(() => [
              c.value ? $e((f(), P("div", {
                key: 0,
                tabindex: -1,
                class: M(s(ae)),
                "aria-hidden": e.disabled || !u.value
              }, null, 10, un)), [
                [ze, u.value]
              ]) : J("", !0)
            ]),
            _: 1
          }, 8, ["name"]),
          me(et, { name: e.animation }, {
            default: se(() => [
              $e((f(), ne(Ge(e.menuTag), {
                id: e.menuId,
                ref_key: "contentRef",
                ref: B,
                tabindex: e.menuTabindex,
                class: M(s(O)),
                style: _e(p.value),
                role: e.ariaRole,
                "aria-hidden": e.disabled || !u.value,
                "aria-modal": !e.inline && e.trapFocus
              }, {
                default: se(() => [
                  _(x.$slots, "default", {
                    active: u.value,
                    toggle: b
                  })
                ]),
                _: 3
              }, 8, ["id", "tabindex", "class", "style", "role", "aria-hidden", "aria-modal"])), [
                [ze, !e.disabled && (u.value || U.value) || e.inline],
                [s(Xa), e.trapFocus]
              ])
            ]),
            _: 3
          }, 8, ["name"])
        ]),
        _: 3
      }, 8, ["position", "teleport", "class", "trigger", "content", "disabled", "disable-positioning"])
    ], 34));
  }
}), ht = /* @__PURE__ */ ye({
  isOruga: !0,
  name: "ODropdownItem",
  configField: "dropdown",
  __name: "DropdownItem",
  props: {
    /** The value that will be returned on events and v-model - default is a uuid */
    value: {
      type: [String, Number, Boolean, Object, Array],
      default: void 0
      // () => uuid(),
    },
    /** Item label, unnecessary when default slot is used */
    label: { type: String, default: void 0 },
    /** Item is disabled */
    disabled: { type: Boolean, default: !1 },
    /** Item is clickable and emit an event */
    clickable: { type: Boolean, default: !0 },
    /** Dropdown item tag name */
    tag: {
      type: [String, Object, Function],
      default: () => r("dropdown.itemTag", "div")
    },
    /** Set the tabindex attribute on the dropdown item div (-1 to prevent selection via tab key) */
    tabindex: { type: [Number, String], default: 0 },
    /**
     * Role attribute to be passed to the list item for better accessibility.
     * Use menuitem only in situations where your dropdown is related to a navigation menu.
     * @values listitem, menuitem, button
     */
    ariaRole: {
      type: String,
      default: r("dropdown.itemAriaRole", "listitem")
    },
    // class props (will not be displayed in the docs)
    /** Class of the dropdown item */
    itemClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the dropdown item when active  */
    itemActiveClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the dropdown item when clickable */
    itemClickableClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the dropdown item when disabled */
    itemDisabledClass: {
      type: [String, Array, Function],
      default: void 0
    }
  },
  emits: ["click"],
  setup(e, { emit: n }) {
    const a = e, t = n, o = l(() => a.value || Ye()), { parent: i } = gt(), u = l(
      () => !i.value.props.disabled && !a.disabled && a.clickable
    ), d = l(() => i.value.selected === null ? !1 : i.value.props.multiple && Array.isArray(i.value.selected) ? i.value.selected.some(
      (v) => Tt(o.value, v)
    ) : Tt(o.value, i.value.selected));
    function m(v) {
      u.value && (i.value.selectItem(o.value), t("click", o.value, v));
    }
    const c = h(
      ["itemClass", "o-drop__item"],
      [
        "itemDisabledClass",
        "o-drop__item--disabled",
        null,
        l(() => i.value.props.disabled || a.disabled)
      ],
      ["itemActiveClass", "o-drop__item--active", null, d],
      ["itemClickableClass", "o-drop__item--clickable", null, u]
    );
    return (v, p) => (f(), ne(Ge(e.tag), {
      class: M(s(c)),
      role: e.ariaRole,
      tabindex: e.tabindex,
      "data-oruga": "dropdown-item",
      onClick: m
    }, {
      default: se(() => [
        _(v.$slots, "default", {}, () => [
          Pe(ue(e.label), 1)
        ])
      ]),
      _: 3
    }, 8, ["class", "role", "tabindex"]));
  }
}), dn = { key: 1 }, cn = { key: 1 };
var Ga = /* @__PURE__ */ ((e) => (e[e.Header = 0] = "Header", e[e.Footer = 1] = "Footer", e))(Ga || {});
const Ja = /* @__PURE__ */ ye({
  isOruga: !0,
  name: "OAutocomplete",
  configField: "autocomplete",
  inheritAttrs: !1,
  __name: "Autocomplete",
  props: {
    /** Override existing theme classes completely */
    override: { type: Boolean, default: void 0 },
    /** @model */
    modelValue: { type: [String, Number], default: "" },
    /** Input type */
    type: { type: String, default: "text" },
    /** Menu tag name */
    menuTag: {
      type: [String, Object, Function],
      default: () => r("autocomplete.menuTag", "div")
    },
    /** Menu item tag name */
    itemTag: {
      type: [String, Object, Function],
      default: () => r("autocomplete.itemTag", "div")
    },
    /** Options / suggestions */
    data: { type: Array, default: () => [] },
    /**
     * Size of the control
     * @values small, medium, large
     */
    size: {
      type: String,
      default: () => r("autocomplete.size")
    },
    /**
     * Position of the dropdown
     * @values auto, top, bottom
     */
    position: {
      type: String,
      default: () => r("autocomplete.position", "auto"),
      validator: (e) => ["auto", "top", "bottom"].indexOf(e) >= 0
    },
    /** Property of the object (if data is array of objects) to use as display text, and to keep track of selected option */
    field: { type: String, default: void 0 },
    /** Property of the object (if `data` is array of objects) to use as display text of group */
    groupField: { type: String, default: void 0 },
    /** Property of the object (if `data` is array of objects) to use as key to get items array of each group */
    groupOptions: { type: String, default: void 0 },
    /** Function to format an option to a string for display in the input (as alternative to field prop) */
    formatter: {
      type: Function,
      default: void 0
    },
    /** Input placeholder */
    placeholder: { type: String, default: void 0 },
    /** Makes input full width when inside a grouped or addon field */
    expanded: { type: Boolean, default: !1 },
    /** Makes the element rounded */
    rounded: { type: Boolean, default: !1 },
    /** Same as native input disabled */
    disabled: { type: Boolean, default: !1 },
    /** Same as native maxlength, plus character counter */
    maxlength: { type: Number, default: void 0 },
    /** Makes the component check if list reached scroll start or end and emit scroll events. */
    checkScroll: {
      type: Boolean,
      default: () => r("autocomplete.checkScroll", !1)
    },
    /** Number of milliseconds to delay before to emit input event */
    debounce: {
      type: Number,
      default: () => r("autocomplete.debounce", 400)
    },
    /** The first option will always be pre-selected (easier to just hit enter or tab) */
    keepFirst: {
      type: Boolean,
      default: () => r("autocomplete.keepFirst", !1)
    },
    /** Clear input text on select */
    clearOnSelect: {
      type: Boolean,
      default: () => r("autocomplete.clearOnSelect", !1)
    },
    /** Open dropdown list on focus */
    openOnFocus: {
      type: Boolean,
      default: () => r("autocomplete.openOnFocus", !1)
    },
    /** Keep open dropdown list after select */
    keepOpen: {
      type: Boolean,
      default: () => r("autocomplete.keepOpen", !1)
    },
    /** Max height of dropdown content */
    maxHeight: {
      type: [String, Number],
      default: () => r("autocomplete.maxHeight")
    },
    /** Array of keys (https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key/Key_Values) which will add a tag when typing (default tab and enter) */
    confirmKeys: {
      type: Array,
      default: () => ["Tab", "Enter"]
    },
    /** Dropdown content (items) are shown into a modal on mobile */
    mobileModal: {
      type: Boolean,
      default: () => r("autocomplete.mobileModal", !1)
    },
    /** Transition name to apply on dropdown list */
    animation: {
      type: String,
      default: () => r("autocomplete.animation", "fade")
    },
    /** Trigger the select event for the first pre-selected option when clicking outside and `keep-first` is enabled */
    selectOnClickOutside: { type: Boolean, default: !1 },
    /** Allows the header in the autocomplete to be selectable */
    selectableHeader: { type: Boolean, default: !1 },
    /** Allows the footer in the autocomplete to be selectable */
    selectableFooter: { type: Boolean, default: !1 },
    /**
     * Icon pack to use
     * @values mdi, fa, fas and any other custom icon pack
     */
    iconPack: {
      type: String,
      default: () => r("autocomplete.iconPack", void 0)
    },
    /** Icon to be shown */
    icon: {
      type: String,
      default: () => r("autocomplete.icon", void 0)
    },
    /** Makes the icon clickable */
    iconClickable: { type: Boolean, default: !1 },
    /** Icon to be added on the right side */
    iconRight: {
      type: String,
      default: () => r("autocomplete.iconRight", void 0)
    },
    /** Make the icon right clickable */
    iconRightClickable: { type: Boolean, default: !1 },
    /** Variant of right icon */
    iconRightVariant: { type: String, default: void 0 },
    /** Add a button/icon to clear the inputed text */
    clearable: {
      type: Boolean,
      default: () => r("autocomplete.clearable", !1)
    },
    /** Icon name to be added on the clear button */
    clearIcon: {
      type: String,
      default: () => r("autocomplete.clearIcon", "close-circle")
    },
    /** Show status icon using field and variant prop */
    statusIcon: {
      type: Boolean,
      default: () => r("statusIcon", !0)
    },
    /** Native options to use in HTML5 validation */
    autocomplete: {
      type: String,
      default: () => r("autocomplete.autocomplete", "off")
    },
    /** Enable html 5 native validation */
    useHtml5Validation: {
      type: Boolean,
      default: () => r("useHtml5Validation", !0)
    },
    /** The message which is shown when a validation error occurs */
    validationMessage: { type: String, default: void 0 },
    /**
     * Append the component to another part of the DOM.
     * Set `true` to append the component to the body.
     * In addition, any CSS selector string or an actual DOM node can be used.
     */
    teleport: {
      type: [Boolean, String, Object],
      default: () => r("autocomplete.teleport", !1)
    },
    // class props (will not be displayed in the docs)
    /** Class of the root element */
    rootClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the menu items */
    itemClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the menu items on hover */
    itemHoverClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the menu items group title */
    itemGroupTitleClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the menu empty placeholder item */
    itemEmptyClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the menu header item */
    itemHeaderClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the menu footer item */
    itemFooterClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /**
     * Classes to apply on internal input component
     * @ignore
     */
    inputClasses: {
      type: Object,
      default: () => r("autocomplete.inputClasses", {})
    }
  },
  emits: ["update:modelValue", "input", "select", "select-header", "select-footer", "focus", "blur", "invalid", "icon-click", "icon-right-click", "scroll-start", "scroll-end"],
  setup(e, { expose: n, emit: a }) {
    function t(X) {
      return X in Ga;
    }
    const o = e, i = a, u = xt(), d = L(), m = L(), c = L(), v = L(), p = L([]);
    function C(X, te, pe) {
      te === 0 && pe === 0 && p.value.splice(0), X && p.value.push(X);
    }
    const { checkHtml5Validity: B, onInvalid: A, onFocus: g, onBlur: y, isFocused: I, setFocus: k } = rt(d, i, o), z = dt(o, i, {
      passive: !0
    }), R = L(!1), H = L(null), j = L(null), U = L(!1), Q = L(!1), V = L(null), b = Ye();
    ce(
      () => z.value,
      (X) => {
        const te = S(H.value);
        te && te !== X && (N(null, !1), De(() => {
          W.value && !u.empty ? R.value = !1 : I.value && (!o.openOnFocus || X) && (R.value = !!X);
        }));
      }
    ), ce(
      () => o.data,
      () => {
        if (o.keepFirst)
          De(() => {
            R.value ? ae() : w(null);
          });
        else if (j.value) {
          const X = S(j.value), pe = D.value.map((we) => we.items).reduce((we, Oe) => [...we, ...Oe], []).findIndex((we) => S(we) === X);
          pe >= 0 ? De(() => $(pe)) : w(null);
        }
      }
    );
    const D = l(() => o.groupField ? o.groupOptions ? o.data.map((X) => {
      const te = Me(X, o.groupField), pe = Me(X, o.groupOptions);
      return { group: te, items: pe };
    }) : Object.keys(o.data).map((X) => ({
      group: X,
      items: o.data[X]
    })) : !o.openOnFocus && !o.keepOpen && z.value === "" ? [{ items: [] }] : [{ items: o.data }]), W = l(
      () => {
        var X;
        return !((X = D.value) != null && X.some(
          (te) => te.items && te.items.length
        ));
      }
    );
    ce(W, (X) => {
      I.value && (R.value = !X || !!u.empty);
    });
    const G = l(() => {
      const X = ["escape"];
      return o.keepOpen || (X.push("content"), X.push("outside")), X;
    });
    function E(X) {
      X === "outside" && o.keepFirst && j.value && o.selectOnClickOutside && N(j.value, !0);
    }
    function S(X) {
      if (!X)
        return "";
      const te = o.field && typeof X == "object" ? Me(X, o.field) : X;
      return (typeof o.formatter == "function" ? o.formatter(te) : te) || "";
    }
    function w(X) {
      X !== void 0 && (j.value = t(X) ? null : X, U.value = X === 0, Q.value = X === 1, V.value = null);
    }
    function $(X) {
      const te = Xe(p.value[X]);
      V.value = te ? te.id : null;
    }
    function N(X, te = !0, pe = void 0) {
      if (X !== void 0) {
        if (H.value = X, i("select", H.value, pe), H.value !== null) {
          if (o.clearOnSelect) {
            const we = d.value.$el.querySelector("input");
            we.value = "";
          } else
            z.value = S(H.value);
          w(null);
        }
        te && De(() => R.value = !1), B();
      }
    }
    function ae() {
      De(() => {
        const X = D.value.filter(
          (te) => te.items && te.items.length
        );
        if (X.length) {
          const te = X[0].items[0];
          w(te), $(0);
        } else
          w(null);
      });
    }
    function O(X, te, pe = !0) {
      o.selectableHeader && (U.value || te === 0) && (i("select-header", X), te && w(null), pe && (R.value = !1)), o.selectableFooter && (Q.value || te === 1) && (i("select-footer", X), te && w(null), pe && (R.value = !1));
    }
    function x(X) {
      if (!R.value) {
        R.value = !0;
        return;
      }
      const te = D.value.map((Bt) => Bt.items).reduce((Bt, Zt) => [...Bt, ...Zt], []);
      v.value && o.selectableHeader && te.unshift(void 0), c.value && o.selectableFooter && te.push(void 0);
      let pe = te.map(We).indexOf(We(j.value));
      U.value ? pe = 0 + X : Q.value ? pe = te.length - 1 + X : pe = pe + X, pe = pe > te.length - 1 ? te.length - 1 : pe, pe = pe < 0 ? 0 : pe, c.value && o.selectableFooter && pe === te.length - 1 ? w(
        1
        /* Footer */
      ) : v.value && o.selectableHeader && pe === 0 ? w(
        0
        /* Header */
      ) : w(te[pe] !== void 0 ? te[pe] : null);
      let we = p.value || [];
      v.value && o.selectableHeader && (we = [v.value, ...we]), c.value && o.selectableFooter && (we = [...we, c.value]);
      const Oe = Xe(we[pe]);
      if (!Oe)
        return;
      V.value = Oe.id;
      const Ne = Xe(m.value.$content), Ct = Ne.scrollTop, $t = Ne.scrollTop + Ne.clientHeight - Oe.clientHeight;
      Oe.offsetTop < Ct ? Ne.scrollTop = Oe.offsetTop : Oe.offsetTop >= $t && (Ne.scrollTop = Oe.offsetTop - Ne.clientHeight + Oe.clientHeight), o.checkScroll && lt();
    }
    function K(X) {
      if (X.key === "Enter" && X.preventDefault(), o.confirmKeys.indexOf(X.key) >= 0) {
        X.key === "," && X.preventDefault();
        const te = !o.keepOpen || X.key === "Tab";
        if (j.value === null) {
          O(X, null, te);
          return;
        }
        N(j.value, te, X);
      }
    }
    function ie(X) {
      S(H.value) === z.value && d.value.$el.querySelector("input").select(), o.openOnFocus && (W.value || (R.value = !0), o.keepFirst && ae()), g(X);
    }
    function fe(X) {
      y(X);
    }
    function He(X) {
      const te = S(H.value);
      te && te === z.value || Ve(X);
    }
    let Ve = ia(Se, o.debounce || 0);
    ce(
      () => o.debounce,
      (X) => {
        Ve = ia(Se, X);
      }
    );
    function Se(X) {
      i("input", X), B();
    }
    const Te = l(
      () => o.clearable && z.value && o.clearIcon ? o.clearIcon : o.iconRight
    ), tt = l(
      () => o.clearable ? !0 : o.iconRightClickable
    );
    function Je(X) {
      o.clearable ? (z.value = "", N(null, !1), o.openOnFocus && k()) : i("icon-right-click", X);
    }
    st(() => {
      Be && o.checkScroll && Ze(
        "scroll",
        lt,
        m.value.$content,
        { immediate: !0 }
      );
    });
    function lt() {
      var Oe, Ne;
      const X = m.value.$content;
      if (!X)
        return;
      const te = X.offsetTop, pe = ((Oe = v.value) == null ? void 0 : Oe.clientHeight) || 0, we = (((Ne = c.value) == null ? void 0 : Ne.clientHeight) || 0) + te;
      X.clientHeight !== X.scrollHeight && (X.scrollTop + X.clientHeight + we >= X.scrollHeight ? i("scroll-end") : X.scrollTop <= pe && i("scroll-start"));
    }
    const Qe = da(), nt = l(() => ({
      ...Qe,
      ...o.inputClasses
    })), ft = h(["rootClass", "o-acp"]), ee = h(["itemClass", "o-acp__item"]), Z = h([
      "itemEmptyClass",
      "o-acp__item--empty"
    ]), T = h([
      "itemGroupTitleClass",
      "o-acp__item-group-title"
    ]), de = h(
      ["itemHeaderClass", "o-acp__item-header"],
      ["itemHoverClass", "o-acp__item--hover", null, U]
    ), ke = h(
      ["itemFooterClass", "o-acp__item-footer"],
      ["itemHoverClass", "o-acp__item--hover", null, Q]
    );
    function Le(X) {
      const te = h([
        "itemHoverClass",
        "o-acp__item--hover",
        null,
        We(X) === We(j.value)
      ]);
      return [...ee.value, ...te.value];
    }
    return n({ focus: k }), (X, te) => (f(), ne(va, {
      ref_key: "dropdownRef",
      ref: m,
      modelValue: H.value,
      "onUpdate:modelValue": te[7] || (te[7] = (pe) => H.value = pe),
      active: R.value,
      "onUpdate:active": te[8] || (te[8] = (pe) => R.value = pe),
      "data-oruga": "autocomplete",
      class: M(s(ft)),
      "menu-id": s(b),
      "menu-tabindex": -1,
      "menu-tag": e.menuTag,
      scrollable: "",
      "aria-role": "listbox",
      tabindex: -1,
      "trap-focus": !1,
      triggers: [],
      disabled: e.disabled,
      closeable: G.value,
      "mobile-modal": e.mobileModal,
      "max-height": e.maxHeight,
      animation: e.animation,
      position: e.position,
      teleport: e.teleport,
      expanded: e.expanded,
      onClose: E
    }, {
      trigger: se(() => [
        me(At, be({
          ref_key: "inputRef",
          ref: d
        }, nt.value, {
          modelValue: s(z),
          "onUpdate:modelValue": [
            te[0] || (te[0] = (pe) => Ke(z) ? z.value = pe : null),
            He
          ],
          type: e.type,
          size: e.size,
          rounded: e.rounded,
          icon: e.icon,
          "icon-right": Te.value,
          "icon-right-clickable": tt.value,
          "icon-pack": e.iconPack,
          placeholder: e.placeholder,
          maxlength: e.maxlength,
          autocomplete: e.autocomplete,
          "use-html5-validation": !1,
          role: "combobox",
          "aria-activedescendant": V.value,
          "aria-autocomplete": e.keepFirst ? "both" : "list",
          "aria-controls": s(b),
          "aria-expanded": R.value,
          expanded: e.expanded,
          disabled: e.disabled,
          "status-icon": e.statusIcon,
          onFocus: ie,
          onBlur: fe,
          onInvalid: s(A),
          onKeydown: [
            K,
            te[1] || (te[1] = Ce(ve((pe) => x(-1), ["prevent"]), ["up"])),
            te[2] || (te[2] = Ce(ve((pe) => x(1), ["prevent"]), ["down"]))
          ],
          onIconClick: te[3] || (te[3] = (pe) => X.$emit("icon-click", pe)),
          onIconRightClick: Je
        }), null, 16, ["modelValue", "type", "size", "rounded", "icon", "icon-right", "icon-right-clickable", "icon-pack", "placeholder", "maxlength", "autocomplete", "aria-activedescendant", "aria-autocomplete", "aria-controls", "aria-expanded", "expanded", "disabled", "status-icon", "onInvalid"])
      ]),
      default: se(() => [
        X.$slots.header ? (f(), ne(ht, {
          key: 0,
          id: `${s(b)}-header`,
          ref_key: "headerRef",
          ref: v,
          tag: e.itemTag,
          "aria-role": "option",
          "aria-selected": U.value,
          tabindex: -1,
          class: M([...s(ee), ...s(de)]),
          onClick: te[4] || (te[4] = (pe, we) => O(
            we,
            0
            /* Header */
          ))
        }, {
          default: se(() => [
            _(X.$slots, "header")
          ]),
          _: 3
        }, 8, ["id", "tag", "aria-selected", "class"])) : J("", !0),
        (f(!0), P(he, null, xe(D.value, (pe, we) => (f(), P(he, null, [
          pe.group ? (f(), ne(ht, {
            key: we + "group",
            tag: e.itemTag,
            tabindex: -1,
            class: M([...s(ee), ...s(T)])
          }, {
            default: se(() => [
              X.$slots.group ? _(X.$slots, "group", {
                key: 0,
                group: pe.group,
                index: we
              }) : (f(), P("span", dn, ue(pe.group), 1))
            ]),
            _: 2
          }, 1032, ["tag", "class"])) : J("", !0),
          (f(!0), P(he, null, xe(pe.items, (Oe, Ne) => (f(), ne(ht, {
            id: `${s(b)}-${we}-${Ne}`,
            key: we + ":" + Ne,
            ref_for: !0,
            ref: (Ct) => C(Ct, we, Ne),
            value: Oe,
            tag: e.itemTag,
            class: M(Le(Oe)),
            "aria-role": "option",
            "aria-selected": We(Oe) === We(j.value),
            tabindex: -1,
            onClick: te[5] || (te[5] = (Ct, $t) => N(Ct, !e.keepOpen, $t))
          }, {
            default: se(() => [
              X.$slots.default ? _(X.$slots, "default", {
                key: 0,
                option: Oe,
                value: S(Oe),
                index: Ne
              }) : (f(), P("span", cn, ue(S(Oe)), 1))
            ]),
            _: 2
          }, 1032, ["id", "value", "tag", "class", "aria-selected"]))), 128))
        ], 64))), 256)),
        W.value && X.$slots.empty ? (f(), ne(ht, {
          key: 1,
          tag: e.itemTag,
          class: M([...s(ee), ...s(Z)])
        }, {
          default: se(() => [
            _(X.$slots, "empty")
          ]),
          _: 3
        }, 8, ["tag", "class"])) : J("", !0),
        X.$slots.footer ? (f(), ne(ht, {
          key: 2,
          id: `${s(b)}-footer`,
          ref_key: "footerRef",
          ref: c,
          tag: e.itemTag,
          "aria-role": "option",
          "aria-selected": Q.value,
          tabindex: -1,
          class: M([...s(ee), ...s(ke)]),
          onClick: te[6] || (te[6] = (pe, we) => O(
            we,
            1
            /* Footer */
          ))
        }, {
          default: se(() => [
            _(X.$slots, "footer")
          ]),
          _: 3
        }, 8, ["id", "tag", "aria-selected", "class"])) : J("", !0)
      ]),
      _: 3
    }, 8, ["modelValue", "active", "class", "menu-id", "menu-tag", "disabled", "closeable", "mobile-modal", "max-height", "animation", "position", "teleport", "expanded"]));
  }
}), fn = {
  install(e) {
    Ae(e, Ja);
  }
}, wt = /* @__PURE__ */ ye({
  isOruga: !0,
  name: "OButton",
  configField: "button",
  __name: "Button",
  props: {
    /** Override existing theme classes completely */
    override: { type: Boolean, default: void 0 },
    /**
     * Button tag name
     * @values button, a, input, router-link, nuxt-link (or other nuxt alias)
     */
    tag: {
      type: [String, Object, Function],
      default: () => r("button.tag", "button")
    },
    /**
     * Color variant of the control
     * @values primary, info, success, warning, danger, and any other custom color
     */
    variant: {
      type: String,
      default: () => r("button.variant")
    },
    /**
     * Size of the control
     * @values small, medium, large
     */
    size: {
      type: String,
      default: () => r("button.size")
    },
    /** Button label, unnecessary when default slot is used */
    label: { type: String, default: void 0 },
    /**
     * Icon pack to use
     * @values mdi, fa, fas and any other custom icon pack
     */
    iconPack: {
      type: String,
      default: () => r("button.iconPack", void 0)
    },
    /** Icon name to show on the left */
    iconLeft: { type: String, default: void 0 },
    /** Icon name to show on the right */
    iconRight: { type: String, default: void 0 },
    /** Enable rounded style */
    rounded: {
      type: Boolean,
      default: () => r("button.rounded", !1)
    },
    /** Button will be expanded (full-width) */
    expanded: { type: Boolean, default: !1 },
    /** Button will be disabled */
    disabled: { type: Boolean, default: !1 },
    /** Enable outlined style */
    outlined: { type: Boolean, default: !1 },
    /** Enable loading style */
    loading: { type: Boolean, default: !1 },
    /** Enable inverted style */
    inverted: { type: Boolean, default: !1 },
    /** Button type, like native */
    nativeType: {
      type: String,
      default: "button",
      validator: (e) => ["button", "submit", "reset"].indexOf(e) >= 0
    },
    /** Accessibility Role attribute to be passed to the button. */
    role: {
      type: String,
      default: () => r("button.role", "button")
    },
    /**
     * This is used internally
     * @ignore
     */
    iconBoth: { type: Boolean, default: !1 },
    // class props (will not be displayed in the docs)
    /** Class of the root element */
    rootClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the button elements wrapper */
    wrapperClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the button when outlined */
    outlinedClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the button with loading */
    loadingClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the button when inverted */
    invertedClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the button when expanded */
    expandedClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the button when rounded */
    roundedClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the button when disabled */
    disabledClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the button icon */
    iconClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the button icon on the left */
    iconLeftClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the button icon on the right */
    iconRightClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the button label */
    labelClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the button size */
    sizeClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the button variant */
    variantClass: {
      type: [String, Array, Function],
      default: void 0
    }
  },
  setup(e) {
    const n = e, a = l(
      () => typeof n.disabled < "u" && n.disabled !== !1 ? "button" : n.tag
    ), t = l(
      () => n.tag === "button" || n.tag === "input" ? n.nativeType : null
    ), o = l(() => n.disabled ? !0 : null), i = h(
      ["rootClass", "o-btn"],
      [
        "sizeClass",
        "o-btn--",
        l(() => n.size),
        l(() => !!n.size)
      ],
      [
        "variantClass",
        "o-btn--",
        l(() => n.variant),
        l(() => !!n.variant)
      ],
      [
        "outlinedClass",
        "o-btn--outlined",
        null,
        l(() => n.outlined && !n.variant)
      ],
      [
        "invertedClass",
        "o-btn--inverted",
        null,
        l(() => n.inverted && !n.variant)
      ],
      [
        "outlinedClass",
        "o-btn--outlined-",
        l(() => n.variant),
        l(() => n.outlined && !!n.variant)
      ],
      [
        "invertedClass",
        "o-btn--inverted-",
        l(() => n.variant),
        l(() => n.inverted && !!n.variant)
      ],
      ["expandedClass", "o-btn--expanded", null, l(() => n.expanded)],
      ["loadingClass", "o-btn--loading", null, l(() => n.loading)],
      ["roundedClass", "o-btn--rounded", null, l(() => n.rounded)],
      ["disabledClass", "o-btn--disabled", null, l(() => n.disabled)]
    ), u = h(["labelClass", "o-btn__label"]), d = h(["iconClass", "o-btn__icon"]), m = h(["iconLeftClass", "o-btn__icon-left"]), c = h(["iconRightClass", "o-btn__icon-right"]), v = h(["wrapperClass", "o-btn__wrapper"]);
    return (p, C) => (f(), ne(Ge(a.value), {
      disabled: o.value,
      type: t.value,
      class: M(s(i)),
      role: e.role,
      "data-oruga": "button"
    }, {
      default: se(() => [
        le("span", {
          class: M(s(v))
        }, [
          e.iconLeft ? (f(), ne(Re, {
            key: 0,
            pack: e.iconPack,
            icon: e.iconLeft,
            size: e.size,
            both: e.iconBoth,
            class: M([...s(d), ...s(m)])
          }, null, 8, ["pack", "icon", "size", "both", "class"])) : J("", !0),
          e.label || p.$slots.default ? (f(), P("span", {
            key: 1,
            class: M(s(u))
          }, [
            _(p.$slots, "default", {}, () => [
              Pe(ue(e.label), 1)
            ])
          ], 2)) : J("", !0),
          e.iconRight ? (f(), ne(Re, {
            key: 2,
            pack: e.iconPack,
            icon: e.iconRight,
            size: e.size,
            both: e.iconBoth,
            class: M([...s(d), ...s(c)])
          }, null, 8, ["pack", "icon", "size", "both", "class"])) : J("", !0)
        ], 2)
      ]),
      _: 3
    }, 8, ["disabled", "type", "class", "role"]));
  }
}), vn = {
  install(e) {
    Ae(e, wt);
  }
}, pn = ["onFocus", "onMouseover", "onClick", "onKeypress"], mn = /* @__PURE__ */ ye({
  isOruga: !0,
  name: "OCarousel",
  configField: "carousel",
  __name: "Carousel",
  props: {
    /** Override existing theme classes completely */
    override: { type: Boolean, default: void 0 },
    /** @model */
    modelValue: { type: Number, default: 0 },
    /** Enable drag mode */
    dragable: { type: Boolean, default: !0 },
    /** Timer interval for `autoplay` */
    interval: {
      type: Number,
      default: () => r("carousel.interval", 3500)
    },
    /** Move item automaticalls after `interval` */
    autoplay: { type: Boolean, default: !1 },
    /** Pause autoplay on hover */
    pauseHover: { type: Boolean, default: !1 },
    /** Repeat from the beginning after reaching the end */
    repeat: { type: Boolean, default: !1 },
    /** Show an overlay */
    overlay: { type: Boolean, default: !1 },
    /** Enable indicators */
    indicators: { type: Boolean, default: !0 },
    /** Place indicators inside the carousel */
    indicatorInside: { type: Boolean, default: !1 },
    /**
     * Indicator interaction mode
     * @values click, hover
     */
    indicatorMode: {
      type: String,
      default: "click",
      validator: (e) => ["click", "hover"].indexOf(e) >= 0
    },
    /** Position of the indicator - depends on used theme */
    indicatorPosition: {
      type: String,
      default: () => r("carousel.indicatorPosition", "bottom")
    },
    /** Style of the indicator - depends on used theme */
    indicatorStyle: {
      type: String,
      default: () => r("carousel.indicatorStyle", "dots")
    },
    /** Number of items to show at once*/
    itemsToShow: {
      type: Number,
      default: () => r("carousel.itemsToShow", 1)
    },
    /** Number of items to switch at once */
    itemsToList: {
      type: Number,
      default: () => r("carousel.itemsToList", 1)
    },
    /** Show next / prev arrows */
    arrows: {
      type: Boolean,
      default: () => r("carousel.arrows", !0)
    },
    /** Show next / prev arrows only on hover */
    arrowsHover: {
      type: Boolean,
      default: () => r("carousel.arrowsHover", !0)
    },
    /**
     * Icon pack to use
     * @values mdi, fa, fas and any other custom icon pack
     */
    iconPack: {
      type: String,
      default: () => r("carousel.iconPack")
    },
    /**
     * Icon size
     * @values small, medium, large
     */
    iconSize: {
      type: String,
      default: () => r("carousel.iconSize")
    },
    /** Icon name for previous icon */
    iconPrev: {
      type: String,
      default: () => r("carousel.iconPrev", "chevron-left")
    },
    /** Icon name for next icon */
    iconNext: {
      type: String,
      default: () => r("carousel.iconNext", "chevron-right")
    },
    /** Define these props for different screen sizes */
    breakpoints: {
      type: Object,
      default: () => ({})
    },
    // class props (will not be displayed in the docs)
    /** Class of the root element */
    rootClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the root element in overlay */
    overlayClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the wrapper element of carousel items */
    wrapperClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of slider items */
    itemsClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of slider items on drag */
    itemsDraggingClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of arrow elements */
    arrowIconClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of prev arrow element */
    arrowIconPrevClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of next arrow element */
    arrowIconNextClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of indicator link element */
    indicatorClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of indicators wrapper element */
    indicatorsClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of indicators wrapper element when inside */
    indicatorsInsideClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of indicators wrapper element when inside and position */
    indicatorsInsidePositionClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of indicator item element */
    indicatorItemClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of indicator element when is active */
    indicatorItemActiveClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of indicator element to separate different styles */
    indicatorItemStyleClass: {
      type: [String, Array, Function],
      default: void 0
    }
  },
  emits: ["update:modelValue", "scroll", "click"],
  setup(e, { emit: n }) {
    const a = e, t = n, o = L();
    function i() {
      N(), $();
    }
    const u = l(() => ({
      restartTimer: i,
      itemWidth: y.value,
      activeIndex: c.value,
      onClick: (T) => t("click", T),
      setActive: (T) => b(T)
    })), { childItems: d } = bt(o, { data: u }), m = dt(a, t), c = L(a.modelValue), v = L(null), p = L(0), C = L(0);
    ce(
      () => a.modelValue,
      (T) => {
        T <= d.value.length - 1 && b(T * g.value.itemsToList, !0);
      }
    ), ce([() => a.itemsToList, () => a.itemsToShow], () => A()), st(() => {
      Be && (window.ResizeObserver && (v.value = new window.ResizeObserver(A), v.value.observe(o.value)), B(), $());
    }), It(() => {
      Be && (window.ResizeObserver && v.value.disconnect(), Se(), N());
    }), Be && (Ze("resize", B, window), Ze("animationend", A), Ze("transitionend", A), Ze("transitionstart", A));
    function B() {
      p.value = window.innerWidth;
    }
    function A() {
      De(() => C.value++);
    }
    const g = l(() => {
      const de = Object.keys(a.breakpoints).map(Number).sort((Le, X) => X - Le).filter(
        (Le) => p.value >= Le
      )[0], ke = We(
        de ? { ...a, ...a.breakpoints[de] } : a
      );
      return ke.itemsToList || (ke.itemsToList = 1), ke.itemsToShow || (ke.itemsToShow = 1), Pl(ke);
    }), y = l(() => p.value ? (C.value, o.value.getBoundingClientRect().width / g.value.itemsToShow) : 0), I = l(
      () => -Fa(
        ie.value + c.value * y.value,
        0,
        (d.value.length - g.value.itemsToShow) * y.value
      )
    ), k = l(() => d.value.length), z = l(
      () => Math.ceil(k.value / g.value.itemsToList)
    ), R = l(
      () => Math.ceil(c.value / g.value.itemsToList)
    ), H = l(
      () => g.value.arrowsHover && W.value || !g.value.arrowsHover
    ), j = l(
      () => (g.value.repeat || c.value > 0) && H.value
    );
    function U() {
      b(c.value - g.value.itemsToList);
    }
    const Q = l(
      () => (g.value.repeat || c.value < k.value - 1) && H.value
    );
    function V() {
      b(c.value + g.value.itemsToList);
    }
    function b(T, de) {
      g.value.repeat && (T = Yt(T, k.value)), T = Fa(T, 0, k.value), c.value = T, t("scroll", R.value), de || (m.value = Math.ceil(T / g.value.itemsToList));
    }
    function D(T, de) {
      a.indicatorMode === T && b(de * g.value.itemsToList);
    }
    const W = L(!1), G = L(!1), E = L(null);
    function S() {
      W.value = !0, ae();
    }
    function w() {
      W.value = !1, $();
    }
    ce(
      () => a.autoplay,
      (T) => {
        T ? $() : N();
      }
    ), ce(
      () => a.repeat,
      (T) => {
        T && $();
      }
    );
    function $() {
      !a.autoplay || E.value || (G.value = !1, E.value = setInterval(() => {
        !a.repeat && !Q.value ? N() : V();
      }, a.interval));
    }
    function N() {
      G.value = !0, E.value && (clearInterval(E.value), E.value = null);
    }
    function ae() {
      a.pauseHover && a.autoplay && N();
    }
    const O = L(!1), x = L(), K = L(0), ie = L(0), fe = l(() => ot(x.value));
    function He(T) {
      fe.value || !g.value.dragable || T.button !== 0 && T.type !== "touchstart" || (K.value = Date.now(), O.value = !!T.touches, x.value = O.value ? T.touches[0].clientX : T.clientX, O.value && N(), Be && (window.addEventListener(
        O.value ? "touchmove" : "mousemove",
        Ve
      ), window.addEventListener(
        O.value ? "touchend" : "mouseup",
        Se
      )));
    }
    function Ve(T) {
      if (!fe.value)
        return;
      const de = T.touches ? (T.changedTouches[0] || T.touches[0]).clientX : T.clientX;
      ie.value = x.value - de, T.touches || T.preventDefault();
    }
    function Se(T) {
      if (!(!fe.value && !K.value)) {
        if (K.value) {
          const de = zl(ie.value), ke = Math.round(
            Math.abs(ie.value / y.value) + 0.15
          );
          b(c.value + de * ke);
        }
        ie.value = 0, x.value = void 0, T != null && T.touches && $(), Be && (window.removeEventListener(
          O.value ? "touchmove" : "mousemove",
          Ve
        ), window.removeEventListener(
          O.value ? "touchend" : "mouseup",
          Se
        ));
      }
    }
    const Te = h(
      ["rootClass", "o-car"],
      ["overlayClass", "o-car__overlay", null, l(() => a.overlay)]
    ), tt = h(["wrapperClass", "o-car__wrapper"]), Je = h(
      ["itemsClass", "o-car__items"],
      ["itemsDraggingClass", "o-car__items--dragging", null, fe]
    ), lt = h([
      "arrowIconClass",
      "o-car__arrow__icon"
    ]), Qe = h([
      "arrowIconPrevClass",
      "o-car__arrow__icon-prev"
    ]), nt = h([
      "arrowIconNextClass",
      "o-car__arrow__icon-next"
    ]);
    function ft(T) {
      return h(
        ["indicatorItemClass", "o-car__indicator__item"],
        [
          "indicatorItemActiveClass",
          "o-car__indicator__item--active",
          null,
          R.value === T
        ],
        [
          "indicatorItemStyleClass",
          "o-car__indicator__item--",
          a.indicatorStyle,
          !!a.indicatorStyle
        ]
      ).value;
    }
    const ee = h(
      ["indicatorsClass", "o-car__indicators"],
      [
        "indicatorsInsideClass",
        "o-car__indicators--inside",
        null,
        l(() => !!a.indicatorInside)
      ],
      [
        "indicatorsInsidePositionClass",
        "o-car__indicators--inside--",
        l(() => a.indicatorPosition),
        l(() => a.indicatorInside && !!a.indicatorPosition)
      ]
    ), Z = h(["indicatorClass", "o-car__indicator"]);
    return (T, de) => (f(), P("div", {
      ref_key: "rootRef",
      ref: o,
      class: M(s(Te)),
      "data-oruga": "carousel",
      role: "region",
      onMouseover: S,
      onMouseleave: w,
      onFocus: S,
      onBlur: w,
      onKeydown: [
        Ce(U, ["left"]),
        Ce(V, ["right"])
      ]
    }, [
      le("div", {
        class: M(s(tt))
      }, [
        le("div", {
          class: M(s(Je)),
          style: _e("transform:translateX(" + I.value + "px)"),
          tabindex: "0",
          role: "group",
          draggable: "true",
          "aria-roledescription": "carousel",
          onMousedown: He,
          onTouchstart: He
        }, [
          _(T.$slots, "default")
        ], 38),
        _(T.$slots, "arrow", {
          hasPrev: j.value,
          prev: U,
          hasNext: Q.value,
          next: V
        }, () => [
          e.arrows ? (f(), P(he, { key: 0 }, [
            $e(me(Re, {
              class: M([...s(lt), ...s(Qe)]),
              pack: e.iconPack,
              icon: e.iconPrev,
              size: e.iconSize,
              both: "",
              role: "button",
              tabindex: "0",
              onClick: U,
              onKeydown: Ce(U, ["enter"])
            }, null, 8, ["class", "pack", "icon", "size"]), [
              [ze, j.value]
            ]),
            $e(me(Re, {
              class: M([...s(lt), ...s(nt)]),
              pack: e.iconPack,
              icon: e.iconNext,
              size: e.iconSize,
              both: "",
              role: "button",
              tabindex: "0",
              onClick: V,
              onKeydown: Ce(V, ["enter"])
            }, null, 8, ["class", "pack", "icon", "size"]), [
              [ze, Q.value]
            ])
          ], 64)) : J("", !0)
        ])
      ], 2),
      _(T.$slots, "indicators", {
        active: s(m),
        switchTo: b,
        indicatorIndex: R.value
      }, () => [
        s(d).length ? (f(), P(he, { key: 0 }, [
          e.indicators ? (f(), P("div", {
            key: 0,
            class: M(s(ee)),
            role: "group"
          }, [
            (f(!0), P(he, null, xe(z.value, (ke, Le) => (f(), P("div", {
              key: Le,
              class: M(s(Z)),
              role: "button",
              tabindex: "0",
              onFocus: (X) => D("hover", Le),
              onMouseover: (X) => D("hover", Le),
              onClick: (X) => D("click", Le),
              onKeypress: Ce((X) => D("click", Le), ["enter"])
            }, [
              _(T.$slots, "indicator", { index: Le }, () => [
                le("span", {
                  class: M(ft(Le))
                }, null, 2)
              ])
            ], 42, pn))), 128))
          ], 2)) : J("", !0)
        ], 64)) : J("", !0)
      ]),
      e.overlay ? _(T.$slots, "overlay", { key: 0 }) : J("", !0)
    ], 34));
  }
}), yn = ["data-id", "role", "aria-selected"], gn = /* @__PURE__ */ ye({
  isOruga: !0,
  name: "OCarouselItem",
  configField: "carousel",
  __name: "CarouselItem",
  props: {
    /** Override existing theme classes completely */
    override: { type: Boolean, default: void 0 },
    /** Make item clickable */
    clickable: { type: Boolean, default: !1 },
    /** Role attribute to be passed to the div wrapper for better accessibility */
    ariaRole: {
      type: String,
      default: () => r("carousel.ariaRole", "option")
    },
    // class props (will not be displayed in the docs)
    /** Class of carousel item */
    itemClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of carousel item when is active */
    itemActiveClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of carousel item when is clickable */
    itemClickableClass: {
      type: [String, Array, Function],
      default: void 0
    }
  },
  setup(e) {
    const n = e, { parent: a, item: t } = gt(), o = l(() => a.value.activeIndex === t.value.index), i = l(() => ({ width: `${a.value.itemWidth}px` }));
    function u(m) {
      o.value && a.value.onClick(m), n.clickable && a.value.setActive(t.value.index);
    }
    const d = h(
      ["itemClass", "o-car__item"],
      ["itemActiveClass", "o-car__item--active", null, o],
      [
        "itemClickableClass",
        "o-car__item--clickable",
        null,
        l(() => n.clickable)
      ]
    );
    return (m, c) => (f(), P("div", {
      class: M(s(d)),
      style: _e(i.value),
      "data-id": `carousel-${s(t).identifier}`,
      "data-oruga": "carousel-item",
      role: e.ariaRole,
      "aria-roledescription": "item",
      "aria-selected": o.value,
      onClick: u,
      onKeypress: Ce(u, ["enter"])
    }, [
      _(m.$slots, "default")
    ], 46, yn));
  }
}), bn = {
  install(e) {
    Ae(e, mn), Ae(e, gn);
  }
}, Cn = ["aria-checked"], hn = ["disabled", "required", "name", "autocomplete", "value", ".indeterminate", "true-value", "false-value", "aria-labelledby"], kn = ["id"], Rt = /* @__PURE__ */ ye({
  isOruga: !0,
  name: "OCheckbox",
  configField: "checkbox",
  inheritAttrs: !1,
  __name: "Checkbox",
  props: {
    /** Override existing theme classes completely */
    override: { type: Boolean, default: void 0 },
    /** @model */
    modelValue: { type: [String, Number, Boolean, Array], default: void 0 },
    /**
     * Color of the control
     * @values primary, info, success, warning, danger, and any other custom color
     */
    variant: {
      type: String,
      default: () => r("checkbox.variant")
    },
    /**
     * Size of the control
     * @values small, medium, large
     */
    size: {
      type: String,
      default: () => r("checkbox.size")
    },
    /** Input label, unnecessary when default slot is used */
    label: { type: String, default: void 0 },
    /** Same as native indeterminate */
    indeterminate: { type: Boolean, default: !1 },
    /** Same as native value */
    nativeValue: { type: [String, Number, Boolean], default: void 0 },
    /** Same as native disabled */
    disabled: { type: Boolean, default: !1 },
    /** Same as native required */
    required: { type: Boolean, default: !1 },
    /** Same as native name */
    name: { type: String, default: void 0 },
    /** Overrides the returned value when it's checked */
    trueValue: { type: [String, Number, Boolean], default: !0 },
    /** Overrides the returned value when it's not checked */
    falseValue: { type: [String, Number, Boolean], default: !1 },
    /** Accessibility label to establish relationship between the checkbox and control label */
    ariaLabelledby: { type: String, default: () => Ye() },
    /** Same as native autocomplete options to use in HTML5 validation */
    autocomplete: {
      type: String,
      default: () => r("checkbox.autocomplete", "off")
    },
    /** Enable html 5 native validation */
    useHtml5Validation: {
      type: Boolean,
      default: () => r("useHtml5Validation", !0)
    },
    // class props (will not be displayed in the docs)
    /** Class of the root element */
    rootClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class when checkbox is disabled */
    disabledClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the root element when checked */
    checkedClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the checkbox input */
    inputClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the checkbox input when checked */
    inputCheckedClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class when checkbox is indeterminate */
    indeterminateClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the checkbox labe */
    labelClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the checkbox size */
    sizeClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the checkbox variant */
    variantClass: {
      type: [String, Array, Function],
      default: void 0
    }
  },
  emits: ["update:modelValue", "input", "update:indeterminate", "focus", "blur", "invalid"],
  setup(e, { expose: n, emit: a }) {
    const t = e, o = a, i = L(), { onBlur: u, onFocus: d, onInvalid: m, setFocus: c } = rt(
      i,
      o,
      t
    ), v = dt(t, o, { passive: !0 }), p = qe("indeterminate", t, o), C = l(
      () => v.value === t.trueValue || Array.isArray(v.value) && v.value.includes(t.nativeValue)
    );
    function B(I) {
      o("input", v.value, I);
    }
    const A = h(
      ["rootClass", "o-chk"],
      ["checkedClass", "o-chk--checked", null, C],
      [
        "sizeClass",
        "o-chk--",
        l(() => t.size),
        l(() => !!t.size)
      ],
      ["disabledClass", "o-chk--disabled", null, l(() => t.disabled)],
      [
        "variantClass",
        "o-chk--",
        l(() => t.variant),
        l(() => !!t.variant)
      ]
    ), g = h(
      ["inputClass", "o-chk__input"],
      ["inputCheckedClass", "o-chk__input--checked", null, C],
      [
        "indeterminateClass",
        "o-chk__input--indeterminate",
        null,
        p
      ]
    ), y = h(["labelClass", "o-chk__label"]);
    return n({ focus: c }), (I, k) => (f(), P("label", {
      ref: "label",
      class: M(s(A)),
      "data-oruga": "checkbox",
      role: "checkbox",
      "aria-checked": C.value,
      onClick: k[5] || (k[5] = ve(
        //@ts-ignore
        (...z) => s(c) && s(c)(...z),
        ["stop"]
      )),
      onKeydown: k[6] || (k[6] = Ce(ve(
        //@ts-ignore
        (...z) => s(c) && s(c)(...z),
        ["prevent"]
      ), ["enter"]))
    }, [
      $e(le("input", be(I.$attrs, {
        ref_key: "inputRef",
        ref: i,
        "onUpdate:modelValue": k[0] || (k[0] = (z) => Ke(v) ? v.value = z : null),
        type: "checkbox",
        "data-oruga-input": "checkbox",
        class: s(g),
        disabled: e.disabled,
        required: e.required,
        name: e.name,
        autocomplete: e.autocomplete,
        value: e.nativeValue,
        ".indeterminate": e.indeterminate,
        "true-value": e.trueValue,
        "false-value": e.falseValue,
        "aria-labelledby": e.ariaLabelledby,
        onClick: k[1] || (k[1] = ve(() => {
        }, ["stop"])),
        onBlur: k[2] || (k[2] = //@ts-ignore
        (...z) => s(u) && s(u)(...z)),
        onFocus: k[3] || (k[3] = //@ts-ignore
        (...z) => s(d) && s(d)(...z)),
        onInvalid: k[4] || (k[4] = //@ts-ignore
        (...z) => s(m) && s(m)(...z)),
        onInput: B
      }), null, 48, hn), [
        [La, s(v)]
      ]),
      e.label || I.$slots.default ? (f(), P("span", {
        key: 0,
        id: e.ariaLabelledby,
        class: M(s(y))
      }, [
        _(I.$slots, "default", {}, () => [
          Pe(ue(e.label), 1)
        ])
      ], 10, kn)) : J("", !0)
    ], 42, Cn));
  }
}), Sn = {
  install(e) {
    Ae(e, Rt);
  }
}, Fn = ["id"], An = /* @__PURE__ */ ye({
  isOruga: !0,
  name: "OCollapse",
  configField: "collapse",
  __name: "Collapse",
  props: {
    /** Override existing theme classes completely */
    override: { type: Boolean, default: void 0 },
    /** Whether collapse is open or not, use v-model:open to make it two-way binding */
    open: { type: Boolean, default: !0 },
    /** Custom animation (transition name) */
    animation: {
      type: String,
      default: () => r("collapse.animation", "fade")
    },
    /** Id property of the content container */
    contentId: { type: String, default: () => Ye() },
    /**
     * Trigger position
     * @values top, bottom
     */
    position: {
      type: String,
      default: () => r("collapse.position", "top"),
      validator: (e) => ["top", "bottom"].indexOf(e) > -1
    },
    // class props (will not be displayed in the docs)
    /** Class of the root element */
    rootClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the trigger element */
    triggerClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the content */
    contentClass: {
      type: [String, Array, Function],
      default: void 0
    }
  },
  emits: ["update:open", "open", "close"],
  setup(e, { emit: n }) {
    const a = e, t = n, o = qe("open", a, t, { passive: !0 });
    function i() {
      o.value = !o.value, o.value ? t("open") : t("close");
    }
    const u = h(["rootClass", "o-clps"]), d = h(["triggerClass", "o-clps__trigger"]), m = h(["contentClass", "o-clps__content"]);
    return (c, v) => (f(), P("div", {
      class: M(s(u)),
      "data-oruga": "collapse"
    }, [
      e.position === "top" ? (f(), P("div", {
        key: 0,
        class: M(s(d)),
        role: "button",
        tabindex: "0",
        onClick: i,
        onKeydown: Ce(i, ["enter"])
      }, [
        _(c.$slots, "trigger", { open: s(o) })
      ], 34)) : J("", !0),
      me(et, { name: e.animation }, {
        default: se(() => [
          $e(le("div", {
            id: e.contentId,
            class: M(s(m))
          }, [
            _(c.$slots, "default")
          ], 10, Fn), [
            [ze, s(o)]
          ])
        ]),
        _: 3
      }, 8, ["name"]),
      e.position === "bottom" ? (f(), P("div", {
        key: 1,
        class: M(s(d)),
        role: "button",
        tabindex: "0",
        onClick: i,
        onKeydown: Ce(i, ["enter"])
      }, [
        _(c.$slots, "trigger", { open: s(o) })
      ], 34)) : J("", !0)
    ], 2));
  }
}), wn = {
  install(e) {
    Ae(e, An);
  }
}, Dn = ["autocomplete", "multiple", "size", "disabled", "aria-labelledby"], xn = {
  key: 0,
  value: null,
  disabled: "",
  hidden: ""
}, $n = ["value"], mt = /* @__PURE__ */ ye({
  isOruga: !0,
  name: "OSelect",
  configField: "select",
  inheritAttrs: !1,
  __name: "Select",
  props: {
    /** Override existing theme classes completely */
    override: { type: Boolean, default: void 0 },
    /** @model */
    modelValue: {
      type: [String, Number, Boolean, Object, Array],
      default: null
    },
    /** Select options, unnecessary when default slot is used */
    options: {
      type: Array,
      default: void 0
    },
    /**
     * Vertical size of input
     * @values small, medium, large
     */
    size: {
      type: String,
      default: () => r("select.size")
    },
    /**
     * Color of the control
     * @values primary, info, success, warning, danger, and any other custom color
     */
    variant: {
      type: String,
      default: () => r("select.variant")
    },
    /** Text when nothing is selected */
    placeholder: { type: String, default: void 0 },
    /** Allow multiple selection */
    multiple: { type: Boolean, default: !1 },
    /** Same as native disabled */
    disabled: { type: Boolean, default: !1 },
    /** Makes input full width when inside a grouped or addon field */
    expanded: { type: Boolean, default: !1 },
    /** Makes the element rounded */
    rounded: { type: Boolean, default: !1 },
    /** Same as native size */
    nativeSize: { type: [String, Number], default: void 0 },
    /**
     * Icon pack to use
     * @values mdi, fa, fas and any other custom icon pack
     */
    iconPack: {
      type: String,
      default: () => r("select.iconPack", void 0)
    },
    /** Icon to be shown */
    icon: {
      type: String,
      default: () => r("select.icon", void 0)
    },
    /** Makes the icon clickable */
    iconClickable: { type: Boolean, default: !1 },
    /** Icon to be added on the right side */
    iconRight: {
      type: String,
      default: () => r("select.iconRight", void 0)
    },
    /** Make the icon right clickable */
    iconRightClickable: { type: Boolean, default: !1 },
    /** Variant of right icon */
    iconRightVariant: { type: String, default: void 0 },
    /** Accessibility label to establish relationship between the input and control label */
    ariaLabelledby: { type: String, default: () => Ye() },
    /** Enable html 5 native validation */
    useHtml5Validation: {
      type: Boolean,
      default: () => r("useHtml5Validation", !0)
    },
    /** The message which is shown when a validation error occurs */
    validationMessage: { type: String, default: void 0 },
    /** Same as native autocomplete options to use in HTML5 validation */
    autocomplete: {
      type: String,
      default: () => r("select.autocomplete", "off")
    },
    /** Show status icon using field and variant prop */
    statusIcon: {
      type: Boolean,
      default: () => r("statusIcon", !0)
    },
    // class props (will not be displayed in the docs)
    /** Class of the root element */
    rootClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the native select element */
    selectClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the left icon space inside the select */
    iconLeftSpaceClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the right icon space inside the select */
    iconRightSpaceClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of select when rounded */
    roundedClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the select when multiple mode is active */
    multipleClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of select when expanded */
    expandedClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of select when disabled */
    disabledClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the left icon */
    iconLeftClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the right icon */
    iconRightClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the select size */
    sizeClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the select variant */
    variantClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the select placeholder */
    placeholderClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the select arrow */
    arrowClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the select variant for the root element*/
    rootVariantClass: {
      type: [String, Array, Function],
      default: void 0
    }
  },
  emits: ["update:modelValue", "focus", "blur", "invalid", "icon-click", "icon-right-click"],
  setup(e, { expose: n, emit: a }) {
    const t = e, o = a, i = L(), { checkHtml5Validity: u, onBlur: d, onFocus: m, onInvalid: c, setFocus: v } = rt(i, o, t), { parentField: p, statusVariant: C, statusVariantIcon: B } = Lt(), A = dt(t, o, { passive: !0 }), g = l(() => A.value === null);
    st(() => {
      ce(
        () => A.value,
        (b) => {
          p != null && p.value && p.value.setFilled(!!b), u();
        },
        { immediate: !0 }
      );
    });
    const y = l(() => !t.options || !Array.isArray(t.options) ? [] : t.options.map(
      (b) => typeof b == "string" ? { value: b, label: b, key: Ye() } : { ...b, key: Ye() }
    )), I = l(
      () => t.iconRight && !t.multiple || t.statusIcon && B.value
    ), k = l(
      () => t.iconRight ? t.iconRight : B.value
    ), z = l(
      () => t.iconRight ? t.iconRightVariant || t.variant || null : C.value
    );
    function R(b, D) {
      o(b, D), De(() => v());
    }
    function H(b) {
      t.iconRightClickable && R("icon-right-click", b);
    }
    const j = h(
      ["rootClass", "o-ctrl-sel"],
      [
        "expandedClass",
        "o-ctrl-sel--expanded",
        null,
        l(() => t.expanded)
      ],
      [
        "rootVariantClass",
        "o-ctrl-sel--",
        l(() => C.value || t.variant),
        l(() => !!C.value || !!t.variant)
      ]
    ), U = h(
      ["selectClass", "o-sel"],
      ["roundedClass", "o-sel--rounded", null, l(() => t.rounded)],
      ["multipleClass", "o-sel--multiple", null, l(() => t.multiple)],
      [
        "sizeClass",
        "o-sel--",
        l(() => t.size),
        l(() => !!t.size)
      ],
      [
        "variantClass",
        "o-sel--",
        l(() => C.value || t.variant),
        l(() => !!C.value || !!t.variant)
      ],
      ["disabledClass", "o-sel--disabled", null, l(() => t.disabled)],
      [
        "iconLeftSpaceClass",
        "o-sel-iconspace-left",
        null,
        l(() => !!t.icon)
      ],
      [
        "iconRightSpaceClass",
        "o-sel-iconspace-right",
        null,
        l(() => !!t.iconRight)
      ],
      ["placeholderClass", "o-sel--placeholder", null, g],
      [
        "arrowClass",
        "o-sel-arrow",
        null,
        l(() => !t.iconRight && !t.multiple)
      ]
    ), Q = h(["iconLeftClass", "o-sel__icon-left"]), V = h(["iconRightClass", "o-sel__icon-right"]);
    return n({ focus: v }), (b, D) => (f(), P("div", {
      class: M(s(j)),
      "data-oruga": "select"
    }, [
      e.icon ? (f(), ne(Re, {
        key: 0,
        class: M(s(Q)),
        clickable: e.iconClickable,
        icon: e.icon,
        pack: e.iconPack,
        size: e.size,
        onClick: D[0] || (D[0] = (W) => R("icon-click", W))
      }, null, 8, ["class", "clickable", "icon", "pack", "size"])) : J("", !0),
      $e(le("select", be(b.$attrs, {
        ref_key: "selectRef",
        ref: i,
        "onUpdate:modelValue": D[1] || (D[1] = (W) => Ke(A) ? A.value = W : null),
        "data-oruga-input": "select",
        class: s(U),
        autocomplete: e.autocomplete,
        multiple: e.multiple,
        size: e.nativeSize,
        disabled: e.disabled,
        "aria-labelledby": e.ariaLabelledby,
        onBlur: D[2] || (D[2] = //@ts-ignore
        (...W) => s(d) && s(d)(...W)),
        onFocus: D[3] || (D[3] = //@ts-ignore
        (...W) => s(m) && s(m)(...W)),
        onInvalid: D[4] || (D[4] = //@ts-ignore
        (...W) => s(c) && s(c)(...W))
      }), [
        e.placeholder || b.$slots.placeholder ? (f(), P(he, { key: 0 }, [
          g.value ? (f(), P("option", xn, [
            _(b.$slots, "placeholder", {}, () => [
              Pe(ue(e.placeholder), 1)
            ])
          ])) : J("", !0)
        ], 64)) : J("", !0),
        _(b.$slots, "default", {}, () => [
          (f(!0), P(he, null, xe(y.value, (W) => (f(), P("option", be({
            key: W.key,
            value: W.value
          }, W.attrs), ue(W.label), 17, $n))), 128))
        ])
      ], 16, Dn), [
        [Ml, s(A)]
      ]),
      I.value ? (f(), ne(Re, {
        key: 1,
        class: M(s(V)),
        clickable: e.iconRightClickable,
        icon: k.value,
        pack: e.iconPack,
        size: e.size,
        variant: z.value,
        both: "",
        onClick: H
      }, null, 8, ["class", "clickable", "icon", "pack", "size", "variant"])) : J("", !0)
    ], 2));
  }
}), Bn = ["data-oruga"], Qa = /* @__PURE__ */ ye({
  name: "OPickerWrapper",
  __name: "PickerWrapper",
  props: {
    /** parent picker component props  */
    pickerProps: { type: Object, required: !0 },
    /** data-oruga attribute value */
    dataOruga: { type: String, required: !0 },
    /** the input value */
    value: { type: [Date, Array], default: void 0 },
    /** the active state of the dropdown */
    active: { type: Boolean, default: !1 },
    formattedValue: { type: String, default: void 0 },
    nativeType: { type: String, required: !0 },
    nativeStep: { type: String, default: void 0 },
    nativeValue: { type: [String, Number], default: void 0 },
    nativeMin: { type: [String, Number], default: void 0 },
    nativeMax: { type: [String, Number], default: void 0 },
    stayOpen: { type: Boolean, default: !1 },
    rootClasses: {
      type: Array,
      required: !0
    },
    dropdownClasses: {
      type: Array,
      required: !0
    },
    boxClass: {
      type: Array,
      required: !0
    }
  },
  emits: ["update:active", "change", "native-change", "focus", "blur", "invalid", "icon-click", "icon-right-click"],
  setup(e, { expose: n, emit: a }) {
    const t = e, o = a, i = l(() => t.pickerProps), u = l(
      () => i.value.mobileNative && vt.any()
    ), d = L(), m = L(), c = L(), v = l(
      () => u.value ? c.value : m.value
    ), {
      checkHtml5Validity: p,
      setFocus: C,
      doClick: B,
      onBlur: A,
      onFocus: g,
      onInvalid: y,
      isValid: I,
      isFocused: k
    } = rt(v, o, i.value), z = l(
      () => !i.value.placeholder || t.nativeValue || k.value ? t.nativeType : "text"
    );
    ce(
      () => t.value,
      () => {
        t.stayOpen || Q(!1), u.value && !I.value && p();
      }
    );
    const R = qe("active", t, o, {
      passive: !0
    });
    ce(R, b);
    const H = l(() => i.value.inline ? void 0 : "dialog"), j = l(() => i.value.openOnFocus ? ["click"] : []);
    Be && Ze("keyup", U);
    function U(E) {
      R.value && (E.key === "Escape" || E.key === "Esc") && Q(!1);
    }
    function Q(E) {
      u.value ? (C(), B()) : d.value && (E || i.value.closeOnClick) && De(() => R.value = E);
    }
    function V(E) {
      R.value && E.stopPropagation();
    }
    function b(E) {
      E ? g() : E || A();
    }
    const D = da(), W = l(() => ({
      ...D,
      ...i.value.inputClasses
    })), G = l(() => ({
      "root-class": Ee(t.dropdownClasses),
      ...i.value.dropdownClasses
    }));
    return n({ focus: C }), (E, S) => (f(), P("div", {
      "data-oruga": e.dataOruga,
      class: M(e.rootClasses)
    }, [
      !u.value || i.value.inline ? (f(), ne(va, be({
        key: 0,
        ref_key: "dropdownRef",
        ref: d
      }, G.value, {
        active: s(R),
        "onUpdate:active": S[4] || (S[4] = (w) => Ke(R) ? R.value = w : null),
        position: i.value.position,
        disabled: i.value.disabled,
        inline: i.value.inline,
        "mobile-modal": i.value.mobileModal,
        "trap-focus": i.value.trapFocus,
        "aria-role": H.value,
        "aria-modal": !i.value.inline,
        tabindex: -1,
        teleport: i.value.teleport,
        triggers: j.value
      }), qt({
        default: se(() => [
          me(ht, {
            override: "",
            tag: "div",
            "item-class": e.boxClass,
            disabled: i.value.disabled,
            clickable: !1
          }, {
            default: se(() => [
              _(E.$slots, "default")
            ]),
            _: 3
          }, 8, ["item-class", "disabled"])
        ]),
        _: 2
      }, [
        i.value.inline ? void 0 : {
          name: "trigger",
          fn: se(() => [
            _(E.$slots, "trigger", {}, () => [
              me(At, be({
                ref_key: "inputRef",
                ref: m
              }, W.value, {
                autocomplete: "off",
                "model-value": e.formattedValue,
                placeholder: i.value.placeholder,
                size: i.value.size,
                "icon-pack": i.value.iconPack,
                icon: i.value.icon,
                "icon-right": i.value.iconRight,
                "icon-right-clickable": i.value.iconRightClickable,
                expanded: i.value.expanded,
                rounded: i.value.rounded,
                disabled: i.value.disabled,
                readonly: i.value.readonly,
                "use-html5-validation": !1,
                onClick: V,
                onKeyup: S[0] || (S[0] = Ce((w) => Q(!0), ["enter"])),
                onChange: S[1] || (S[1] = (w) => E.$emit("change", w.target.value)),
                onFocus: s(g),
                onBlur: s(A),
                onIconClick: S[2] || (S[2] = (w) => E.$emit("icon-click", w)),
                onIconRightClick: S[3] || (S[3] = (w) => E.$emit("icon-right-click", w))
              }), null, 16, ["model-value", "placeholder", "size", "icon-pack", "icon", "icon-right", "icon-right-clickable", "expanded", "rounded", "disabled", "readonly", "onFocus", "onBlur"])
            ])
          ]),
          key: "0"
        }
      ]), 1040, ["active", "position", "disabled", "inline", "mobile-modal", "trap-focus", "aria-role", "aria-modal", "teleport", "triggers"])) : (f(), ne(At, be({
        key: 1,
        ref_key: "nativeInputRef",
        ref: c
      }, W.value, {
        type: z.value,
        autocomplete: "off",
        "model-value": e.nativeValue,
        min: e.nativeMin,
        max: e.nativeMax,
        step: e.nativeStep,
        placeholder: i.value.placeholder,
        size: i.value.size,
        "icon-pack": i.value.iconPack,
        icon: i.value.icon,
        "icon-right": i.value.iconRight,
        "icon-right-clickable": i.value.iconRightClickable,
        rounded: i.value.rounded,
        disabled: i.value.disabled,
        readonly: !1,
        "use-html5-validation": !1,
        onChange: S[5] || (S[5] = (w) => E.$emit("native-change", w.target.value)),
        onFocus: s(g),
        onBlur: s(A),
        onInvalid: s(y),
        onIconClick: S[6] || (S[6] = (w) => E.$emit("icon-click", w)),
        onIconRightClick: S[7] || (S[7] = (w) => E.$emit("icon-right-click", w))
      }), null, 16, ["type", "model-value", "min", "max", "step", "placeholder", "size", "icon-pack", "icon", "icon-right", "icon-right-clickable", "rounded", "disabled", "onFocus", "onBlur", "onInvalid"]))
    ], 10, Bn));
  }
});
function On(e = void 0, n = "long") {
  const a = [];
  for (let o = 0; o < 12; o++)
    a.push(new Date(2e3, o, 15));
  const t = new Intl.DateTimeFormat(e, {
    month: n
    // timeZone: 'UTC'
  });
  return a.map((o) => t.format(o));
}
function Pn(e = void 0, n = 0, a = "narrow") {
  const t = [];
  for (let i = 1, u = 0; u < 7; i++) {
    const d = new Date(2e3, 0, i);
    (d.getDay() === n || u > 0) && (t.push(d), u++);
  }
  const o = new Intl.DateTimeFormat(e, {
    weekday: a
    // timeZone: 'UTC'
  });
  return t.map((i) => o.format(i));
}
function pa(e, n) {
  const a = n.match(e);
  return e.toString().match(/<(.+?)>/g).map((t) => {
    const o = t.match(/<(.+)>/);
    return !o || o.length <= 0 ? null : t.match(/<(.+)>/)[1];
  }).reduce((t, o, i) => (a && a.length > i ? t[o] = a[i + 1] : t[o] = null, t), {});
}
function Mn(e, n, a, t) {
  const o = new Date(a, n), i = [], u = new Date(a, n, e).getDay(), d = u >= t ? u - t : 7 - t + u;
  let m = 1;
  for (let v = 0; v < d; v++)
    i.unshift(
      new Date(
        o.getFullYear(),
        o.getMonth(),
        e - m
      )
    ), m++;
  i.push(new Date(a, n, e));
  let c = 1;
  for (; i.length < 7; )
    i.push(new Date(a, n, e + c)), c++;
  return i;
}
function ra(e, n, a) {
  const t = 7 + n - a;
  return -((7 + new Date(e, 0, t).getDay() - n) % 7) + t - 1;
}
function Rn(e) {
  return e % 4 === 0 && e % 100 !== 0 || e % 400 === 0 ? 366 : 365;
}
function ta(e, n, a) {
  const t = ra(e, n, a), o = ra(e + 1, n, a);
  return (Rn(e) - t + o) / 7;
}
function ma(e) {
  function n(c, v) {
    const p = [];
    if (e.minDate && p.push(c >= e.minDate), e.maxDate && p.push(c <= e.maxDate), e.nearbyMonthDays && !e.nearbySelectableMonthDays && p.push(c.getMonth() === v), e.selectableDates)
      if (typeof e.selectableDates == "function") {
        if (e.selectableDates(c))
          return !0;
        p.push(!1);
      } else
        for (let C = 0; C < e.selectableDates.length; C++) {
          const B = e.selectableDates[C];
          if (c.getDate() === B.getDate() && c.getFullYear() === B.getFullYear() && c.getMonth() === B.getMonth())
            return !0;
          p.push(!1);
        }
    if (e.unselectableDates)
      if (typeof e.unselectableDates == "function")
        p.push(!e.unselectableDates(c));
      else
        for (let C = 0; C < e.unselectableDates.length; C++) {
          const B = e.unselectableDates[C];
          p.push(
            c.getDate() !== B.getDate() || c.getFullYear() !== B.getFullYear() || c.getMonth() !== B.getMonth()
          );
        }
    if (e.unselectableDaysOfWeek)
      for (let C = 0; C < e.unselectableDaysOfWeek.length; C++) {
        const B = e.unselectableDaysOfWeek[C];
        p.push(c.getDay() !== B);
      }
    return p.indexOf(!1) < 0;
  }
  const a = l(() => e.type === "month"), t = l(
    () => new Intl.DateTimeFormat(e.locale, {
      year: "numeric",
      month: "numeric"
    }).resolvedOptions()
  ), o = l(
    () => new Intl.DateTimeFormat(
      e.locale
      /*, { timeZone: 'UTC' }*/
    )
  ), i = l(
    () => new Intl.DateTimeFormat(e.locale, {
      year: t.value.year || "numeric",
      month: t.value.month || "2-digit"
      // timeZone: 'UTC'
    })
  ), u = l(() => {
    const c = e.dateCreator();
    return c.setHours(10), c.setSeconds(0), c.setMinutes(0), c.setMilliseconds(0), c;
  });
  return { isDateSelectable: n, defaultDateParser: (c) => {
    if (!c)
      return null;
    if (o.value.formatToParts && typeof o.value.formatToParts == "function") {
      const B = (a.value ? i.value : o.value).formatToParts(u.value).map((g) => g.type === "literal" ? g.value : `((?!=<${g.type}>)\\d+)`).join(""), A = pa(B, c);
      if (A.year && A.year.length === 4 && A.month && A.month <= 12) {
        if (a.value)
          return new Date(A.year, A.month - 1);
        if (A.day && A.day <= 31)
          return new Date(
            A.year,
            A.month - 1,
            A.day,
            12
          );
      }
    }
    if (!a.value)
      return new Date(Date.parse(c));
    const v = c.split("/"), p = v[0].length === 4 ? v[0] : v[1], C = v[0].length === 2 ? v[0] : v[1];
    if (p && C)
      return new Date(
        parseInt(p, 10),
        parseInt(C, 10) - 1,
        1,
        0,
        0,
        0,
        0
      );
  }, defaultDateFormatter: (c) => {
    if (!c)
      return "";
    const p = (Array.isArray(c) ? c : [c]).map((C) => {
      const B = new Date(
        C.getFullYear(),
        C.getMonth(),
        C.getDate(),
        12
      );
      return a.value ? i.value.format(B) : o.value.format(B);
    });
    return e.multiple ? p.join(", ") : p.join(" - ");
  } };
}
const Vn = ["tabindex"], Tn = ["tabindex", "onClick", "onMouseenter", "onFocus", "onKeydown"], In = /* @__PURE__ */ ye({
  name: "ODatepickerTableRow",
  configField: "datepicker",
  __name: "DatepickerTableRow",
  props: {
    day: { type: Number, required: !0 },
    week: { type: Array, required: !0 },
    month: { type: Number, required: !0 },
    selectedDate: {
      type: [Date, Array],
      default: void 0
    },
    events: { type: Array, default: void 0 },
    hoveredDateRange: { type: Array, default: () => [] },
    pickerProps: {
      type: Object,
      required: !0
    }
  },
  emits: ["select", "hover-enddate", "change-focus", "week-number-click"],
  setup(e, { emit: n }) {
    const a = e, t = n, { isDateSelectable: o } = ma(a.pickerProps), i = l(() => a.pickerProps), u = l(() => {
      var V;
      return !!((V = a.events) != null && V.length);
    }), d = L(/* @__PURE__ */ new Map());
    function m(V, b) {
      const D = `day-${V.getMonth()}-${V.getDate()}`;
      b && d.value.set(D, b);
    }
    ce(
      () => a.day,
      (V) => {
        a.week.map((b) => b.getDate()).includes(V) && De(() => {
          const b = `day-${a.month}-${V}`, D = d.value.get(b);
          D && D.focus();
        });
      }
    ), ce(
      () => a.month,
      // clear day refs on month change
      () => d.value = /* @__PURE__ */ new Map()
    );
    function c(V) {
      i.value.weekNumberClickable && t("week-number-click", V);
    }
    function v(V) {
      return Math.round(
        (V.getTime() - new Date(V.getFullYear(), 0, 1).getTime()) / 864e5
      ) + 1;
    }
    function p(V) {
      const b = i.value.firstDayOfWeek, D = i.value.rulesForFirstWeek, W = ra(V.getFullYear(), b, D), G = Math.floor((v(V) - W - 1) / 7) + 1;
      let E, S;
      return G < 1 ? (S = V.getFullYear() - 1, E = G + ta(S, b, D)) : G > ta(V.getFullYear(), b, D) ? (E = G - ta(V.getFullYear(), b, D), S = V.getFullYear() + 1) : (S = V.getFullYear(), E = G), E;
    }
    function C(V) {
      var b;
      return (b = a.events) != null && b.length ? a.events.filter((D) => D.date.getDay() === V.getDay()) : [];
    }
    function B(V, b) {
      let D = !0;
      switch (V.key) {
        case "Tab": {
          D = !1;
          break;
        }
        case " ":
        case "Space":
        case "Spacebar":
        case "Enter": {
          A(b);
          break;
        }
        case "ArrowLeft":
        case "Left": {
          g(b, -1);
          break;
        }
        case "ArrowRight":
        case "Right": {
          g(b, 1);
          break;
        }
        case "ArrowUp":
        case "Up": {
          g(b, -7);
          break;
        }
        case "ArrowDown":
        case "Down": {
          g(b, 7);
          break;
        }
      }
      D && V.preventDefault();
    }
    function A(V) {
      i.value.disabled || o(V, a.month) && t("select", V);
    }
    function g(V, b) {
      const D = new Date(V.getTime());
      for (D.setDate(V.getDate() + b); i.value.minDate && D < i.value.minDate || i.value.maxDate && D > i.value.maxDate || !o(D, D.getMonth()); )
        D.setDate(D.getDate() - Math.sign(b));
      y(D), t("change-focus", D);
    }
    function y(V) {
      i.value.range && t("hover-enddate", V);
    }
    function I(V, b, D = !1) {
      return !V || !b || D ? !1 : Array.isArray(b) ? b.some(
        (W) => V.getDate() === W.getDate() && V.getFullYear() === W.getFullYear() && V.getMonth() === W.getMonth()
      ) : V.getDate() === b.getDate() && V.getFullYear() === b.getFullYear() && V.getMonth() === b.getMonth();
    }
    function k(V, b, D = !1) {
      return !Array.isArray(b) || D ? !1 : V > b[0] && V < b[1];
    }
    function z(V) {
      const b = h(
        [
          "tableCellSelectedClass",
          "o-dpck__table__cell--selected",
          null,
          I(V, a.selectedDate) || k(V, a.selectedDate, i.value.multiple)
        ],
        [
          "tableCellFirstSelectedClass",
          "o-dpck__table__cell--first-selected",
          null,
          I(
            V,
            Array.isArray(a.selectedDate) && a.selectedDate[0],
            i.value.multiple
          )
        ],
        [
          "tableCellWithinSelectedClass",
          "o-dpck__table__cell--within-selected",
          null,
          k(V, a.selectedDate, i.value.multiple)
        ],
        [
          "tableCellLastSelectedClass",
          "o-dpck__table__cell--last-selected",
          null,
          I(
            V,
            Array.isArray(a.selectedDate) && a.selectedDate[1],
            i.value.multiple
          )
        ],
        [
          "tableCellFirstHoveredClass",
          "o-dpck__table__cell--first-hovered",
          null,
          I(
            V,
            Array.isArray(a.hoveredDateRange) && a.hoveredDateRange[0]
          )
        ],
        [
          "tableCellWithinHoveredClass",
          "o-dpck__table__cell--within-hovered",
          null,
          k(V, a.hoveredDateRange)
        ],
        [
          "tableCellLastHoveredClass",
          "o-dpck__table__cell--last-hovered",
          null,
          I(
            V,
            Array.isArray(a.hoveredDateRange) && a.hoveredDateRange[1]
          )
        ],
        [
          "tableCellTodayClass",
          "o-dpck__table__cell--today",
          null,
          I(V, i.value.dateCreator())
        ],
        [
          "tableCellSelectableClass",
          "o-dpck__table__cell--selectable",
          null,
          o(V, a.month) && !i.value.disabled
        ],
        [
          "tableCellUnselectableClass",
          "o-dpck__table__cell--unselectable",
          null,
          !o(V, a.month) || i.value.disabled
        ],
        [
          "tableCellInvisibleClass",
          "o-dpck__table__cell--invisible",
          null,
          !i.value.nearbyMonthDays && V.getMonth() !== a.month
        ],
        [
          "tableCellNearbyClass",
          "o-dpck__table__cell--nearby",
          null,
          i.value.nearbySelectableMonthDays && V.getMonth() !== a.month
        ],
        [
          "tableCellTodayClass",
          "o-dpck__table__cell--today",
          null,
          I(V, i.value.dateCreator())
        ]
      );
      return [
        ...j.value,
        ...Q.value,
        ...b.value
      ];
    }
    function R(V) {
      return h(
        ["tableEventClass", "o-dpck__table__event"],
        [
          "tableEventVariantClass",
          "o-dpck__table__event--",
          V.type,
          !!V.type
        ],
        [
          "tableEventIndicatorsClass",
          "o-dpck__table__event--",
          i.value.indicators,
          !!i.value.indicators
        ]
      ).value;
    }
    const H = h(["tableRowClass", "o-dpck__table__row"]), j = h([
      "tableCellClass",
      "o-dpck__table__cell"
    ]), U = h([
      "tableEventsClass",
      "o-dpck__table__events"
    ]), Q = h([
      "tableCellEventsClass",
      "o-dpck__table__cell--events",
      null,
      u
    ]);
    return (V, b) => (f(), P("div", {
      class: M(s(H))
    }, [
      i.value.showWeekNumber ? (f(), P("div", {
        key: 0,
        class: M(s(j)),
        style: _e({
          cursor: i.value.weekNumberClickable ? "pointer" : "auto"
        }),
        tabindex: i.value.weekNumberClickable ? 0 : null,
        role: "button",
        onClick: b[0] || (b[0] = ve((D) => c(p(e.week[6])), ["prevent"])),
        onKeydown: b[1] || (b[1] = Ce(ve((D) => c(p(e.week[6])), ["prevent"]), ["enter"]))
      }, [
        le("span", null, ue(p(e.week[6])), 1)
      ], 46, Vn)) : J("", !0),
      (f(!0), P(he, null, xe(e.week, (D, W) => (f(), P(he, { key: W }, [
        !i.value.disabled && s(o)(D, e.month) ? (f(), P("div", {
          key: 0,
          ref_for: !0,
          ref: (G) => m(D, G),
          class: M(z(D)),
          role: "button",
          tabindex: e.day === D.getDate() && e.month === D.getMonth() ? null : 0,
          onClick: ve((G) => A(D), ["prevent"]),
          onMouseenter: (G) => y(D),
          onFocus: (G) => y(D),
          onKeydown: Ce(ve((G) => B(G, D), ["prevent"]), ["enter"])
        }, [
          le("span", null, ue(D.getDate()), 1),
          C(D).length ? (f(), P("div", {
            key: 0,
            class: M(s(U))
          }, [
            (f(!0), P(he, null, xe(C(D), (G, E) => (f(), P("div", {
              key: E,
              class: M(R(G))
            }, null, 2))), 128))
          ], 2)) : J("", !0)
        ], 42, Tn)) : (f(), P("div", {
          key: 1,
          class: M(z(D))
        }, [
          le("span", null, ue(D.getDate()), 1)
        ], 2))
      ], 64))), 128))
    ], 2));
  }
}), zn = /* @__PURE__ */ ye({
  name: "ODatepickerTable",
  configField: "datepicker",
  __name: "DatepickerTable",
  props: /* @__PURE__ */ Ue({
    modelValue: {
      type: [Date, Array],
      default: void 0
    },
    focusedDate: { type: Object, required: !0 },
    dayNames: { type: Array, required: !0 },
    monthNames: { type: Array, required: !0 },
    pickerProps: {
      type: Object,
      required: !0
    }
  }, {
    focusedDate: {},
    focusedDateModifiers: {}
  }),
  emits: /* @__PURE__ */ Ue(["update:modelValue", "update:focusedDate", "range-start", "range-end", "week-number-click"], ["update:focusedDate"]),
  setup(e, { emit: n }) {
    const a = e, t = n, { isDateSelectable: o } = ma(a.pickerProps), i = it(e, "focusedDate"), u = L(), d = L(), m = L(), c = l(() => a.pickerProps), v = l(() => {
      const b = [];
      let D = c.value.firstDayOfWeek;
      for (; b.length < a.dayNames.length; ) {
        const W = a.dayNames[D % a.dayNames.length];
        b.push(W), D++;
      }
      return c.value.showWeekNumber && b.unshift(""), b;
    }), p = l(() => c.value.events ? c.value.events.map(
      (b) => !b.date && b instanceof Date ? { date: b } : b
    ).filter(
      (b) => b.date.getMonth() === i.value.month && b.date.getFullYear() === i.value.year
    ) : []), C = l(() => {
      g();
      const b = i.value.month, D = i.value.year, W = [];
      let G = 1;
      for (; W.length < 6; ) {
        const E = Mn(
          G,
          b,
          D,
          c.value.firstDayOfWeek
        );
        W.push(E), G += 7;
      }
      return W;
    });
    function B(b) {
      return c.value.events ? p.value.filter((D) => {
        const W = new Date(D.date);
        W.setHours(0, 0, 0, 0);
        const G = W.getTime();
        return b.some((E) => E.getTime() === G);
      }) : [];
    }
    const A = l(() => !c.value.range || d.value ? [] : (m.value < u.value ? [m.value, u.value] : [u.value, m.value]).filter(ot));
    function g() {
      const b = new Date(
        i.value.year,
        i.value.month,
        i.value.day
      );
      if (o(b, i.value.month))
        return;
      let D = 0;
      const W = new Date(
        i.value.year,
        i.value.month + 1,
        0
      ).getDate();
      let G = null;
      for (; !G && ++D < W; ) {
        const E = new Date(
          i.value.year,
          i.value.month,
          D
        );
        o(E, i.value.month) && (G = b, i.value = {
          day: E.getDate(),
          month: E.getMonth(),
          year: E.getFullYear()
        });
      }
    }
    function y(b) {
      c.value.disabled || (!c.value.range && !c.value.multiple ? t("update:modelValue", b) : c.value.range ? I(b) : c.value.multiple && k(b));
    }
    function I(b) {
      u.value && d.value ? (u.value = b, d.value = void 0, t("range-start", b)) : u.value && !d.value ? (u.value > b ? (d.value = u.value, u.value = b) : d.value = b, t("range-end", b), t("update:modelValue", [
        u.value,
        d.value
      ])) : (u.value = b, t("range-start", b));
    }
    function k(b) {
      if (!Array.isArray(a.modelValue))
        return;
      let D = a.modelValue;
      D.filter(
        (G) => G.getDate() === b.getDate() && G.getFullYear() === b.getFullYear() && G.getMonth() === b.getMonth()
      ).length ? D = D.filter(
        (G) => G.getDate() !== b.getDate() || G.getFullYear() !== b.getFullYear() || G.getMonth() !== b.getMonth()
      ) : D = [...D, b], t("update:modelValue", D);
    }
    function z(b) {
      m.value = b;
    }
    function R(b) {
      i.value = {
        day: b.getDate(),
        month: b.getMonth(),
        year: b.getFullYear()
      };
    }
    const H = h(["tableClass", "o-dpck__table"]), j = h([
      "tableHeadClass",
      "o-dpck__table__head"
    ]), U = h([
      "tableCellClass",
      "o-dpck__table__cell"
    ]), Q = h([
      "tableHeadCellClass",
      "o-dpck__table__head-cell"
    ]), V = h([
      "tableBodyClass",
      "o-dpck__table__body"
    ]);
    return (b, D) => (f(), P("section", {
      class: M(s(H))
    }, [
      le("header", {
        class: M(s(j))
      }, [
        (f(!0), P(he, null, xe(v.value, (W, G) => (f(), P("div", {
          key: G,
          class: M([...s(U), ...s(Q)])
        }, [
          le("span", null, ue(W), 1)
        ], 2))), 128))
      ], 2),
      le("div", {
        class: M(s(V))
      }, [
        (f(!0), P(he, null, xe(C.value, (W, G) => (f(), ne(In, {
          key: G,
          "selected-date": e.modelValue,
          day: i.value.day,
          week: W,
          month: i.value.month,
          events: B(W),
          "hovered-date-range": A.value,
          "picker-props": a.pickerProps,
          onSelect: y,
          onHoverEnddate: z,
          onChangeFocus: R,
          onWeekNumberClick: D[0] || (D[0] = (E) => b.$emit("week-number-click", E))
        }, null, 8, ["selected-date", "day", "week", "month", "events", "hovered-date-range", "picker-props"]))), 128))
      ], 2)
    ], 2));
  }
}), Hn = ["disabled", "tabindex", "onClick", "onMouseenter", "onFocus", "onKeydown"], Ln = {
  key: 0,
  class: "events"
}, Nn = /* @__PURE__ */ ye({
  name: "ODatepickerMonth",
  configField: "datepicker",
  inheritAttrs: !1,
  __name: "DatepickerMonth",
  props: {
    modelValue: {
      type: [Date, Array],
      default: void 0
    },
    monthNames: { type: Array, required: !0 },
    focusedDate: { type: Object, required: !0 },
    pickerProps: {
      type: Object,
      required: !0
    }
  },
  emits: ["update:modelValue", "update:focusedDate", "range-start", "range-end"],
  setup(e, { emit: n }) {
    const a = e, t = n, o = L(), i = L(), u = L(), d = l(() => a.pickerProps), m = l(() => {
      var S;
      return !!((S = d.value.events) != null && S.length);
    }), c = L(/* @__PURE__ */ new Map());
    function v(S, w) {
      const $ = `month-${S.getMonth()}`;
      w && c.value.set($, w);
    }
    ce(
      () => a.focusedDate.month,
      (S) => {
        const w = `month-${S}`;
        De(() => {
          const $ = c.value.get(w);
          ($ == null ? void 0 : $.length) > 0 && $[0] && $[0].focus();
        });
      }
    );
    const p = l(() => d.value.events ? d.value.events.map((S) => (!S.date && S instanceof Date && (S = { date: S }), S.type || (S.type = "is-primary"), S)).filter((S) => S.date.getFullYear() === a.focusedDate.year) : []), C = l(() => {
      const S = a.focusedDate.year, w = [];
      for (let $ = 0; $ < 12; $++) {
        const N = new Date(S, $, 1);
        N.setHours(0, 0, 0, 0), w.push(N);
      }
      return w;
    }), B = l(() => !d.value.range || !i.value ? [] : (u.value < o.value ? [u.value, o.value] : [o.value, u.value]).filter(ot));
    function A(S) {
      return p.value.length ? p.value.filter(
        (w) => w.date.getMonth() === S.getMonth()
      ) : [];
    }
    function g(S) {
      const w = [];
      if (d.value.minDate && w.push(S >= d.value.minDate), d.value.maxDate && w.push(S <= d.value.maxDate), w.push(S.getFullYear() === a.focusedDate.year), d.value.selectableDates)
        if (typeof d.value.selectableDates == "function") {
          if (d.value.selectableDates(S))
            return !0;
          w.push(!1);
        } else
          for (let $ = 0; $ < d.value.selectableDates.length; $++) {
            const N = d.value.selectableDates[$];
            if (S.getFullYear() === N.getFullYear() && S.getMonth() === N.getMonth())
              return !0;
            w.push(!1);
          }
      if (d.value.unselectableDates)
        if (typeof d.value.unselectableDates == "function")
          w.push(!d.value.unselectableDates(S));
        else
          for (let $ = 0; $ < d.value.unselectableDates.length; $++) {
            const N = d.value.unselectableDates[$];
            w.push(
              S.getFullYear() !== N.getFullYear() || S.getMonth() !== N.getMonth()
            );
          }
      if (d.value.unselectableDaysOfWeek)
        for (let $ = 0; $ < d.value.unselectableDaysOfWeek.length; $++) {
          const N = d.value.unselectableDaysOfWeek[$];
          w.push(S.getDay() !== N);
        }
      return w.indexOf(!1) < 0;
    }
    function y(S, w) {
      let $ = !0;
      switch (S.key) {
        case "Tab": {
          $ = !1;
          break;
        }
        case " ":
        case "Space":
        case "Spacebar":
        case "Enter": {
          I(w);
          break;
        }
        case "ArrowLeft":
        case "Left": {
          H(w, -1);
          break;
        }
        case "ArrowRight":
        case "Right": {
          H(w, 1);
          break;
        }
        case "ArrowUp":
        case "Up": {
          H(w, -7);
          break;
        }
        case "ArrowDown":
        case "Down": {
          H(w, 7);
          break;
        }
      }
      $ && S.preventDefault();
    }
    function I(S) {
      d.value.disabled || (!d.value.range && !d.value.multiple && g(S) ? t("update:modelValue", S) : d.value.range ? k(S) : d.value.multiple && R(S));
    }
    function k(S) {
      o.value && i.value ? (o.value = S, i.value = void 0, t("range-start", S)) : o.value && !i.value ? (o.value > S ? (i.value = o.value, o.value = S) : i.value = S, t("range-end", S), t("update:modelValue", [
        o.value,
        i.value
      ])) : (o.value = S, t("range-start", S));
    }
    const z = l(
      () => d.value.multiple && a.modelValue ? a.modelValue : []
    );
    function R(S) {
      if (!Array.isArray(a.modelValue))
        return;
      let w = a.modelValue;
      w.filter(
        (N) => N.getDate() === S.getDate() && N.getFullYear() === S.getFullYear() && N.getMonth() === S.getMonth()
      ).length ? w = w.filter(
        (N) => N.getDate() !== S.getDate() || N.getFullYear() !== S.getFullYear() || N.getMonth() !== S.getMonth()
      ) : w.push(S), t("update:modelValue", w);
    }
    function H(S, w) {
      S.setMonth(S.getMonth() + w);
      const $ = {
        day: S.getDate(),
        month: S.getMonth(),
        year: S.getFullYear()
      };
      t("update:focusedDate", $);
    }
    function j(S) {
      d.value.range && (u.value = S);
    }
    function U(S, w, $ = !1) {
      return !S || !w || $ ? !1 : Array.isArray(w) ? w.some(
        (N) => S.getFullYear() === N.getFullYear() && S.getMonth() === N.getMonth()
      ) : S.getFullYear() === w.getFullYear() && S.getMonth() === w.getMonth();
    }
    function Q(S, w, $ = !1) {
      return !Array.isArray(w) || $ ? !1 : S > w[0] && S < w[1];
    }
    function V(S, w, $ = !1) {
      return !Array.isArray(w) || !$ ? !1 : w.some(
        (N) => S.getDate() === N.getDate() && S.getFullYear() === N.getFullYear() && S.getMonth() === N.getMonth()
      );
    }
    const b = h(["monthClass", "o-dpck__month"]), D = h([
      "monthBodyClass",
      "o-dpck__month__body"
    ]), W = h([
      "monthTableClass",
      "o-dpck__month__table"
    ]), G = h(
      ["monthCellClass", "o-dpck__month__cell"],
      ["monthCellEventsClass", "o-dpck__month__cell--events", null, m]
    );
    function E(S) {
      const w = h(
        [
          "monthCellSelectedClass",
          "o-dpck__month__cell--selected",
          null,
          U(S, a.modelValue, d.value.multiple) || Q(S, a.modelValue, d.value.multiple) || V(
            S,
            z.value,
            d.value.multiple
          )
        ],
        [
          "monthCellFirstSelectedClass",
          "o-dpck__month__cell--first-selected",
          null,
          U(
            S,
            Array.isArray(a.modelValue) && a.modelValue[0],
            d.value.multiple
          )
        ],
        [
          "monthCellWithinSelectedClass",
          "o-dpck__month__cell--within-selected",
          null,
          Q(S, a.modelValue, d.value.multiple)
        ],
        [
          "monthCellLastSelectedClass",
          "o-dpck__month__cell--last-selected",
          null,
          U(
            S,
            Array.isArray(a.modelValue) && a.modelValue[1],
            d.value.multiple
          )
        ],
        [
          "monthCellWithinHoveredRangeClass",
          "o-dpck__month__cell--within-hovered-range",
          null,
          B.value && B.value.length === 2 && (U(S, B.value) || Q(S, B.value))
        ],
        [
          "monthCellFirstHoveredClass",
          "o-dpck__month__cell--first-hovered",
          null,
          U(
            S,
            Array.isArray(B.value) && B.value[0]
          )
        ],
        [
          "monthCellWithinHoveredClass",
          "o-dpck__month__cell--within-hovered",
          null,
          Q(S, B.value)
        ],
        [
          "monthCellLastHoveredClass",
          "o-dpck__month__cell--last-hovered",
          null,
          U(
            S,
            Array.isArray(B.value) && B.value[1]
          )
        ],
        [
          "monthCellTodayClass",
          "o-dpck__month__cell--today",
          null,
          U(S, d.value.dateCreator())
        ],
        [
          "monthCellSelectableclass",
          "o-dpck__month__cell--selectable",
          null,
          g(S) && !d.value.disabled
        ],
        [
          "monthCellUnselectableClass",
          "o-dpck__month__cell--unselectable",
          null,
          !g(S) || d.value.disabled
        ]
      );
      return [...G.value, ...w.value];
    }
    return (S, w) => (f(), P("section", {
      class: M(s(b))
    }, [
      le("div", {
        class: M(s(D))
      }, [
        le("div", {
          class: M(s(W))
        }, [
          (f(!0), P(he, null, xe(C.value, ($, N) => (f(), P(he, { key: N }, [
            !d.value.disabled && g($) ? (f(), P("div", {
              key: 0,
              ref_for: !0,
              ref: (ae) => v($, ae),
              class: M(E($)),
              role: "button",
              disabled: d.value.disabled,
              tabindex: e.focusedDate.month === $.getMonth() ? null : 0,
              onClick: ve((ae) => I($), ["prevent"]),
              onMouseenter: (ae) => j($),
              onFocus: (ae) => j($),
              onKeydown: ve((ae) => y(ae, $), ["prevent"])
            }, [
              Pe(ue(e.monthNames[$.getMonth()]) + " ", 1),
              A($).length ? (f(), P("div", Ln, [
                (f(!0), P(he, null, xe(A($), (ae, O) => (f(), P("div", {
                  key: O,
                  class: M(["event", ae.type])
                }, null, 2))), 128))
              ])) : J("", !0)
            ], 42, Hn)) : (f(), P("div", {
              key: 1,
              class: M(E($))
            }, ue(e.monthNames[$.getMonth()]), 3))
          ], 64))), 128))
        ], 2)
      ], 2)
    ], 2));
  }
}), En = ["value", "disabled"], jn = ["value"], Za = /* @__PURE__ */ ye({
  isOruga: !0,
  name: "ODatepicker",
  configField: "datepicker",
  __name: "Datepicker",
  props: /* @__PURE__ */ Ue({
    /** Override existing theme classes completely */
    override: { type: Boolean, default: void 0 },
    /** @model */
    modelValue: {
      type: [Date, Array],
      default: void 0
    },
    /** The active state of the dropdown, use v-model:active to make it two-way binding. */
    active: { type: Boolean, default: !1 },
    /**
     * Define picker mode
     * @values date, month
     */
    type: {
      type: String,
      default: "date",
      validator: (e) => ["month", "date"].indexOf(e) >= 0
    },
    /** Set custom day names, else use names based on locale */
    dayNames: {
      type: Array,
      default: () => r("datepicker.dayNames", void 0)
    },
    /** Set custom month names, else use names based on locale */
    monthNames: {
      type: Array,
      default: () => r("datepicker.monthNames", void 0)
    },
    /**
     * Size of the control input
     * @values small, medium, large
     */
    size: {
      type: String,
      default: () => r("datepicker.size")
    },
    /** Set default date to focus on */
    focusedDate: { type: Date, default: void 0 },
    /** Events to display on picker */
    events: { type: Array, default: void 0 },
    /** Event indicators for style class definiton */
    indicators: { type: String, default: "dots" },
    /** Min date to select */
    minDate: { type: Date, default: void 0 },
    /** Max date to select */
    maxDate: { type: Date, default: void 0 },
    /** Enable date range selection */
    range: { type: Boolean, default: !1 },
    /** Makes input full width when inside a grouped or addon field */
    expanded: { type: Boolean, default: !1 },
    /** Makes the input rounded */
    rounded: { type: Boolean, default: !1 },
    /** Display datepicker inline */
    inline: { type: Boolean, default: !1 },
    /** Input placeholder */
    placeholder: { type: String, default: void 0 },
    /** Same as native input readonly */
    readonly: { type: Boolean, default: !0 },
    /** Same as native, also push new item to v-model instead of replacing */
    multiple: { type: Boolean, default: !1 },
    /** Same as native disabled */
    disabled: { type: Boolean, default: !1 },
    /** Open dropdown on focus */
    openOnFocus: {
      type: Boolean,
      default: () => r("datepicker.openOnFocus", !0)
    },
    /** Close dropdown on click */
    closeOnClick: {
      type: Boolean,
      default: () => r("datepicker.closeOnClick", !0)
    },
    /** Date format locale */
    locale: {
      type: String,
      default: () => r("locale")
    },
    /** Custom function to format a date into a string */
    dateFormatter: {
      type: Function,
      default: (e, n) => r("datepicker.dateFormatter", n)(e)
    },
    /** Custom function to parse a string into a date */
    dateParser: {
      type: Function,
      default: (e, n) => r("datepicker.dateParser", n)(e)
    },
    /** Date creator function, default is `new Date()` */
    dateCreator: {
      type: Function,
      default: () => r("datepicker.dateCreator", () => /* @__PURE__ */ new Date())()
    },
    /** Define a list of dates which can be selected */
    selectableDates: {
      type: [Array, Function],
      default: () => []
    },
    /** Define a list of dates which can not be selected */
    unselectableDates: {
      type: [Array, Function],
      default: () => []
    },
    /** Define a list of weeks which can not be selected */
    unselectableDaysOfWeek: {
      type: Array,
      default: () => r("datepicker.unselectableDaysOfWeek", void 0)
    },
    /** Show nearby month days */
    nearbyMonthDays: {
      type: Boolean,
      default: () => r("datepicker.nearbyMonthDays", !0)
    },
    /** Define if nearby month days can be selected */
    nearbySelectableMonthDays: {
      type: Boolean,
      default: () => r("datepicker.nearbySelectableMonthDays", !1)
    },
    /** Show weeek numbers */
    showWeekNumber: {
      type: Boolean,
      default: () => r("datepicker.showWeekNumber", !1)
    },
    /** Define if weeek numbers are clickable */
    weekNumberClickable: {
      type: Boolean,
      default: () => r("datepicker.weekNumberClickable", !1)
    },
    /** Set the first day of a week */
    firstDayOfWeek: {
      type: Number,
      default: () => r("datepicker.firstDayOfWeek", 0)
    },
    /** Rules for the first week : 1 for the 1st January, 4 for the 4th January */
    rulesForFirstWeek: { type: Number, default: () => 4 },
    /** Define the range of years to show */
    yearsRange: {
      type: Array,
      default: () => r("datepicker.yearsRange", [-100, 10])
    },
    /** Trap dropdown on focus */
    trapFocus: {
      type: Boolean,
      default: () => r("datepicker.trapFocus", !0)
    },
    /** Position of the dropdown relative to the input */
    position: { type: String, default: void 0 },
    /** Enable dropdown mobile modal */
    mobileModal: {
      type: Boolean,
      default: () => r("datepicker.mobileModal", !0)
    },
    /** Enable mobile native input if mobile agent */
    mobileNative: {
      type: Boolean,
      default: () => r("datepicker.mobileNative", !0)
    },
    /**
     * Icon pack to use
     * @values mdi, fa, fas and any other custom icon pack
     */
    iconPack: {
      type: String,
      default: () => r("datepicker.iconPack", void 0)
    },
    /** Icon to be shown */
    icon: {
      type: String,
      default: () => r("datepicker.icon", void 0)
    },
    /** Icon to be added on the right side */
    iconRight: {
      type: String,
      default: () => r("datepicker.iconRight", void 0)
    },
    /** Make the icon right clickable */
    iconRightClickable: { type: Boolean, default: !1 },
    /** Icon name for previous icon */
    iconPrev: {
      type: String,
      default: () => r("datepicker.iconPrev", "chevron-left")
    },
    /** Icon name for next icon */
    iconNext: {
      type: String,
      default: () => r("datepicker.iconNext", "chevron-right")
    },
    /** Mobile breakpoint as max-width value */
    mobileBreakpoint: {
      type: String,
      default: () => r("datepicker.mobileBreakpoint")
    },
    /**
     * Append the component to another part of the DOM.
     * Set `true` to append the component to the body.
     * In addition, any CSS selector string or an actual DOM node can be used.
     */
    teleport: {
      type: [Boolean, String, Object],
      default: () => r("datepicker.teleport", !1)
    },
    /** Enable html 5 native validation */
    useHtml5Validation: {
      type: Boolean,
      default: () => r("useHtml5Validation", !0)
    },
    /** The message which is shown when a validation error occurs */
    validationMessage: { type: String, default: void 0 },
    /** Accessibility next button aria label */
    ariaNextLabel: {
      type: String,
      default: () => r("datepicker.ariaNextLabel", "Next Page")
    },
    /** Accessibility previous button aria label  */
    ariaPreviousLabel: {
      type: String,
      default: () => r("datepicker.ariaNextLabel", "Previous Page")
    },
    // class props (will not be displayed in the docs)
    /** Class of the root element */
    rootClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the Datepicker size */
    sizeClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the Datepicker box where you choose the date */
    boxClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the Datepicker header inside the box */
    headerClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the Datepicker buttons inside the box */
    headerButtonsClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the Datepicker buttons inside the box when a size is choosen */
    headerButtonsSizeClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the prev button inside the Datepicker box */
    prevButtonClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the next button inside the Datepicker box */
    nextButtonClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the month and year selects container inside the Datepicker box */
    listsClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the Datepicker footer */
    footerClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the Datepicker table inside the box */
    tableClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of Datepicker header with days of the week inside the table */
    tableHeadClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the cell inside the table header */
    tableHeadCellClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the table body inside the box */
    tableBodyClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the table row */
    tableRowClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the table cell */
    tableCellClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the table cell when nearby month days are hidden */
    tableCellInvisibleClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of table cell when it's selected */
    tableCellSelectedClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the first selected table cell when in range */
    tableCellFirstSelectedClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the table cells within the range when the range is selected */
    tableCellWithinSelectedClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the last selected table cell during range selection */
    tableCellLastSelectedClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the first hovered table cell during range selection */
    tableCellFirstHoveredClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the table cell when hovered during range selection */
    tableCellWithinHoveredClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the last table cell hovered during range selection */
    tableCellLastHoveredClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the table cell of the current day */
    tableCellTodayClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the table cell that is selectable */
    tableCellSelectableClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the table cell that is unselectable */
    tableCellUnselectableClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the table cell when nearby days (prev/next month) are selectable */
    tableCellNearbyClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the cell of a row when at least one event is present */
    tableCellEventsClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the events container */
    tableEventsClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the event */
    tableEventClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the event indicator when a `variant` is specified */
    tableEventVariantClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the event indicator */
    tableEventIndicatorsClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the Datepicker table inside the box when type is month */
    monthClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the table body inside the box when type is month */
    monthBodyClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the table container when type is month */
    monthTableClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the table cell when type is month */
    monthCellClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of table cell when it's selected when type is month */
    monthCellSelectedClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the first selected table cell when in range when type is month */
    monthCellFirstSelectedClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the table cells within the range when the range is selected when type is month */
    monthCellWithinSelectedClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the last selected table cell during range selection when type is month */
    monthCellLastSelectedClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the first hovered table cell during range selection when type is month */
    monthCellWithinHoveredRangeClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the table cell when hovered during range selection when type is month */
    monthCellFirstHoveredClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the table cell when hovered during range selection and cell is in range when type is month */
    monthCellWithinHoveredClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the last table cell hovered during range selection when type is month */
    monthCellLastHoveredClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the table cell of the current day when type is month */
    monthCellTodayClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the table cell that is selectable when type is month */
    monthCellSelectableClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the table cell that is unselectable when type is month */
    monthCellUnselectableClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /**Class of the events container when type is month */
    monthCellEventsClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the Datepicker when on mobile */
    mobileClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /**
     * Class configuration for the internal input component
     * @ignore
     */
    inputClasses: {
      type: Object,
      default: () => r("datepicker.inputClasses", {})
    },
    /**
     * Class configuration for the internal dropdown component
     * @ignore
     */
    dropdownClasses: {
      type: Object,
      default: () => r(
        "datepicker.dropdownClasses",
        {}
      )
    },
    /**
     * Class configuration for the internal select component
     * @ignore
     */
    selectClasses: {
      type: Object,
      default: () => r("datepicker.selectClasses", {})
    }
  }, {
    modelValue: {},
    modelModifiers: {},
    active: { type: Boolean },
    activeModifiers: {}
  }),
  emits: /* @__PURE__ */ Ue(["update:modelValue", "update:active", "range-start", "range-end", "change-month", "change-year", "focus", "blur", "invalid", "icon-click", "icon-right-click"], ["update:modelValue", "update:active"]),
  setup(e, { expose: n, emit: a }) {
    const t = e, o = a, { defaultDateFormatter: i, defaultDateParser: u } = ma(t), { isMobile: d } = ct(t.mobileBreakpoint), m = L(), c = it(e, "modelValue"), v = it(e, "active"), p = l(
      () => Array.isArray(c.value) ? t.dateFormatter([...c.value], i) : t.dateFormatter(c.value, i)
    ), C = l(() => t.type === "month");
    ce(
      () => t.modelValue,
      (O) => {
        if (c.value !== O) {
          const x = Array.isArray(O), K = x ? O.length ? O[O.length - 1] : t.dateCreator() : O || t.dateCreator();
          (!x || x && Array.isArray(c.value) && O.length > c.value.length) && (A.value = {
            day: K.getDate(),
            month: K.getMonth(),
            year: K.getFullYear()
          });
        }
      }
    ), ce(
      () => t.focusedDate,
      (O) => {
        O && (A.value = {
          day: O.getDate(),
          month: O.getMonth(),
          year: O.getFullYear()
        });
      }
    );
    const B = (Array.isArray(t.modelValue) ? t.modelValue[0] : t.modelValue) || t.focusedDate || t.dateCreator();
    !t.modelValue && t.maxDate && t.maxDate.getFullYear() < B.getFullYear() && B.setFullYear(t.maxDate.getFullYear());
    const A = L({
      day: B.getDate(),
      month: B.getMonth(),
      year: B.getFullYear()
    });
    ce(
      () => A.value.month,
      (O) => o("change-month", O)
    ), ce(
      () => A.value.year,
      (O) => o("change-year", O)
    );
    const g = l(
      () => Array.isArray(t.monthNames) ? t.monthNames : On(t.locale)
    ), y = l(() => {
      let O = 0, x = 12;
      return t.minDate && A.value.year === t.minDate.getFullYear() && (O = t.minDate.getMonth()), t.maxDate && A.value.year === t.maxDate.getFullYear() && (x = t.maxDate.getMonth()), g.value.map((K, ie) => ({
        name: K,
        index: ie,
        disabled: ie < O || ie > x
      }));
    }), I = l(() => Array.isArray(t.dayNames) ? t.dayNames : Pn(t.locale)), k = l(() => {
      let O = A.value.year + t.yearsRange[1];
      t.maxDate && t.maxDate.getFullYear() < O && (O = Math.max(
        t.maxDate.getFullYear(),
        A.value.year
      ));
      let x = A.value.year + t.yearsRange[0];
      return t.minDate && t.minDate.getFullYear() > x && (x = Math.min(
        t.minDate.getFullYear(),
        A.value.year
      )), Array.from(
        { length: O - x + 1 || 1 },
        (K, ie) => x + ie
      ).reverse();
    }), z = l(() => {
      if (!t.minDate)
        return !0;
      if (C.value)
        return A.value.year > t.minDate.getFullYear();
      const O = new Date(
        A.value.year,
        A.value.month
      ), x = new Date(
        t.minDate.getFullYear(),
        t.minDate.getMonth()
      );
      return O > x;
    });
    function R() {
      t.disabled || (C.value ? A.value.year -= 1 : A.value.month > 0 ? A.value.month -= 1 : (A.value.month = 11, A.value.year -= 1));
    }
    const H = l(() => {
      if (!t.maxDate)
        return !0;
      if (C.value)
        return A.value.year < t.maxDate.getFullYear();
      const O = new Date(
        A.value.year,
        A.value.month
      ), x = new Date(
        t.maxDate.getFullYear(),
        t.maxDate.getMonth()
      );
      return O < x;
    });
    function j() {
      t.disabled || (C.value ? A.value.year += 1 : A.value.month < 11 ? A.value.month += 1 : (A.value.month = 0, A.value.year += 1));
    }
    function U(O) {
      if (Array.isArray(O) && (O = O[0]), !O)
        return "";
      const x = new Date(O);
      if (C.value) {
        const K = x.getFullYear(), ie = x.getMonth() + 1;
        return K + "-" + ((ie < 10 ? "0" : "") + ie);
      } else {
        const K = x.getFullYear(), ie = x.getMonth() + 1, fe = x.getDate();
        return K + "-" + ((ie < 10 ? "0" : "") + ie) + "-" + ((fe < 10 ? "0" : "") + fe);
      }
    }
    function Q(O) {
      const x = t.dateParser(O, u);
      x && Array.isArray(x) && x.length === 2 && !isNaN(x[0]) && !isNaN(x[1]) ? c.value = x : c.value = null;
    }
    function V(O) {
      const x = O ? O.split("-") : [];
      if (x.length === 3) {
        const K = parseInt(x[0], 10), ie = parseInt(x[1]) - 1, fe = parseInt(x[2]);
        c.value = new Date(K, ie, fe);
      } else
        c.value = null;
    }
    const b = h(
      ["rootClass", "o-dpck"],
      [
        "sizeClass",
        "o-dpck--",
        l(() => t.size),
        l(() => !!t.size)
      ],
      ["mobileClass", "o-dpck--mobile", null, d],
      ["expandedClass", "o-dpck--expanded", null, l(() => t.expanded)]
    ), D = h(["headerClass", "o-dpck__header"]), W = h(
      ["headerButtonsClass", "o-dpck__header__buttons"],
      [
        "headerButtonsSizeClass",
        "o-dpck__header__buttons--",
        l(() => t.size),
        l(() => !!t.size)
      ]
    ), G = h([
      "prevButtonClass",
      "o-dpck__header__previous"
    ]), E = h([
      "nextButtonClass",
      "o-dpck__header__next"
    ]), S = h(["listsClass", "o-dpck__header__list"]), w = h(["footerClass", "o-dpck__footer"]), $ = h([
      "dropdownClasses.rootClass",
      "o-tpck__dropdown"
    ]), N = h(["boxClass", "o-dpck__box"]), ae = l(() => Ee(N.value));
    return n({ focus: () => {
      var O;
      return (O = m.value) == null ? void 0 : O.focus();
    } }), (O, x) => (f(), ne(Qa, {
      ref_key: "pickerRef",
      ref: m,
      active: v.value,
      "onUpdate:active": x[10] || (x[10] = (K) => v.value = K),
      "data-oruga": "datepicker",
      value: c.value,
      "picker-props": t,
      "formatted-value": p.value,
      "native-type": C.value ? "month" : "date",
      "native-value": U(c.value),
      "native-max": U(e.maxDate),
      "native-min": U(e.minDate),
      "stay-open": e.multiple,
      "dropdown-classes": s($),
      "root-classes": s(b),
      "box-class": ae.value,
      onChange: Q,
      onNativeChange: V,
      onFocus: x[11] || (x[11] = (K) => O.$emit("focus", K)),
      onBlur: x[12] || (x[12] = (K) => O.$emit("blur", K)),
      onInvalid: x[13] || (x[13] = (K) => O.$emit("invalid", K)),
      onIconClick: x[14] || (x[14] = (K) => O.$emit("icon-click", K)),
      onIconRightClick: x[15] || (x[15] = (K) => O.$emit("icon-right-click", K))
    }, qt({
      default: se(() => [
        le("header", {
          class: M(s(D))
        }, [
          _(O.$slots, "header", {}, () => [
            le("div", {
              class: M(s(W))
            }, [
              e.disabled ? J("", !0) : (f(), ne(wt, {
                key: 0,
                class: M(s(G)),
                disabled: !z.value,
                "aria-label": e.ariaPreviousLabel,
                "icon-pack": e.iconPack,
                "icon-left": e.iconPrev,
                outlined: "",
                onClick: ve(R, ["prevent"]),
                onKeydown: [
                  Ce(ve(R, ["prevent"]), ["enter"]),
                  Ce(ve(R, ["prevent"]), ["space"])
                ]
              }, null, 8, ["class", "disabled", "aria-label", "icon-pack", "icon-left", "onKeydown"])),
              e.disabled ? J("", !0) : (f(), ne(wt, {
                key: 1,
                class: M(s(E)),
                disabled: !H.value,
                "aria-label": e.ariaNextLabel,
                "icon-pack": e.iconPack,
                "icon-left": e.iconNext,
                outlined: "",
                onClick: ve(j, ["prevent"]),
                onKeydown: [
                  Ce(ve(j, ["prevent"]), ["enter"]),
                  Ce(ve(j, ["prevent"]), ["space"])
                ]
              }, null, 8, ["class", "disabled", "aria-label", "icon-pack", "icon-left", "onKeydown"])),
              le("div", {
                class: M(s(S))
              }, [
                C.value ? J("", !0) : (f(), ne(mt, be({
                  key: 0,
                  modelValue: A.value.month,
                  "onUpdate:modelValue": x[0] || (x[0] = (K) => A.value.month = K),
                  disabled: e.disabled,
                  size: e.size
                }, e.selectClasses), {
                  default: se(() => [
                    (f(!0), P(he, null, xe(y.value, (K) => (f(), P("option", {
                      key: K.name,
                      value: K.index,
                      disabled: K.disabled
                    }, ue(K.name), 9, En))), 128))
                  ]),
                  _: 1
                }, 16, ["modelValue", "disabled", "size"])),
                me(mt, be({
                  modelValue: A.value.year,
                  "onUpdate:modelValue": x[1] || (x[1] = (K) => A.value.year = K),
                  disabled: e.disabled,
                  size: e.size
                }, e.selectClasses), {
                  default: se(() => [
                    (f(!0), P(he, null, xe(k.value, (K) => (f(), P("option", {
                      key: K,
                      value: K
                    }, ue(K), 9, jn))), 128))
                  ]),
                  _: 1
                }, 16, ["modelValue", "disabled", "size"])
              ], 2)
            ], 2)
          ])
        ], 2),
        _(O.$slots, "body", {}, () => [
          C.value ? (f(), ne(Nn, {
            key: 0,
            modelValue: c.value,
            "onUpdate:modelValue": x[2] || (x[2] = (K) => c.value = K),
            "focused-date": A.value,
            "onUpdate:focusedDate": x[3] || (x[3] = (K) => A.value = K),
            "month-names": g.value,
            "picker-props": t,
            onRangeStart: x[4] || (x[4] = (K) => O.$emit("range-start", K)),
            onRangeEnd: x[5] || (x[5] = (K) => O.$emit("range-end", K))
          }, null, 8, ["modelValue", "focused-date", "month-names", "picker-props"])) : (f(), ne(zn, {
            key: 1,
            modelValue: c.value,
            "onUpdate:modelValue": x[6] || (x[6] = (K) => c.value = K),
            "focused-date": A.value,
            "onUpdate:focusedDate": x[7] || (x[7] = (K) => A.value = K),
            "day-names": I.value,
            "month-names": g.value,
            "picker-props": t,
            onRangeStart: x[8] || (x[8] = (K) => O.$emit("range-start", K)),
            onRangeEnd: x[9] || (x[9] = (K) => O.$emit("range-end", K))
          }, null, 8, ["modelValue", "focused-date", "day-names", "month-names", "picker-props"]))
        ]),
        O.$slots.footer ? (f(), P("footer", {
          key: 0,
          class: M(s(w))
        }, [
          _(O.$slots, "footer")
        ], 2)) : J("", !0)
      ]),
      _: 2
    }, [
      O.$slots.trigger ? {
        name: "trigger",
        fn: se(() => [
          _(O.$slots, "trigger")
        ]),
        key: "0"
      } : void 0
    ]), 1032, ["active", "value", "picker-props", "formatted-value", "native-type", "native-value", "native-max", "native-min", "stay-open", "dropdown-classes", "root-classes", "box-class"]));
  }
}), Wn = {
  install(e) {
    Ae(e, Za);
  }
}, Et = "AM", jt = "PM", $a = "24", Wt = "12";
function Yn(e) {
  const n = l(
    () => new Intl.DateTimeFormat(e.locale, {
      hour: "numeric",
      minute: "numeric",
      second: e.enableSeconds ? "numeric" : void 0
    }).resolvedOptions()
  ), a = l(
    () => new Intl.DateTimeFormat(e.locale, {
      hour: n.value.hour || "numeric",
      minute: n.value.minute || "numeric",
      second: e.enableSeconds ? n.value.second || "numeric" : void 0,
      hourCycle: o.value ? "h23" : "h12"
    })
  ), t = l(
    () => e.hourFormat || (n.value.hour12 ? Wt : $a)
  ), o = l(
    () => t.value === $a
  ), i = l(() => {
    const A = e.timeCreator();
    return A.setHours(10), A.setSeconds(0), A.setMinutes(0), A.setMilliseconds(0), A;
  }), u = l(() => {
    if (a.value.formatToParts && typeof a.value.formatToParts == "function") {
      const A = i.value;
      A.setHours(10);
      const g = a.value.formatToParts(A).find((y) => y.type === "dayPeriod");
      if (g)
        return g.value;
    }
    return Et;
  }), d = l(() => {
    if (a.value.formatToParts && typeof a.value.formatToParts == "function") {
      const A = i.value;
      A.setHours(20);
      const g = a.value.formatToParts(A).find((y) => y.type === "dayPeriod");
      if (g)
        return g.value;
    }
    return jt;
  }), m = l(() => [u.value, d.value]), c = l(() => {
    if (a.value.formatToParts && typeof a.value.formatToParts == "function") {
      const A = i.value, g = a.value.formatToParts(A), y = g.find(
        (I, k) => k > 0 && g[k - 1].type === "hour"
      );
      if (y)
        return y.value;
    }
    return ":";
  }), v = l(() => {
    if (a.value.formatToParts && typeof a.value.formatToParts == "function") {
      const A = i.value, g = a.value.formatToParts(A), y = g.find(
        (I, k) => k > 0 && g[k - 1].type === "minute"
      );
      if (y)
        return y.value;
    }
    return ":";
  }), p = l(() => {
    if (a.value.formatToParts && typeof a.value.formatToParts == "function") {
      const A = i.value, g = a.value.formatToParts(A), y = g.find(
        (I, k) => k > 0 && g[k - 1].type === "second"
      );
      if (y)
        return y.value;
    }
  });
  function C(A) {
    return a.value.format(A);
  }
  function B(A) {
    if (!A)
      return null;
    if (a.value.formatToParts && typeof a.value.formatToParts == "function") {
      const H = a.value.formatToParts(i.value).map((U) => U.type === "literal" ? U.value.replace(/ /g, "\\s?") : U.type === "dayPeriod" ? `((?!=<${U.type}>)(${u.value}|${d.value}|${Et}|${jt}|${Et.toLowerCase()}|${jt.toLowerCase()})?)` : `((?!=<${U.type}>)\\d+)`).join(""), j = pa(H, A);
      if (j.hour = j.hour ? parseInt(j.hour, 10) : null, j.minute = j.minute ? parseInt(j.minute, 10) : null, j.second = j.second ? parseInt(j.second, 10) : null, j.hour && j.hour >= 0 && j.hour < 24 && j.minute && j.minute >= 0 && j.minute < 59) {
        j.dayPeriod && (j.dayPeriod.toLowerCase() === d.value.toLowerCase() || j.dayPeriod.toLowerCase() === jt.toLowerCase()) && j.hour < 12 && (j.hour += 12);
        const U = i.value;
        return U.setHours(j.hour), U.setMinutes(j.minute), U.setSeconds(j.second || 0), U;
      }
    }
    let g = !1;
    if (e.hourFormat === Wt) {
      const H = A.split(" ");
      A = H[0], g = H[1] === u.value || H[1] === Et;
    }
    const y = A.split(":");
    let I = parseInt(y[0], 10);
    const k = parseInt(y[1], 10), z = e.enableSeconds ? parseInt(y[2], 10) : 0;
    if (isNaN(I) || I < 0 || I > 23 || e.hourFormat === Wt && (I < 1 || I > 12) || isNaN(k) || k < 0 || k > 59)
      return null;
    const R = i.value;
    return R.setSeconds(z), R.setMinutes(k), e.hourFormat === Wt && (g && I === 12 ? I = 0 : !g && I !== 12 && (I += 12)), R.setHours(I), new Date(R.getTime());
  }
  return {
    defaultTimeFormatter: C,
    defaultTimeParser: B,
    pmString: d,
    amString: u,
    meridiens: m,
    isHourFormat24: o,
    hourLiteral: c,
    minuteLiteral: v,
    secondLiteral: p
  };
}
const Kn = ["value", "disabled"], Un = ["value", "disabled"], qn = ["value", "disabled"], Xn = ["value", "disabled"], _a = /* @__PURE__ */ ye({
  isOruga: !0,
  name: "OTimepicker",
  configField: "timepicker",
  __name: "Timepicker",
  props: {
    /** Override existing theme classes completely */
    override: { type: Boolean, default: void 0 },
    /** @model */
    modelValue: { type: Date, default: void 0 },
    /** The active state of the dropdown */
    active: { type: Boolean, default: !1 },
    /** Min time to select */
    minTime: { type: Date, default: void 0 },
    /** Max time to select */
    maxTime: { type: Date, default: void 0 },
    /** Display datepicker inline */
    inline: { type: Boolean, default: !1 },
    /** Input placeholder */
    placeholder: { type: String, default: void 0 },
    /** Makes input full width when inside a grouped or addon field */
    expanded: { type: Boolean, default: !1 },
    /** Makes the input rounded */
    rounded: { type: Boolean, default: !1 },
    /** Same as native input readonly */
    readonly: { type: Boolean, default: !1 },
    /** Same as native disabled */
    disabled: { type: Boolean, default: !1 },
    /**
     * Size of the button
     * @values small, medium, large
     */
    size: {
      type: String,
      default: () => r("timepicker.size")
    },
    hourFormat: { type: String, default: void 0 },
    incrementHours: { type: Number, default: 1 },
    incrementMinutes: { type: Number, default: 1 },
    incrementSeconds: { type: Number, default: 1 },
    /** Open dropdown on focus */
    openOnFocus: {
      type: Boolean,
      default: () => r("timepicker.openOnFocus", !0)
    },
    /** Close dropdown on click */
    closeOnClick: {
      type: Boolean,
      default: () => r("timepicker.closeOnClick", !0)
    },
    enableSeconds: { type: Boolean, default: !1 },
    defaultMinutes: { type: Number, default: void 0 },
    defaultSeconds: { type: Number, default: void 0 },
    /** Date format locale */
    locale: {
      type: String,
      default: () => r("locale")
    },
    /** Custom function to format a date into a string */
    timeFormatter: {
      type: Function,
      default: (e, n) => r("timepicker.timeFormatter", n)(e)
    },
    /** Custom function to parse a string into a date */
    timeParser: {
      type: Function,
      default: (e, n) => r("timepicker.timeParser", n)(e)
    },
    /** time creator function, default is `new Date()` */
    timeCreator: {
      type: Function,
      default: () => r("timepicker.timeCreator", () => /* @__PURE__ */ new Date())()
    },
    /** Define a list of times which can not be selected */
    unselectableTimes: {
      type: [Array, Function],
      default: () => []
    },
    /** Reset the time inputs when meridian changes */
    resetOnMeridianChange: {
      type: Boolean,
      default: !1
    },
    /** Dropdown trapFocus */
    trapFocus: {
      type: Boolean,
      default: () => r("timepicker.trapFocus", !0)
    },
    /** Dropdown position */
    position: { type: String, default: void 0 },
    /** Enable dropdown mobile modal */
    mobileModal: {
      type: Boolean,
      default: () => r("timepicker.mobileModal", !0)
    },
    /** Enable mobile native input if mobile agent */
    mobileNative: {
      type: Boolean,
      default: () => r("timepicker.mobileNative", !0)
    },
    /**
     * Icon pack to use
     * @values mdi, fa, fas and any other custom icon pack
     */
    iconPack: {
      type: String,
      default: () => r("timepicker.iconPack", void 0)
    },
    /** Icon to be shown */
    icon: {
      type: String,
      default: () => r("timepicker.icon", void 0)
    },
    /** Icon to be added on the right side */
    iconRight: {
      type: String,
      default: () => r("timepicker.iconRight", void 0)
    },
    /** Make the icon right clickable */
    iconRightClickable: { type: Boolean, default: !1 },
    /** Mobile breakpoint as max-width value */
    mobileBreakpoint: {
      type: String,
      default: () => r("timepicker.mobileBreakpoint")
    },
    /**
     * Append the component to another part of the DOM.
     * Set `true` to append the component to the body.
     * In addition, any CSS selector string or an actual DOM node can be used.
     */
    teleport: {
      type: [Boolean, String, Object],
      default: () => r("timepicker.teleport", !1)
    },
    /** Enable html 5 native validation */
    useHtml5Validation: {
      type: Boolean,
      default: () => r("useHtml5Validation", !0)
    },
    /** The message which is shown when a validation error occurs */
    validationMessage: { type: String, default: void 0 },
    // class props (will not be displayed in the docs)
    /** Class of the root element */
    rootClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the Timepicker component size */
    sizeClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the Timepicker component box where you choose the date */
    boxClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the Timepicker separator */
    separatorClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the Timepicker footer */
    footerClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /**
     * Class configuration for the internal input component
     * @ignore
     */
    inputClasses: {
      type: Object,
      default: () => r("timepicker.inputClasses", {})
    },
    /**
     * Class configuration for the internal dropdown component
     * @ignore
     */
    dropdownClasses: {
      type: Object,
      default: () => r("timepicker.dropdownClasses", {})
    },
    /**
     * Class configuration for the internal select component
     * @ignore
     */
    selectClasses: {
      type: Object,
      default: () => r("timepicker.selectClasses", {})
    }
  },
  emits: ["update:modelValue", "update:active", "focus", "blur", "invalid", "icon-click", "icon-right-click"],
  setup(e, { expose: n, emit: a }) {
    const t = e, o = a, { isMobile: i } = ct(t.mobileBreakpoint), {
      defaultTimeFormatter: u,
      defaultTimeParser: d,
      pmString: m,
      amString: c,
      meridiens: v,
      isHourFormat24: p,
      hourLiteral: C,
      minuteLiteral: B,
      secondLiteral: A
    } = Yn(t), g = L(), y = dt(t, o), I = qe("active", t, o), k = L(), z = L(), R = L(), H = L();
    ce(
      () => t.modelValue,
      (ee) => {
        ee ? (k.value = ee.getHours(), z.value = ee.getMinutes(), R.value = ee.getSeconds(), H.value = ee.getHours() >= 12 ? m.value : c.value) : (k.value = null, z.value = null, R.value = null, H.value = c.value);
      },
      { immediate: !0 }
    );
    const j = l(
      () => t.timeFormatter(t.modelValue, u)
    ), U = l(() => t.enableSeconds ? "1" : null);
    ce(
      () => t.hourFormat,
      () => {
        k.value !== null && (H.value = k.value >= 12 ? m.value : c.value);
      }
    ), ce(
      () => t.locale,
      (ee) => {
        ee || (H.value = c.value);
      }
    );
    function Q(ee, Z) {
      return p.value || Z ? V(ee) : String(ee);
    }
    function V(ee) {
      return (ee < 10 ? "0" : "") + ee;
    }
    const b = l(() => {
      if (!t.incrementHours || t.incrementHours < 1)
        throw new Error("Hour increment cannot be null or less than 1.");
      const ee = [], Z = p.value ? 24 : 12;
      for (let T = 0; T < Z; T += t.incrementHours) {
        let de = T, ke = de;
        p.value || (de = T + 1, ke = de, H.value === c.value ? de === 12 && (de = 0) : H.value === m.value && de !== 12 && (de += 12)), ee.push({
          label: Q(ke, !1),
          value: de
        });
      }
      return ee;
    }), D = l(() => {
      if (!t.incrementMinutes || t.incrementMinutes < 1)
        throw new Error("Minute increment cannot be null or less than 1.");
      const ee = [];
      for (let Z = 0; Z < 60; Z += t.incrementMinutes)
        ee.push({
          label: Q(Z, !0),
          value: Z
        });
      return ee;
    }), W = l(() => {
      if (!t.incrementSeconds || t.incrementSeconds < 1)
        throw new Error("Second increment cannot be null or less than 1.");
      const ee = [];
      for (let Z = 0; Z < 60; Z += t.incrementSeconds)
        ee.push({
          label: Q(Z, !0),
          value: Z
        });
      return ee;
    });
    function G(ee) {
      let Z = !1;
      if (t.minTime) {
        const T = t.minTime.getHours(), de = D.value.every((ke) => E(ee, ke.value));
        Z = ee < T || de;
      }
      if (t.maxTime && !Z) {
        const T = t.maxTime.getHours();
        Z = ee > T;
      }
      if (t.unselectableTimes && !Z)
        if (typeof t.unselectableTimes == "function") {
          const T = /* @__PURE__ */ new Date();
          return T.setHours(ee), T.setMinutes(z.value), T.setSeconds(R.value), t.unselectableTimes(T);
        } else
          t.unselectableTimes.filter((de) => t.enableSeconds && R.value !== null ? de.getHours() === ee && de.getMinutes() === z.value && de.getSeconds() === R.value : z.value !== null ? de.getHours() === ee && de.getMinutes() === z.value : !1).length > 0 ? Z = !0 : Z = D.value.every((de) => t.unselectableTimes.filter(
            (ke) => ke.getHours() === ee && ke.getMinutes() === de.value
          ).length > 0);
      return Z;
    }
    function E(ee, Z) {
      let T = !1;
      if (t.minTime) {
        const de = t.minTime.getHours(), ke = t.minTime.getMinutes();
        T = ee === de && Z < ke;
      }
      if (t.maxTime && !T) {
        const de = t.maxTime.getHours(), ke = t.maxTime.getMinutes();
        T = ee === de && Z > ke;
      }
      return T;
    }
    function S(ee) {
      if (k.value === null)
        return !1;
      let Z = !1;
      if (G(k.value) ? Z = !0 : Z = E(k.value, ee), t.unselectableTimes && !Z)
        if (typeof t.unselectableTimes == "function") {
          const T = /* @__PURE__ */ new Date();
          return T.setHours(k.value), T.setMinutes(ee), T.setSeconds(R.value), t.unselectableTimes(T);
        } else
          Z = t.unselectableTimes.filter((de) => t.enableSeconds && R.value !== null ? de.getHours() === k.value && de.getMinutes() === ee && de.getSeconds() === R.value : de.getHours() === k.value && de.getMinutes() === ee).length > 0;
    }
    function w(ee) {
      if (z.value == null)
        return !1;
      let Z = !1;
      if (S(z.value))
        Z = !0;
      else {
        if (t.minTime) {
          const T = t.minTime.getHours(), de = t.minTime.getMinutes(), ke = t.minTime.getSeconds();
          Z = k.value === T && z.value === de && ee < ke;
        }
        if (t.maxTime && !Z) {
          const T = t.maxTime.getHours(), de = t.maxTime.getMinutes(), ke = t.maxTime.getSeconds();
          Z = k.value === T && z.value === de && ee > ke;
        }
      }
      if (t.unselectableTimes && !Z)
        if (typeof t.unselectableTimes == "function") {
          const T = /* @__PURE__ */ new Date();
          return T.setHours(k.value), T.setMinutes(z.value), T.setSeconds(ee), t.unselectableTimes(T);
        } else
          Z = t.unselectableTimes.filter((de) => de.getHours() === k.value && de.getMinutes() === z.value && de.getSeconds() === ee).length > 0;
    }
    function $(ee) {
      const Z = ee == "AM" ? 0 : 12;
      for (let T = 0; T < 12; T++)
        if (!G(T + Z))
          return !1;
      return !0;
    }
    function N(ee, Z, T, de) {
      if (ee != null && Z != null && (!p.value && de !== null || p.value)) {
        let ke = null;
        y.value ? ke = new Date(y.value) : (ke = t.timeCreator(), ke.setMilliseconds(0)), ke.setHours(ee), ke.setMinutes(Z), ke.setSeconds(T), isNaN(ke.getTime()) || (y.value = new Date(ke.getTime()));
      }
    }
    function ae(ee) {
      const Z = new Date(ee);
      if (ee && !isNaN(Z.getTime())) {
        const T = Z.getHours(), de = Z.getMinutes(), ke = Z.getSeconds();
        return Q(T, !0) + ":" + Q(de, !0) + ":" + Q(ke, !0);
      }
      return "";
    }
    function O(ee) {
      k.value !== null && t.resetOnMeridianChange ? (k.value = null, z.value = null, R.value = null, y.value = null) : k.value !== null && (ee === m.value ? k.value += 12 : ee === c.value && (k.value -= 12)), N(
        k.value,
        z.value,
        t.enableSeconds ? R.value : 0,
        ee
      );
    }
    function x(ee) {
      !z.value && typeof t.defaultMinutes < "u" && (z.value = t.defaultMinutes), !R.value && typeof t.defaultSeconds < "u" && (R.value = t.defaultSeconds), N(
        parseInt(ee, 10),
        z.value,
        t.enableSeconds ? R.value : 0,
        H.value
      );
    }
    function K(ee) {
      !R.value && t.defaultSeconds && (R.value = t.defaultSeconds), N(
        k.value,
        parseInt(ee, 10),
        t.enableSeconds ? R.value : 0,
        H.value
      );
    }
    function ie(ee) {
      N(
        k.value,
        z.value,
        parseInt(ee, 10),
        H.value
      );
    }
    function fe(ee) {
      const Z = t.timeParser(ee, d);
      y.value = Z || null;
    }
    function He(ee) {
      if (ee) {
        let Z = null;
        y.value ? Z = new Date(y.value) : (Z = t.timeCreator(), Z.setMilliseconds(0));
        const T = ee.split(":");
        Z.setHours(parseInt(T[0], 10)), Z.setMinutes(parseInt(T[1], 10)), Z.setSeconds(T[2] ? parseInt(T[2], 10) : 0), y.value = new Date(Z.getTime());
      } else
        y.value = null;
    }
    const Ve = h([
      "selectClasses.selectClass",
      "o-tpck__select"
    ]), Se = h([
      "selectClasses.placeholderClass",
      "o-tpck__select-placeholder"
    ]), Te = l(() => ({
      "select-class": Ee(Ve.value),
      "placeholder-class": Ee(Se.value),
      ...t.selectClasses
    })), tt = h(
      ["rootClass", "o-tpck"],
      [
        "sizeClass",
        "o-tpck--",
        l(() => t.size),
        l(() => !!t.size)
      ],
      ["mobileClass", "o-tpck--mobile", null, i]
    ), Je = h(["separatorClass", "o-tpck__separtor"]), lt = h(["footerClass", "o-tpck__footer"]), Qe = h([
      "dropdownClasses.rootClass",
      "o-tpck__dropdown"
    ]), nt = h(["boxClass", "o-tpck__box"]), ft = l(() => Ee(nt.value));
    return n({ focus: () => {
      var ee;
      return (ee = g.value) == null ? void 0 : ee.focus();
    } }), (ee, Z) => (f(), ne(Qa, {
      ref_key: "pickerRef",
      ref: g,
      active: s(I),
      "onUpdate:active": Z[8] || (Z[8] = (T) => Ke(I) ? I.value = T : null),
      "data-oruga": "timepicker",
      value: s(y),
      "picker-props": t,
      "formatted-value": j.value,
      "native-type": "time",
      "native-value": ae(s(y)),
      "native-max": ae(e.maxTime),
      "native-min": ae(e.minTime),
      "native-step": U.value,
      "dropdown-classes": s(Qe),
      "root-classes": s(tt),
      "box-class": ft.value,
      onChange: fe,
      onNativeChange: He,
      onFocus: Z[9] || (Z[9] = (T) => ee.$emit("focus", T)),
      onBlur: Z[10] || (Z[10] = (T) => ee.$emit("blur", T)),
      onInvalid: Z[11] || (Z[11] = (T) => ee.$emit("invalid", T)),
      onIconClick: Z[12] || (Z[12] = (T) => ee.$emit("icon-click", T)),
      onIconRightClick: Z[13] || (Z[13] = (T) => ee.$emit("icon-right-click", T))
    }, qt({
      default: se(() => [
        me(mt, be(Te.value, {
          modelValue: k.value,
          "onUpdate:modelValue": Z[0] || (Z[0] = (T) => k.value = T),
          override: "",
          disabled: e.disabled,
          placeholder: "00",
          onChange: Z[1] || (Z[1] = (T) => x(T.target.value))
        }), {
          default: se(() => [
            (f(!0), P(he, null, xe(b.value, (T) => (f(), P("option", {
              key: T.value,
              value: T.value,
              disabled: G(T.value)
            }, ue(T.label), 9, Kn))), 128))
          ]),
          _: 1
        }, 16, ["modelValue", "disabled"]),
        le("span", {
          class: M(s(Je))
        }, ue(s(C)), 3),
        me(mt, be(Te.value, {
          modelValue: z.value,
          "onUpdate:modelValue": Z[2] || (Z[2] = (T) => z.value = T),
          override: "",
          disabled: e.disabled,
          placeholder: "00",
          onChange: Z[3] || (Z[3] = (T) => K(T.target.value))
        }), {
          default: se(() => [
            (f(!0), P(he, null, xe(D.value, (T) => (f(), P("option", {
              key: T.value,
              value: T.value,
              disabled: S(T.value)
            }, ue(T.label), 9, Un))), 128))
          ]),
          _: 1
        }, 16, ["modelValue", "disabled"]),
        e.enableSeconds ? (f(), P(he, { key: 0 }, [
          le("span", {
            class: M(s(Je))
          }, ue(s(B)), 3),
          me(mt, be(Te.value, {
            modelValue: R.value,
            "onUpdate:modelValue": Z[4] || (Z[4] = (T) => R.value = T),
            override: "",
            disabled: e.disabled,
            placeholder: "00",
            onChange: Z[5] || (Z[5] = (T) => ie(T.target.value))
          }), {
            default: se(() => [
              (f(!0), P(he, null, xe(W.value, (T) => (f(), P("option", {
                key: T.value,
                value: T.value,
                disabled: w(T.value)
              }, ue(T.label), 9, qn))), 128))
            ]),
            _: 1
          }, 16, ["modelValue", "disabled"]),
          le("span", {
            class: M(s(Je))
          }, ue(s(A)), 3)
        ], 64)) : J("", !0),
        s(p) ? J("", !0) : (f(), ne(mt, be({ key: 1 }, Te.value, {
          modelValue: H.value,
          "onUpdate:modelValue": Z[6] || (Z[6] = (T) => H.value = T),
          override: "",
          disabled: e.disabled,
          onChange: Z[7] || (Z[7] = (T) => O(T.target.value))
        }), {
          default: se(() => [
            (f(!0), P(he, null, xe(s(v), (T) => (f(), P("option", {
              key: T,
              value: T,
              disabled: $(T)
            }, ue(T), 9, Xn))), 128))
          ]),
          _: 1
        }, 16, ["modelValue", "disabled"])),
        ee.$slots.default ? (f(), P("footer", {
          key: 2,
          class: M(s(lt))
        }, [
          _(ee.$slots, "default")
        ], 2)) : J("", !0)
      ]),
      _: 2
    }, [
      ee.$slots.trigger ? {
        name: "trigger",
        fn: se(() => [
          _(ee.$slots, "trigger")
        ]),
        key: "0"
      } : void 0
    ]), 1032, ["active", "value", "picker-props", "formatted-value", "native-value", "native-max", "native-min", "native-step", "dropdown-classes", "root-classes", "box-class"]));
  }
}), aa = "AM", la = "PM", Gn = "24", Jn = /* @__PURE__ */ ye({
  isOruga: !0,
  name: "ODatetimepicker",
  configField: "datetimepicker",
  inheritAttrs: !1,
  __name: "Datetimepicker",
  props: /* @__PURE__ */ Ue({
    /** Override existing theme classes completely */
    override: { type: Boolean, default: void 0 },
    /** @model */
    modelValue: { type: Date, default: void 0 },
    /** The active state of the dropdown, use v-model:active to make it two-way binding. */
    active: { type: Boolean, default: !1 },
    /** Define props for the underlying datepicker component */
    datepicker: {
      type: Object,
      default: void 0
    },
    /** Define props for the underlying timepicker component */
    timepicker: {
      type: Object,
      default: void 0
    },
    /** Min date to select */
    minDatetime: { type: Date, default: void 0 },
    /** Max date to select */
    maxDatetime: { type: Date, default: void 0 },
    /**
     * Size of the input control
     * @values small, medium, large
     */
    size: {
      type: String,
      default: () => r("datetimepicker.size")
    },
    expanded: { type: Boolean, default: !1 },
    /** Makes the input rounded */
    rounded: { type: Boolean, default: !1 },
    /** Input placeholder */
    placeholder: { type: String, default: void 0 },
    /** Same as native input readonly */
    readonly: { type: Boolean, default: !1 },
    /** Same as native disabled */
    disabled: { type: Boolean, default: !1 },
    /** Display datetimepicker inline */
    inline: { type: Boolean, default: !1 },
    /** Open dropdown on focus */
    openOnFocus: {
      type: Boolean,
      default: () => r("datetimepicker.openOnFocus", !0)
    },
    /** Date format locale */
    locale: {
      type: String,
      default: () => r("locale")
    },
    /** Custom function to format a date into a string */
    datetimeFormatter: {
      type: Function,
      default: (e, n) => r("datetimepicker.dateFormatter", n)(e)
    },
    /** Custom function to parse a string into a date */
    datetimeParser: {
      type: Function,
      default: (e, n) => r("datetimepicker.dateParser", n)(e)
    },
    /** Date creator function, default is `new Date()` */
    datetimeCreator: {
      type: Function,
      default: (e) => r(
        "datetimepicker.datetimeCreator",
        (n) => new Date(n)
      )(e)
    },
    /** Dropdown position */
    position: { type: String, default: void 0 },
    /** Enable mobile native input if mobile agent */
    mobileNative: {
      type: Boolean,
      default: () => r("datetimepicker.mobileNative", !0)
    },
    /**
     * Icon pack to use
     * @values mdi, fa, fas and any other custom icon pack
     */
    iconPack: {
      type: String,
      default: () => r("datetimepicker.iconPack", void 0)
    },
    /** Icon to be shown */
    icon: {
      type: String,
      default: () => r("datetimepicker.icon", void 0)
    },
    /** Icon to be added on the right side */
    iconRight: {
      type: String,
      default: () => r("datetimepicker.iconRight", void 0)
    },
    /** Make the icon right clickable */
    iconRightClickable: { type: Boolean, default: !1 },
    /**
     * Append the component to another part of the DOM.
     * Set `true` to append the component to the body.
     * In addition, any CSS selector string or an actual DOM node can be used.
     */
    teleport: {
      type: [Boolean, String, Object],
      default: () => r("datetimepicker.teleport", !1)
    },
    /** Enable html 5 native validation */
    useHtml5Validation: {
      type: Boolean,
      default: () => r("useHtml5Validation", !0)
    },
    /** The message which is shown when a validation error occurs */
    validationMessage: { type: String, default: void 0 },
    // class props (will not be displayed in the docs)
    /** Class of the Datepicker wrapper */
    datepickerWrapperClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the Timepicker wrapper */
    timepickerWrapperClass: {
      type: [String, Array, Function],
      default: void 0
    }
  }, {
    active: { type: Boolean },
    activeModifiers: {},
    modelValue: {},
    modelModifiers: {}
  }),
  emits: /* @__PURE__ */ Ue(["update:modelValue", "update:active", "range-start", "range-end", "change-month", "change-year", "focus", "blur", "invalid", "icon-click", "icon-right-click"], ["update:active", "update:modelValue"]),
  setup(e, { expose: n, emit: a }) {
    const t = e, o = a, i = L(), u = L(), d = L(), m = l(
      () => B.value ? d.value : i.value
    ), { setFocus: c, onBlur: v, onFocus: p, onInvalid: C } = rt(
      m,
      o,
      t
    ), B = l(
      () => t.mobileNative && vt.any()
    );
    ce([() => B.value, () => t.inline], () => {
      i.value && i.value.$forceUpdate();
    });
    const A = it(e, "active"), g = it(e, "modelValue");
    function y(O) {
      if (!O) {
        g.value = void 0;
        return;
      }
      if (Array.isArray(O)) {
        y(O[0]);
        return;
      }
      let x = new Date(O.getTime());
      t.modelValue ? (O.getDate() !== t.modelValue.getDate() || O.getMonth() !== t.modelValue.getMonth() || O.getFullYear() !== t.modelValue.getFullYear()) && O.getHours() === 0 && O.getMinutes() === 0 && O.getSeconds() === 0 && x.setHours(
        t.modelValue.getHours(),
        t.modelValue.getMinutes(),
        t.modelValue.getSeconds(),
        0
      ) : x = t.datetimeCreator(O), t.minDatetime && x < t.minDatetime ? x = t.minDatetime : t.maxDatetime && x > t.maxDatetime && (x = t.maxDatetime), g.value = new Date(x.getTime());
    }
    const I = l(() => t.minDatetime ? new Date(
      t.minDatetime.getFullYear(),
      t.minDatetime.getMonth(),
      t.minDatetime.getDate(),
      0,
      0,
      0,
      0
    ) : t.datepicker ? t.datepicker.minDate : null), k = l(() => t.maxDatetime ? new Date(
      t.maxDatetime.getFullYear(),
      t.maxDatetime.getMonth(),
      t.maxDatetime.getDate(),
      0,
      0,
      0,
      0
    ) : t.datepicker ? t.datepicker.maxDate : null), z = l(() => !t.minDatetime || g.value === null || typeof g.value > "u" || g.value.getFullYear() != t.minDatetime.getFullYear() || g.value.getMonth() != t.minDatetime.getMonth() || g.value.getDate() != t.minDatetime.getDate() ? t.timepicker ? t.timepicker.minTime : null : t.minDatetime), R = l(() => !t.maxDatetime || g.value === null || typeof g.value > "u" || g.value.getFullYear() != t.maxDatetime.getFullYear() || g.value.getMonth() != t.maxDatetime.getMonth() || g.value.getDate() != t.maxDatetime.getDate() ? t.timepicker ? t.timepicker.maxTime : null : t.maxDatetime), H = l(
      () => {
        var O;
        return (O = t.datepicker) != null && O.size ? t.datepicker.size : t.size;
      }
    ), j = l(
      () => {
        var O;
        return (O = t.timepicker) != null && O.size ? t.timepicker.size : t.size;
      }
    ), U = l(
      () => {
        var O;
        return (O = t.timepicker) != null && O.disabled ? t.timepicker.disabled : t.disabled;
      }
    );
    function Q(O) {
      const x = new Date(O);
      if (O && !isNaN(x.getTime())) {
        const K = x.getFullYear(), ie = x.getMonth() + 1, fe = x.getDate(), He = x.getHours(), Ve = x.getMinutes(), Se = x.getSeconds();
        return K + "-" + ((ie < 10 ? "0" : "") + ie) + "-" + ((fe < 10 ? "0" : "") + fe) + "T" + ((He < 10 ? "0" : "") + He) + ":" + ((Ve < 10 ? "0" : "") + Ve) + ":" + ((Se < 10 ? "0" : "") + Se);
      }
      return "";
    }
    const V = l(
      () => {
        var O;
        return (O = u.value) != null && O.enableSeconds ? u.value.enableSeconds : !1;
      }
    ), b = l(
      () => new Intl.DateTimeFormat(t.locale, {
        year: "numeric",
        month: "numeric",
        day: "numeric",
        hour: "numeric",
        minute: "numeric",
        second: V.value ? "numeric" : void 0
      }).resolvedOptions()
    ), D = l(
      () => {
        var O;
        return ((O = t.timepicker) == null ? void 0 : O.hourFormat) === Gn || !b.value.hour12;
      }
    ), W = l(
      () => new Intl.DateTimeFormat(t.locale, {
        year: b.value.year || "numeric",
        month: b.value.month || "numeric",
        day: b.value.day || "numeric",
        hour: b.value.hour || "numeric",
        minute: b.value.minute || "numeric",
        second: V.value ? b.value.second || "numeric" : void 0,
        hourCycle: D.value ? "h23" : "h12"
      })
    ), G = l(() => {
      if (W.value.formatToParts && typeof W.value.formatToParts == "function") {
        const O = t.datetimeCreator(/* @__PURE__ */ new Date());
        O.setHours(10);
        const x = W.value.formatToParts(O).find((K) => K.type === "dayPeriod");
        if (x)
          return x.value;
      }
      return aa;
    }), E = l(() => {
      if (W.value.formatToParts && typeof W.value.formatToParts == "function") {
        const O = t.datetimeCreator(/* @__PURE__ */ new Date());
        O.setHours(20);
        const x = W.value.formatToParts(O).find((K) => K.type === "dayPeriod");
        if (x)
          return x.value;
      }
      return la;
    });
    function S(O) {
      function x(ie) {
        if (W.value.formatToParts && typeof W.value.formatToParts == "function") {
          const fe = [aa, la, aa.toLowerCase(), la.toLowerCase()];
          u.value && (fe.push(G.value), fe.push(E.value));
          const He = this.dtf.formatToParts(/* @__PURE__ */ new Date()), Ve = He.map((Te, tt) => Te.type === "literal" ? tt + 1 < He.length && He[tt + 1].type === "hour" ? "[^\\d]+" : Te.value.replace(/ /g, "\\s?") : Te.type === "dayPeriod" ? `((?!=<${Te.type}>)(${fe.join(
            "|"
          )})?)` : `((?!=<${Te.type}>)\\d+)`).join(""), Se = pa(Ve, ie);
          if (Se.year && Se.year.length === 4 && Se.month && Se.month <= 12 && Se.day && Se.day <= 31 && Se.hour && Se.hour >= 0 && Se.hour < 24 && Se.minute && Se.minute >= 0 && Se.minute <= 59)
            return new Date(
              Se.year,
              Se.month - 1,
              Se.day,
              Se.hour,
              Se.minute,
              Se.second || 0
            );
        }
        return new Date(Date.parse(ie));
      }
      return t.datetimeParser(O, x);
    }
    function w(O) {
      return t.datetimeFormatter(
        O,
        (x) => x ? W.value.format(x) : ""
      );
    }
    function $(O) {
      const x = O.target.value, K = x ? x.split(/\D/) : [];
      if (K.length >= 5) {
        const ie = parseInt(K[0], 10), fe = parseInt(K[1], 10) - 1, He = parseInt(K[2], 10), Ve = parseInt(K[3], 10), Se = parseInt(K[4], 10);
        y(new Date(ie, fe, He, Ve, Se));
      } else
        y(null);
    }
    const N = h([
      "datepickerWrapperClass",
      "o-dtpck__date"
    ]), ae = h([
      "timepickerWrapperClass",
      "o-dtpck__time"
    ]);
    return n({ focus: c }), (O, x) => !B.value || e.inline ? (f(), ne(Za, be({
      key: 0,
      ref_key: "datepickerRef",
      ref: i
    }, { ...O.$attrs, ...e.datepicker }, {
      active: A.value,
      "onUpdate:active": x[1] || (x[1] = (K) => A.value = K),
      "model-value": g.value,
      "data-oruga": "datetimepicker",
      class: s(N),
      rounded: e.rounded,
      "open-on-focus": e.openOnFocus,
      position: e.position,
      inline: e.inline,
      readonly: e.readonly,
      expanded: e.expanded,
      "close-on-click": !1,
      "date-formatter": w,
      "date-parser": S,
      "min-date": I.value,
      "max-date": k.value,
      icon: e.icon,
      "icon-right": e.iconRight,
      "icon-right-clickable": e.iconRightClickable,
      "icon-pack": e.iconPack,
      size: H.value,
      placeholder: e.placeholder,
      range: !1,
      disabled: e.disabled,
      "mobile-native": B.value,
      locale: e.locale,
      teleport: e.teleport,
      "onUpdate:modelValue": y,
      onFocus: s(p),
      onBlur: s(v),
      onChangeMonth: x[2] || (x[2] = (K) => O.$emit("change-month", K)),
      onChangeYear: x[3] || (x[3] = (K) => O.$emit("change-year", K)),
      onIconClick: x[4] || (x[4] = (K) => O.$emit("icon-click", K)),
      onIconRightClick: x[5] || (x[5] = (K) => O.$emit("icon-right-click", K))
    }), {
      footer: se(() => [
        le("div", {
          class: M(s(ae))
        }, [
          me(_a, be({
            ref_key: "timepickerRef",
            ref: u
          }, e.timepicker, {
            modelValue: g.value,
            "onUpdate:modelValue": x[0] || (x[0] = (K) => g.value = K),
            inline: "",
            readonly: e.readonly,
            "min-time": z.value,
            "max-time": R.value,
            size: j.value,
            disabled: U.value,
            "mobile-native": B.value,
            locale: e.locale
          }), null, 16, ["modelValue", "readonly", "min-time", "max-time", "size", "disabled", "mobile-native", "locale"])
        ], 2),
        O.$slots.footer !== void 0 ? _(O.$slots, "footer", { key: 0 }) : J("", !0)
      ]),
      _: 3
    }, 16, ["active", "model-value", "class", "rounded", "open-on-focus", "position", "inline", "readonly", "expanded", "min-date", "max-date", "icon", "icon-right", "icon-right-clickable", "icon-pack", "size", "placeholder", "disabled", "mobile-native", "locale", "teleport", "onFocus", "onBlur"])) : (f(), ne(At, be({ key: 1 }, O.$attrs, {
      ref_key: "nativeInputRef",
      ref: d,
      type: "datetime-local",
      autocomplete: "off",
      value: Q(g.value),
      max: Q(k.value),
      min: Q(I.value),
      placeholder: e.placeholder,
      size: H.value,
      "icon-pack": e.iconPack,
      icon: e.icon,
      rounded: e.rounded,
      disabled: e.disabled,
      readonly: !1,
      "use-html5-validation": !1,
      onChange: $,
      onFocus: s(p),
      onBlur: s(v),
      onInvalid: s(C)
    }), null, 16, ["value", "max", "min", "placeholder", "size", "icon-pack", "icon", "rounded", "disabled", "onFocus", "onBlur", "onInvalid"]));
  }
}), Qn = {
  install(e) {
    Ae(e, Jn);
  }
}, Zn = {
  install(e) {
    Ae(e, va), Ae(e, ht);
  }
}, _n = {
  install(e) {
    Ae(e, Ka);
  }
}, eo = {
  install(e) {
    Ae(e, Re);
  }
}, to = {
  install(e) {
    Ae(e, At);
  }
}, ya = /* @__PURE__ */ ye({
  isOruga: !0,
  name: "OLoading",
  configField: "loading",
  inheritAttrs: !1,
  __name: "Loading",
  props: {
    /** Override existing theme classes completely */
    override: { type: Boolean, default: void 0 },
    /** Whether loading is active or not, use v-model:active to make it two-way binding. */
    active: { type: Boolean, default: !1 },
    /** Loader will overlay the full page. */
    fullPage: { type: Boolean, default: !0 },
    /** Notification label, unnecessary when default slot is used. */
    label: { type: String, default: void 0 },
    /** Custom animation (transition name) */
    animation: {
      type: String,
      default: () => r("loading.animation", "fade")
    },
    /** Is Loading cancable by pressing escape or clicking outside. */
    cancelable: { type: Boolean, default: !1 },
    /** Callback function to call after user canceled (pressed escape / clicked outside). */
    onCancel: { type: Function, default: () => {
    } },
    /** Callback function to call after close (programmatically close or user canceled). */
    onClose: { type: Function, default: () => {
    } },
    /** Icon name to show, unnecessary when default slot is used. */
    icon: {
      type: String,
      default: () => r("loading.icon", "loading")
    },
    /** Enable spin effect on icon */
    iconSpin: {
      type: Boolean,
      default: () => r("loading.iconSpin", !0)
    },
    /**
     * Icon size
     * @values small, medium, large
     */
    iconSize: {
      type: String,
      default: () => r("loading.iconSize", "medium")
    },
    /**
     * DOM element where the loading component will be created on (for programmatic usage).
     * Note that this also changes fullPage to false.
     */
    container: {
      type: [Object, String],
      default: () => r("loading.container", "body")
    },
    /**
     * This is used internally for programmatic usage
     * @ignore
     */
    programmatic: {
      type: Object,
      default: void 0
    },
    /**
     * This is used internally for programmatic usage.
     * @ignore
     */
    promise: { type: Promise, default: void 0 },
    // class props (will not be displayed in the docs)
    /** Class of the root element */
    rootClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class for the root element when fullpage */
    fullPageClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the loading overlay */
    overlayClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class for the loading icon */
    iconClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class for the loading label */
    labelClass: {
      type: [String, Array, Function],
      default: void 0
    }
  },
  emits: ["update:active", "update:fullPage", "close"],
  setup(e, { expose: n, emit: a }) {
    const t = e, o = a, i = L(), u = qe("fullPage", t, o), { isActive: d, close: m, cancel: c } = Jt(
      i,
      t,
      o,
      {
        cancelOptions: ["escape", "outside"]
      }
    );
    st(() => {
      t.programmatic && t.container && (u.value = !1);
    });
    const v = h(
      ["rootClass", "o-load"],
      ["fullPageClass", "o-load--fullpage", null, u]
    ), p = h(["overlayClass", "o-load__overlay"]), C = h(["iconClass", "o-load__icon"]), B = h(["labelClass", "o-load__label"]);
    return n({ close: m, promise: t.promise }), (A, g) => (f(), ne(et, { name: e.animation }, {
      default: se(() => [
        s(d) ? (f(), P("div", {
          key: 0,
          ref_key: "rootRef",
          ref: i,
          "data-oruga": "loading",
          role: "dialog",
          class: M(s(v))
        }, [
          le("div", {
            class: M(s(p)),
            tabindex: -1,
            "aria-hidden": "true",
            onClick: g[0] || (g[0] = (y) => s(c)("outside"))
          }, null, 2),
          _(A.$slots, "default", { close: s(m) }, () => [
            me(Re, {
              icon: e.icon,
              spin: e.iconSpin,
              size: e.iconSize,
              class: M(s(C)),
              both: ""
            }, null, 8, ["icon", "spin", "size", "class"]),
            e.label ? (f(), P("span", {
              key: 0,
              class: M(s(B))
            }, ue(e.label), 3)) : J("", !0)
          ])
        ], 2)) : J("", !0)
      ]),
      _: 3
    }, 8, ["name"]));
  }
});
class Qt {
  constructor() {
    Sa(this, "entries");
    this.entries = [];
  }
  add(n) {
    this.entries.push(n);
  }
  remove(n) {
    const a = this.entries.indexOf(n);
    this.entries.splice(a, 1);
  }
  walk(n) {
    this.entries = [...this.entries].filter((a) => n(a) !== !0);
  }
}
const Ba = new Qt(), ao = {
  open(e) {
    const n = typeof e == "string" ? {
      label: e
    } : { ...e };
    let a;
    Array.isArray(n.label) && (a = n.label, delete n.label);
    const o = yt({
      programmatic: { instances: Ba },
      active: !0
      // set the active state to true
    }, n);
    o.promise = new Promise((m, c) => {
      o.programmatic.resolve = m, o.programmatic.reject = c;
    });
    const i = () => a, u = zt, d = me(ya, o, i);
    return d.appContext = u._context, Xt(d, document.createElement("div")), d.component.exposed;
  },
  closeAll(...e) {
    Ba.walk((n) => n.exposed.close(...e));
  }
}, lo = ao, no = {
  install(e) {
    Ae(e, ya), Ht(e, "loading", lo);
  }
}, oo = ["role"], io = /* @__PURE__ */ ye({
  isOruga: !0,
  name: "OMenu",
  configField: "menu",
  __name: "Menu",
  props: {
    /** Override existing theme classes completely */
    override: { type: Boolean, default: void 0 },
    /** Menu label */
    label: { type: String, default: void 0 },
    /** If sub menu items are collapsible */
    accordion: { type: Boolean, default: !0 },
    /** If the menu items are clickable */
    activable: { type: Boolean, default: !0 },
    /**
     * Role attribute to be passed to the list container for better accessibility.
     * Use menu only in situations where your dropdown is related to a navigation menu.
     * @values list, menu, dialog
     */
    ariaRole: {
      type: String,
      default: r("menu.ariaRole", "menu"),
      validator: (e) => ["menu", "list", "dialog"].indexOf(e) > -1
    },
    /** Icon to be shown */
    icon: { type: String, default: void 0 },
    /**
     * Icon pack to use
     * @values mdi, fa, fas and any other custom icon pack
     */
    iconPack: {
      type: String,
      default: () => r("menu.iconPack")
    },
    /**
     * Icon size
     * @values small, medium, large
     */
    iconSize: {
      type: String,
      default: () => r("menu.iconSize")
    },
    // class props (will not be displayed in the docs)
    /** Class of the root element */
    rootClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the menu list */
    listClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the menu list label */
    listLabelClass: {
      type: [String, Array, Function],
      default: void 0
    }
  },
  setup(e) {
    const n = e, a = L(), t = l(() => ({
      activable: n.activable,
      accordion: n.accordion,
      resetMenu: i
    })), { childItems: o } = bt(a, {
      data: t
    });
    function i(c = []) {
      o.value.forEach((v) => {
        c.includes(We(v)) || v.data.value.reset();
      });
    }
    const u = h(["rootClass", "o-menu"]), d = h(["listClass", "o-menu__list"]), m = h(["listLabelClass", "o-menu__label"]);
    return (c, v) => {
      const p = Ut("o-icon");
      return f(), P("div", {
        ref_key: "rootRef",
        ref: a,
        "data-oruga": "menu",
        class: M(s(u))
      }, [
        e.label || c.$slots.label ? (f(), P("div", {
          key: 0,
          class: M(s(m))
        }, [
          _(c.$slots, "label", {}, () => [
            e.icon ? (f(), ne(p, {
              key: 0,
              icon: e.icon,
              pack: e.iconPack,
              size: e.iconSize
            }, null, 8, ["icon", "pack", "size"])) : J("", !0),
            le("span", null, ue(e.label), 1)
          ])
        ], 2)) : J("", !0),
        le("ul", {
          class: M(s(d)),
          role: e.ariaRole
        }, [
          _(c.$slots, "default")
        ], 10, oo)
      ], 2);
    };
  }
}), so = ["role", "data-id"], ro = /* @__PURE__ */ ye({
  isOruga: !0,
  name: "OMenuItem",
  configField: "menu",
  inheritAttrs: !1,
  __name: "MenuItem",
  props: {
    /** Override existing theme classes completely */
    override: { type: Boolean, default: void 0 },
    /** The active state of the menu item, use v-model:active to make it two-way binding. */
    active: { type: Boolean, default: !1 },
    /** Menu item label */
    label: { type: String, default: void 0 },
    /** Menu item will be expanded */
    expanded: { type: Boolean, default: !1 },
    /** Menu item will be disabled */
    disabled: { type: Boolean, default: !1 },
    /** Icon to be shown */
    icon: { type: String, default: void 0 },
    /**
     * Icon pack to use
     * @values mdi, fa, fas and any other custom icon pack
     */
    iconPack: {
      type: String,
      default: () => r("menu.iconPack")
    },
    /**
     * Icon size
     * @values small, medium, large
     */
    iconSize: {
      type: String,
      default: () => r("menu.iconSize")
    },
    /** Transition name to apply on menu list */
    animation: {
      type: String,
      default: () => r("menu.animation", "slide")
    },
    /** Menu item tag name */
    tag: {
      type: [String, Object, Function],
      default: () => r("menu.menuTag", "a")
    },
    /**
     * Role attribute to be passed to the list item for better accessibility.
     * @values listitem, menuitem
     */
    ariaRole: {
      type: String,
      default: r("menu.itemAriaRole", "menuitem")
    },
    // class props (will not be displayed in the docs)
    /** Class of the menu item */
    itemClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the active menu item */
    itemActiveClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the disabled menu item */
    itemDisabledClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the icon of menu item */
    itemIconTextClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the menu item when is a submenu */
    itemSubmenuClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the root element of menu item */
    itemWrapperClass: {
      type: [String, Array, Function],
      default: void 0
    }
  },
  emits: ["update:modelValue", "update:expanded"],
  setup(e, { emit: n }) {
    const a = e, t = n, o = l(() => ({
      reset: A
    })), { parent: i, item: u } = gt({
      data: o
    }), d = gt({
      key: "menu-item",
      needParent: !1
    }), m = l(() => {
      var R;
      return (R = d.parent) == null ? void 0 : R.value;
    }), c = qe("active", a, t, { passive: !0 }), v = qe("expanded", a, t, { passive: !0 }), p = l(
      () => m.value ? `menu-item-${d.item.value.identifier}` : `menu-${u.value.identifier}`
    );
    function C() {
      a.disabled || (B(), v.value = a.expanded || !v.value, i.value.activable && (c.value = !0));
    }
    function B(R) {
      var H;
      (H = m.value) != null && H.triggerReset ? m.value.triggerReset(We(u.value)) : i.value.resetMenu && i.value.resetMenu([We(u.value), R]);
    }
    function A() {
      i.value.accordion && (v.value = !1), i.value.activable && (c.value = !1);
    }
    const g = L(), y = l(() => ({
      triggerReset: B
    }));
    bt(g, { key: "menu-item", data: y });
    const I = h(
      ["itemClass", "o-menu__item"],
      ["itemActiveClass", "o-menu__item--active", null, c],
      [
        "itemDisabledClass",
        "o-menu__item--disabled",
        null,
        l(() => a.disabled)
      ],
      [
        "itemIconTextClass",
        "o-menu__item--icon-text",
        null,
        l(() => !!a.icon)
      ]
    ), k = h([
      "itemSubmenuClass",
      "o-menu__item__submenu"
    ]), z = h([
      "itemWrapperClass",
      "o-menu__item__wrapper"
    ]);
    return (R, H) => {
      const j = Ut("o-icon");
      return f(), P("li", {
        ref_key: "rootRef",
        ref: g,
        role: e.ariaRole,
        class: M(s(z)),
        "data-id": p.value,
        "data-oruga": "menu-item",
        "aria-roledescription": "item"
      }, [
        (f(), ne(Ge(e.tag), be(R.$attrs, {
          class: s(I),
          onClick: H[0] || (H[0] = (U) => C())
        }), {
          default: se(() => [
            e.icon ? (f(), ne(j, {
              key: 0,
              icon: e.icon,
              pack: e.iconPack,
              size: e.iconSize
            }, null, 8, ["icon", "pack", "size"])) : J("", !0),
            _(R.$slots, "label", {
              expanded: s(v),
              active: s(c)
            }, () => [
              le("span", null, ue(e.label), 1)
            ])
          ]),
          _: 3
        }, 16, ["class"])),
        R.$slots.default ? (f(), ne(et, {
          key: 0,
          name: e.animation
        }, {
          default: se(() => [
            $e(le("ul", {
              class: M(s(k))
            }, [
              _(R.$slots, "default")
            ], 2), [
              [ze, s(v)]
            ])
          ]),
          _: 3
        }, 8, ["name"])) : J("", !0)
      ], 10, so);
    };
  }
}), uo = {
  install(e) {
    Ae(e, io), Ae(e, ro);
  }
}, co = ["role", "aria-label", "aria-modal"], fo = { key: 0 }, el = /* @__PURE__ */ ye({
  isOruga: !0,
  name: "OModal",
  configField: "modal",
  inheritAttrs: !1,
  __name: "Modal",
  props: {
    /** Override existing theme classes completely */
    override: { type: Boolean, default: void 0 },
    /** Whether modal is active or not, use v-model:active to make it two-way binding */
    active: { type: Boolean, default: !1 },
    /** Display modal as full screen */
    fullScreen: { type: Boolean, default: !1 },
    /** Text content, unnecessary when default slot is used */
    content: { type: String, default: void 0 },
    /** Width of the Modal */
    width: {
      type: [String, Number],
      default: () => r("modal.width", 960)
    },
    /** Custom animation (transition name) */
    animation: {
      type: String,
      default: () => r("modal.animation", "zoom-out")
    },
    /**
     * Is Modal cancleable by clicking 'X', pressing escape or clicking outside
     * @values escape, x, outside, button, true, false
     */
    cancelable: {
      type: [Array, Boolean],
      default: () => r("modal.cancelable", ["escape", "x", "outside", "button"])
    },
    /** Callback function to call after user canceled (clicked 'X' / pressed escape / clicked outside) */
    onCancel: { type: Function, default: () => {
    } },
    /** Callback function to call after close (programmatically close or user canceled) */
    onClose: { type: Function, default: () => {
    } },
    /**
     * Use `clip` to remove the body scrollbar, `keep` to have a non scrollable scrollbar to avoid shifting background,
     * but will set body to position fixed, might break some layouts.
     * @values keep, clip
     */
    scroll: {
      type: String,
      default: () => r("modal.scroll", "keep"),
      validator: (e) => ["keep", "clip"].indexOf(e) >= 0
    },
    /** Trap focus inside the modal */
    trapFocus: {
      type: Boolean,
      default: () => r("modal.trapFocus", !0)
    },
    /**
     * Role attribute to be passed to the div wrapper for better accessibility.
     * @values dialog, alertdialog
     */
    ariaRole: {
      type: String,
      default: () => r("modal.ariaRole"),
      validator: (e) => ["dialog", "alertdialog"].indexOf(e) >= 0
    },
    /** Accessibility aria-label to be passed to the div wrapper element */
    ariaLabel: { type: String, default: () => r("modal.ariaLabel") },
    /** Destroy modal on hide */
    destroyOnHide: {
      type: Boolean,
      default: () => r("modal.destroyOnHide", !1)
    },
    /** Automatically focus modal when active */
    autoFocus: {
      type: Boolean,
      default: () => r("modal.autoFocus", !0)
    },
    /** Close icon name */
    closeIcon: {
      type: String,
      default: () => r("modal.closeIcon", "close")
    },
    /**
     * Size of close icon
     * @values small, medium, large
     */
    closeIconSize: {
      type: String,
      default: () => r("modal.closeIconSize", "medium")
    },
    /** Mobile breakpoint as max-width value */
    mobileBreakpoint: {
      type: String,
      default: () => r("modal.mobileBreakpoint")
    },
    /**
     * Append the component to another part of the DOM.
     * Set `true` to append the component to the body.
     * In addition, any CSS selector string or an actual DOM node can be used.
     */
    teleport: {
      type: [Boolean, String, Object],
      default: () => r("modal.teleport", !1)
    },
    /**
     * Component to be injected, used to open a component modal programmatically.
     * Close modal within the component by emitting a 'close' event — emits('close')
     */
    component: {
      type: [Object, Function],
      default: void 0
    },
    /** Props to be binded to the injected component */
    props: { type: Object, default: void 0 },
    /** Events to be binded to the injected component */
    events: { type: Object, default: () => ({}) },
    /** DOM element where the modal component will be created on (for programmatic usage) */
    container: {
      type: [Object, String],
      default: () => r("modal.container", "body")
    },
    /**
     * This is used internally for programmatic usage
     * @ignore
     */
    programmatic: {
      type: Object,
      default: void 0
    },
    /**
     * This is used internally for programmatic usage
     * @ignore
     */
    promise: { type: Promise, default: void 0 },
    // class props (will not be displayed in the docs)
    /** Class of the root element */
    rootClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of modal component when its active */
    activeClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the modal overlay */
    overlayClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the modal content */
    contentClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the close button */
    closeClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the modal when fullscreen */
    fullScreenClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of modal component when on mobile */
    mobileClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the modal when scroll is clip */
    scrollClipClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the modal when scroll is not clip */
    noScrollClass: {
      type: [String, Array, Function],
      default: void 0
    }
  },
  emits: ["update:active", "close"],
  setup(e, { expose: n, emit: a }) {
    const t = e, o = a, i = L(), { isActive: u, close: d, cancel: m } = Jt(
      i,
      t,
      o,
      {
        destroyOnHide: t.destroyOnHide,
        cancelOptions: r("modal.cancelable", [
          "escape",
          "x",
          "outside",
          "button"
        ])
      }
    ), { isMobile: c } = ct(t.mobileBreakpoint), v = l(
      () => typeof t.teleport == "boolean" ? { to: "body", disabled: !t.teleport } : { to: t.teleport, disabled: !1 }
    ), p = L(null), C = L(!t.active);
    ce(u, (V) => {
      g(), V && i.value && t.autoFocus && De(() => i.value.focus()), !V && t.destroyOnHide && setTimeout(() => oa(i.value));
    });
    const B = l(
      () => Array.isArray(t.cancelable) ? t.cancelable.indexOf("x") >= 0 : t.cancelable
    ), A = l(
      () => t.fullScreen ? null : { maxWidth: Ft(t.width) }
    );
    It(() => {
      if (Be) {
        const V = p.value ? p.value : document.documentElement.scrollTop;
        Q.value && (document.body.classList.remove(...Q.value), document.documentElement.classList.remove(...Q.value)), document.documentElement.scrollTop = V, document.body.style.top = null;
      }
    });
    function g() {
      if (Be) {
        if (t.scroll === "clip") {
          Q.value && (u.value ? document.documentElement.classList.add(...Q.value) : document.documentElement.classList.remove(...Q.value));
          return;
        }
        if (p.value = p.value ? p.value : document.documentElement.scrollTop, Q.value && (u.value ? document.body.classList.add(...Q.value) : document.body.classList.remove(...Q.value)), u.value) {
          document.body.style.top = `-${p.value}px`;
          return;
        }
        document.documentElement.scrollTop = p.value, document.body.style.top = null, p.value = null;
      }
    }
    function y() {
      C.value = !1;
    }
    function I() {
      C.value = !0;
    }
    const k = h(
      ["rootClass", "o-modal"],
      ["mobileClass", "o-modal--mobile", null, c],
      ["activeClass", "o-modal--active", null, u]
    ), z = h(["overlayClass", "o-modal__overlay"]), R = h(
      ["contentClass", "o-modal__content"],
      [
        "fullScreenClass",
        "o-modal__content--full-screen",
        null,
        l(() => t.fullScreen)
      ]
    ), H = h(["closeClass", "o-modal__close"]), j = h(["scrollClipClass", "o-clipped"]), U = h(["noScrollClass", "o-noscroll"]), Q = l(
      () => Ee(
        t.scroll === "clip" ? j.value : U.value
      )
    );
    return Q.value, n({ close: d, promise: t.promise }), (V, b) => (f(), ne(ua, {
      to: v.value.to,
      disabled: v.value.disabled
    }, [
      me(et, {
        name: e.animation,
        onAfterEnter: y,
        onBeforeLeave: I
      }, {
        default: se(() => [
          $e((f(), P("div", be(V.$attrs, {
            ref_key: "rootRef",
            ref: i,
            "data-oruga": "modal",
            class: s(k),
            tabindex: -1,
            role: e.ariaRole,
            "aria-label": e.ariaLabel,
            "aria-modal": s(u)
          }), [
            le("div", {
              class: M(s(z)),
              tabindex: "-1",
              "aria-hidden": "true",
              onClick: b[0] || (b[0] = (D) => s(m)("outside"))
            }, null, 2),
            le("div", {
              class: M(s(R)),
              style: _e(A.value)
            }, [
              e.component ? (f(), ne(Ge(e.component), be({ key: 0 }, V.$props.props, ca(V.$props.events), { onClose: s(d) }), null, 16, ["onClose"])) : _(V.$slots, "default", {
                key: 1,
                close: s(d)
              }, () => [
                e.content ? (f(), P("div", fo, ue(e.content), 1)) : J("", !0)
              ]),
              B.value ? $e((f(), ne(Re, {
                key: 2,
                clickable: "",
                both: "",
                class: M(s(H)),
                icon: e.closeIcon,
                size: e.closeIconSize,
                onClick: b[1] || (b[1] = (D) => s(m)("x"))
              }, null, 8, ["class", "icon", "size"])), [
                [ze, !C.value]
              ]) : J("", !0)
            ], 6)
          ], 16, co)), [
            [ze, s(u)],
            [s(Xa), e.trapFocus]
          ])
        ]),
        _: 3
      }, 8, ["name"])
    ], 8, ["to", "disabled"]));
  }
}), Oa = new Qt(), vo = {
  open(e) {
    const n = typeof e == "string" ? {
      content: e
    } : { ...e };
    let a;
    Array.isArray(n.content) && (a = n.content, delete n.content);
    const o = yt({
      programmatic: { instances: Oa },
      active: !0
      // set the active state to true
    }, n);
    o.promise = new Promise((m, c) => {
      o.programmatic.resolve = m, o.programmatic.reject = c;
    });
    const i = () => a, u = zt, d = me(el, o, i);
    return d.appContext = u._context, Xt(d, document.createElement("div")), d.component.exposed;
  },
  closeAll(...e) {
    Oa.walk((n) => n.exposed.close(...e));
  }
}, po = vo, mo = {
  install(e) {
    Ae(e, el), Ht(e, "modal", po);
  }
}, yo = ["aria-label"], go = ["innerHTML"], bo = /* @__PURE__ */ ye({
  isOruga: !0,
  name: "ONotification",
  configField: "notification",
  inheritAttrs: !1,
  __name: "Notification",
  props: {
    /** Override existing theme classes completely */
    override: { type: Boolean, default: void 0 },
    /** Whether modal is active or not, use v-model:active to make it two-way binding */
    active: { type: Boolean, default: !0 },
    /**
     * Type (color) of the notification
     * @values info, success, warning, danger
     */
    type: {
      type: String,
      default: void 0,
      validator: (e) => ["info", "success", "warning", "danger", void 0].indexOf(e) > -1
    },
    /**
     * Color of the control
     * @values primary, info, success, warning, danger, and any other custom color
     */
    variant: {
      type: String,
      default: () => r("notification.variant")
    },
    /**
     * Which position the notification will appear when programmatically
     * @values top-right, top, top-left, bottom-right, bottom, bottom-left
     */
    position: {
      type: String,
      default: () => r("notification.position", "top"),
      validator: (e) => [
        "top-right",
        "top",
        "top-left",
        "bottom-right",
        "bottom",
        "bottom-left"
      ].indexOf(e) > -1
    },
    /** Message text (can contain HTML), unnecessary when default slot is used */
    message: {
      type: [String, Array],
      default: void 0
    },
    /** Custom animation (transition name) */
    animation: {
      type: String,
      default: () => r("notification.animation", "fade")
    },
    /** Accessibility label for the close button */
    ariaCloseLabel: {
      type: String,
      default: () => r("notification.ariaCloseLabel", "Close")
    },
    /**
     * Icon pack to use
     * @values mdi, fa, fas and any other custom icon pack
     */
    iconPack: {
      type: String,
      default: () => r("notification.iconPack")
    },
    /** Icon name to use */
    icon: { type: String, default: void 0 },
    /**
     * Icon size
     * @values small, medium, large
     */
    iconSize: {
      type: String,
      default: () => r("notification.iconSize", "large")
    },
    /** Add close button to the item that closes the notification */
    closable: { type: Boolean, default: !1 },
    /** Close icon name */
    closeIcon: {
      type: String,
      default: () => r("notification.closeIcon", "close")
    },
    /**
     * Size of close icon
     * @values small, medium, large
     */
    closeIconSize: {
      type: String,
      default: () => r("notification.closeIconSize")
    },
    // class props (will not be displayed in the docs)
    /** Class of the root element */
    rootClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the close button container */
    closeClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the content element */
    contentClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the icon on the left */
    iconClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the element when positioned */
    positionClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the notification variant */
    variantClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the wrapper element */
    wrapperClass: {
      type: [String, Array, Function],
      default: void 0
    }
  },
  emits: ["update:active", "close"],
  setup(e, { emit: n }) {
    const a = e, t = n, o = qe("active", a, t, {
      passive: !0
    }), i = l(() => {
      if (a.icon)
        return a.icon;
      switch (a.type) {
        case "info":
          return "information";
        case "success":
          return "check-circle";
        case "warning":
          return "alert";
        case "danger":
          return "alert-circle";
        default:
          return null;
      }
    });
    function u(...C) {
      o.value = !1, t("close", ...C);
    }
    const d = h(
      ["rootClass", "o-notification"],
      [
        "variantClass",
        "o-notification--",
        l(() => a.variant),
        l(() => !!a.variant)
      ],
      [
        "positionClass",
        "o-notification--",
        l(() => a.position),
        l(() => !!a.position)
      ]
    ), m = h([
      "wrapperClass",
      "o-notification__wrapper"
    ]), c = h(["iconClass", "o-notification__icon"]), v = h([
      "contentClass",
      "o-notification__content"
    ]), p = h(["closeClass", "o-notification__close"]);
    return (C, B) => (f(), ne(et, { name: e.animation }, {
      default: se(() => [
        $e(le("article", be(C.$attrs, {
          class: s(d),
          "data-oruga": "notification"
        }), [
          e.closable ? (f(), P("button", {
            key: 0,
            class: M(s(p)),
            type: "button",
            "aria-label": e.ariaCloseLabel,
            onClick: B[0] || (B[0] = (A) => u({ action: "close", method: "x" }))
          }, [
            me(Re, {
              clickable: "",
              pack: e.iconPack,
              both: "",
              icon: e.closeIcon,
              size: e.closeIconSize
            }, null, 8, ["pack", "icon", "size"])
          ], 10, yo)) : J("", !0),
          _(C.$slots, "inner", { close: u }),
          C.$slots.default || e.message ? (f(), P("div", {
            key: 1,
            class: M(s(m))
          }, [
            i.value ? (f(), ne(Re, {
              key: 0,
              icon: i.value,
              pack: e.iconPack,
              class: M(s(c)),
              both: "",
              size: e.iconSize,
              "aria-hidden": ""
            }, null, 8, ["icon", "pack", "class", "size"])) : J("", !0),
            le("div", {
              class: M(s(v))
            }, [
              _(C.$slots, "default", { close: u }, () => [
                e.message ? (f(), P("span", {
                  key: 0,
                  innerHTML: e.message
                }, null, 8, go)) : J("", !0)
              ])
            ], 2)
          ], 2)) : J("", !0)
        ], 16), [
          [ze, s(o)]
        ])
      ]),
      _: 3
    }, 8, ["name"]));
  }
}), Co = /* @__PURE__ */ ye({
  isOruga: !0,
  name: "ONotificationNotice",
  configField: "notification",
  inheritAttrs: !1,
  __name: "NotificationNotice",
  props: {
    /** Override existing theme classes completely */
    override: { type: Boolean, default: void 0 },
    /** Whether notification is active or not, use v-model:active to make it two-way binding. */
    active: { type: Boolean, default: !0 },
    /**
     * Which position the notification will appear when programmatically.
     * @values top-right, top, top-left, bottom-right, bottom, bottom-left
     */
    position: {
      type: String,
      default: () => r("notification.position", "top"),
      validator: (e) => [
        "top-right",
        "top",
        "top-left",
        "bottom-right",
        "bottom",
        "bottom-left"
      ].indexOf(e) > -1
    },
    /** Hide notification after duration (in miliseconds) */
    duration: {
      type: Number,
      default: () => r("notification.duration", 2e3)
    },
    /** Show the Notification infinitely until it is dismissed. */
    infinite: { type: Boolean, default: !1 },
    /** If notice should queue with others notices (snackbar/toast/notification). */
    queue: {
      type: Boolean,
      default: () => r("notification.queue")
    },
    /** Callback function to call after user canceled (pressed escape / clicked outside). */
    onCancel: { type: Function, default: () => {
    } },
    /** Callback function to call after close (programmatically close or user canceled). */
    onClose: { type: Function, default: () => {
    } },
    /**
     * Component to be injected.
     * Close notification within the component by emitting a 'close' event — $emit('close').
     */
    component: {
      type: [Object, Function],
      default: void 0
    },
    /** Props to be binded to the injected component. */
    props: { type: Object, default: void 0 },
    /** Events to be binded to the injected component. */
    events: { type: Object, default: () => ({}) },
    /**
     * DOM element the toast will be created on (for programmatic usage).
     * Note that this also changes the position of the toast from fixed to absolute.
     * Meaning that the container should be fixed.
     */
    container: {
      type: [Object, String],
      default: () => r("notification.container", "body")
    },
    /**
     * Props passed to the internal notification component.
     * @ignore
     */
    notification: {
      type: Object,
      default: () => ({})
    },
    /**
     * This is used internally for programmatic usage.
     * @ignore
     */
    programmatic: {
      type: Object,
      default: void 0
    },
    /**
     * This is used internally for programmatic usage.
     * @ignore
     */
    promise: { type: Promise, default: void 0 },
    // class props (will not be displayed in the docs)
    /** Root class of the notice */
    noticeClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the notice when positioned */
    noticePositionClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the custom container element */
    noticeCustomContainerClass: {
      type: [String, Array, Function],
      default: void 0
    }
  },
  emits: ["update:active", "close"],
  setup(e, { expose: n, emit: a }) {
    const t = e, o = a, i = L(), { isActive: u, close: d, container: m } = Jt(
      () => i.value.$el,
      t,
      o,
      {
        cancelOptions: ["escape", "x"]
      }
    ), c = L(null), v = L(null), p = L();
    ce(
      () => u,
      (H) => {
        H ? g() : p.value && clearTimeout(p.value);
      }
    ), Rl(() => {
      if (I.value && z.value && k.value) {
        const H = Ee(I.value), j = Ee(k.value), U = Ee(z.value);
        if (c.value = m.value.querySelector(
          `.${H.join(".")}.${j.join(".")}`
        ), v.value = m.value.querySelector(
          `.${H.join(".")}.${U.join(".")}`
        ), c.value && v.value)
          return;
        if (c.value || (c.value = document.createElement("div"), c.value.className = `${H.join(
          " "
        )} ${j.join(" ")}`), v.value || (v.value = document.createElement("div"), v.value.className = `${H.join(
          " "
        )} ${U.join(" ")}`), m.value.appendChild(c.value), m.value.appendChild(v.value), m.value.tagName !== "BODY") {
          const Q = Ee(
            R.value
          );
          Q != null && Q.length && Q.filter((V) => !!V).forEach((V) => {
            c.value.classList.add(V), v.value.classList.add(V);
          });
        }
      }
    }), st(() => {
      A(), g();
    });
    const C = l(() => {
      switch (t.position) {
        case "top-right":
        case "top":
        case "top-left":
          return c.value;
        case "bottom-right":
        case "bottom":
        case "bottom-left":
          return v.value;
        default:
          return null;
      }
    }), B = l(
      () => t.queue ? c.value.childElementCount > 0 || v.value.childElementCount > 0 : !1
    );
    function A() {
      B.value && (C.value.innerHTML = ""), C.value.insertAdjacentElement(
        "afterbegin",
        i.value.$el
      ), u.value = !0;
    }
    function g() {
      t.infinite || (p.value && clearTimeout(p.value), p.value = setTimeout(() => {
        u.value && y({ action: "close", method: "timeout" });
      }, t.duration));
    }
    function y(...H) {
      clearTimeout(p.value), d(...H);
    }
    const I = h(["noticeClass", "o-notices"]), k = h([
      "noticePositionClass",
      "o-notices--",
      "top"
    ]), z = h([
      "noticePositionClass",
      "o-notices--",
      "bottom"
    ]), R = h([
      "noticeCustomContainerClass",
      "o-notices__custom-container"
    ]);
    return n({ close: y, promise: t.promise }), (H, j) => {
      const U = Ut("o-notification");
      return f(), ne(U, be(e.notification, {
        ref_key: "notificationRef",
        ref: i,
        active: s(u),
        "onUpdate:active": j[0] || (j[0] = (Q) => Ke(u) ? u.value = Q : null),
        position: e.position,
        onClose: y
      }), {
        inner: se(({ close: Q }) => [
          e.component ? (f(), ne(Ge(e.component), be({ key: 0 }, H.$props.props, ca(H.$props.events), { onClose: Q }), null, 16, ["onClose"])) : J("", !0)
        ]),
        default: se(() => [
          _(H.$slots, "default")
        ]),
        _: 3
      }, 16, ["active", "position"]);
    };
  }
}), Pa = new Qt(), ho = {
  open(e) {
    const n = typeof e == "string" ? {
      message: e
    } : { ...e };
    let a;
    Array.isArray(n.message) && (a = n.message, delete n.message);
    const t = {
      programmatic: { instances: Pa },
      active: !0,
      // set the active state to true
      position: r("notification.position", "top-right")
    }, o = n.notification ? n.notification : n, i = yt(t, n);
    i.notification = yt({}, o), i.promise = new Promise((c, v) => {
      i.programmatic.resolve = c, i.programmatic.reject = v;
    });
    const u = () => a, d = zt, m = me(Co, i, u);
    return m.appContext = d._context, Xt(m, document.createElement("div")), m.component.exposed;
  },
  closeAll(...e) {
    Pa.walk((n) => n.exposed.close(...e));
  }
}, ko = ho, So = {
  install(e) {
    Ae(e, bo), Ht(
      e,
      "notification",
      ko
    );
  }
}, Mt = /* @__PURE__ */ ye({
  isOruga: !0,
  name: "OPaginationButton",
  configField: "pagination",
  __name: "PaginationButton",
  props: {
    number: { type: Number, default: void 0 },
    isCurrent: { type: Boolean, default: !1 },
    click: {
      type: Function,
      required: !0
    },
    ariaLabel: { type: String, default: void 0 },
    disabled: { type: Boolean, default: !1 },
    tag: {
      type: [String, Object, Function],
      default: "button"
    },
    class: { type: String, default: void 0 },
    linkClass: {
      type: Array,
      required: !0
    },
    linkCurrentClass: {
      type: Array,
      required: !0
    }
  },
  setup(e) {
    const n = e, a = l(() => [
      ...n.linkClass,
      n.class,
      ...n.isCurrent ? n.linkCurrentClass : []
    ]);
    return (t, o) => (f(), ne(Ge(e.tag), be({
      role: "button",
      tabindex: e.disabled ? null : 0,
      disabled: e.disabled,
      class: a.value
    }, t.$attrs, {
      "aria-label": e.ariaLabel,
      "aria-current": e.isCurrent,
      onClick: ve(e.click, ["prevent"]),
      onKeydown: Ce(ve(e.click, ["prevent"]), ["enter"])
    }), {
      default: se(() => [
        _(t.$slots, "default", {}, () => [
          Pe(ue(e.number), 1)
        ])
      ]),
      _: 3
    }, 16, ["tabindex", "disabled", "class", "aria-label", "aria-current", "onClick", "onKeydown"]));
  }
}), tl = /* @__PURE__ */ ye({
  isOruga: !0,
  name: "OPagination",
  configField: "pagination",
  inheritAttrs: !1,
  __name: "Pagination",
  props: {
    /** Override existing theme classes completely */
    override: { type: Boolean, default: void 0 },
    /** Total count of items */
    total: { type: Number, default: void 0 },
    /** Items count for each page */
    perPage: {
      type: [Number, String],
      default: () => r("pagination.perPage", 20)
    },
    /** Current page number, use v-model:current to make it two-way binding. */
    current: { type: Number, default: 1 },
    /** Number of pagination items to show before current page. */
    rangeBefore: { type: Number, default: 1 },
    /** Number of pagination items to show after current page. */
    rangeAfter: { type: Number, default: 1 },
    /**
     * Pagination size
     * @values small, medium, large
     */
    size: {
      type: String,
      default: () => r("pagination.size")
    },
    /** Simple style */
    simple: {
      type: Boolean,
      default: () => r("pagination.simple", !1)
    },
    /** Rounded button style */
    rounded: {
      type: Boolean,
      default: () => r("pagination.rounded", !1)
    },
    /**
     * Buttons order
     * @values centered, right, left
     */
    order: {
      type: String,
      default: () => r("pagination.order", "right"),
      validator: (e) => ["centered", "right", "left"].indexOf(e) >= 0
    },
    /** Pagination button tag name */
    buttonTag: {
      type: [String, Object, Function],
      default: () => r("pagination.buttonTag", "button")
    },
    /**
     * Icon pack to use
     * @values mdi, fa, fas and any other custom icon pack
     */
    iconPack: {
      type: String,
      default: () => r("pagination.iconPack")
    },
    /** Icon to use for previous button */
    iconPrev: {
      type: String,
      default: () => r("pagination.iconPrev", "chevron-left")
    },
    /** Icon to use for next button */
    iconNext: {
      type: String,
      default: () => r("pagination.iconNext", "chevron-right")
    },
    /** Mobile breakpoint as max-width value */
    mobileBreakpoint: {
      type: String,
      default: () => r("pagination.mobileBreakpoint")
    },
    /** Accessibility label for the next page button. */
    ariaNextLabel: {
      type: String,
      default: () => r("pagination.ariaNextLabel", "Next page")
    },
    /** Accessibility label for the previous page button. */
    ariaPreviousLabel: {
      type: String,
      default: () => r("pagination.ariaPreviousLabel", "Previous page")
    },
    /** Accessibility label for the page button. */
    ariaPageLabel: {
      type: String,
      default: () => r("pagination.ariaPageLabel", "page")
    },
    /** Accessibility label for the current page button. */
    ariaCurrentLabel: {
      type: String,
      default: () => r("pagination.ariaCurrentLabel", "Current page")
    },
    // class props (will not be displayed in the docs)
    /** Class of the root element */
    rootClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the prev button */
    prevButtonClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the next button */
    nextButtonClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the pagination list */
    listClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the pagination list items */
    listItemClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the link button */
    linkClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the current link */
    linkCurrentClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the pagination ellipsis */
    ellipsisClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the info in `simple` mode */
    infoClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the pagination order */
    orderClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the pagination in `simple` mode */
    simpleClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the pagination when rounded */
    roundedClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the disabled link */
    linkDisabledClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class for the pagination size */
    sizeClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of pagination component when on mobile */
    mobileClass: {
      type: [String, Array, Function],
      default: void 0
    }
  },
  emits: ["update:current", "change"],
  setup(e, { expose: n, emit: a }) {
    const t = e, o = a, { isMobile: i } = ct(t.mobileBreakpoint), u = qe("current", t, o), d = l(
      () => Math.ceil(t.total / Number(t.perPage))
    );
    ce(
      () => d.value,
      (w) => {
        t.current > w && H();
      }
    );
    const m = l(() => {
      const w = Number(t.perPage), $ = t.current * w - w + 1;
      return $ >= 0 ? $ : 0;
    }), c = l(() => t.current > 1), v = l(() => t.current >= 2 + t.rangeBefore), p = l(() => t.current >= t.rangeBefore + 4), C = l(
      () => t.current <= d.value - (1 + t.rangeAfter)
    ), B = l(
      () => t.current < d.value - (2 + t.rangeAfter)
    ), A = l(() => t.current < d.value), g = l(() => {
      if (t.simple)
        return;
      let w = Math.max(1, t.current - t.rangeBefore);
      w - 1 === 2 && w--;
      let $ = Math.min(t.current + t.rangeAfter, d.value);
      d.value - $ === 2 && $++;
      const N = [];
      for (let ae = w; ae <= $; ae++)
        N.push(y(ae));
      return N;
    });
    function y(w, $) {
      return {
        number: w,
        isCurrent: t.current === w,
        click: (N) => j(w, N),
        ariaLabel: $ || I(w, t.current === w),
        tag: t.buttonTag
      };
    }
    function I(w, $) {
      return t.ariaPageLabel && (!$ || !t.ariaCurrentLabel) ? t.ariaPageLabel + " " + w + "." : t.ariaPageLabel && $ && t.ariaCurrentLabel ? t.ariaCurrentLabel + ", " + t.ariaPageLabel + " " + w + "." : null;
    }
    function k(w) {
      j(t.current - 1, w);
    }
    function z(w) {
      j(t.current + 1, w);
    }
    function R(w) {
      j(1, w);
    }
    function H(w) {
      j(d.value, w);
    }
    function j(w, $) {
      t.current === w || w < 1 || w > d.value || (o("change", w), u.value = w, $ && $.target && De(() => $.target.focus()));
    }
    const U = h(
      ["rootClass", "o-pag"],
      [
        "orderClass",
        "o-pag--",
        l(() => t.order),
        l(() => !!t.order)
      ],
      [
        "sizeClass",
        "o-pag--",
        l(() => t.size),
        l(() => !!t.size)
      ],
      ["simpleClass", "o-pag--simple", null, l(() => t.simple)],
      ["mobileClass", "o-pag--mobile", null, i]
    ), Q = h(
      ["prevButtonClass", "o-pag__previous"],
      [
        "linkDisabledClass",
        "o-pag__link--disabled",
        null,
        l(() => !c.value)
      ]
    ), V = h(
      ["nextButtonClass", "o-pag__next"],
      [
        "linkDisabledClass",
        "o-pag__link--disabled",
        null,
        l(() => !A.value)
      ]
    ), b = h(["infoClass", "o-pag__info"]), D = h(["ellipsisClass", "o-pag__ellipsis"]), W = h(["listClass", "o-pag__list"]), G = h(
      ["linkClass", "o-pag__link"],
      [
        "roundedClass",
        "o-pag__link--rounded",
        null,
        l(() => t.rounded)
      ]
    ), E = h([
      "linkCurrentClass",
      "o-pag__link--current"
    ]), S = h(["listItemClass", "o-pag__item"]);
    return n({ last: H, first: R, prev: k, next: z }), (w, $) => (f(), P("nav", {
      class: M(s(U)),
      "data-oruga": "pagination"
    }, [
      _(w.$slots, "previous", Ot(Pt(y(s(u) - 1, e.ariaPreviousLabel))), () => [
        me(Mt, be(y(s(u) - 1, e.ariaPreviousLabel), {
          class: s(Q),
          "link-class": s(G),
          "link-current-class": s(E)
        }), {
          default: se(() => [
            me(Re, {
              icon: e.iconPrev,
              pack: e.iconPack,
              both: "",
              "aria-hidden": "true"
            }, null, 8, ["icon", "pack"])
          ]),
          _: 1
        }, 16, ["class", "link-class", "link-current-class"])
      ]),
      _(w.$slots, "next", Ot(Pt(y(s(u) + 1, e.ariaNextLabel))), () => [
        me(Mt, be(y(s(u) + 1, e.ariaNextLabel), {
          class: s(V),
          "link-class": s(G),
          "link-current-class": s(E)
        }), {
          default: se(() => [
            me(Re, {
              icon: e.iconNext,
              pack: e.iconPack,
              both: "",
              "aria-hidden": "true"
            }, null, 8, ["icon", "pack"])
          ]),
          _: 1
        }, 16, ["class", "link-class", "link-current-class"])
      ]),
      e.simple ? (f(), P("small", {
        key: 0,
        class: M(s(b))
      }, [
        e.perPage == 1 ? (f(), P(he, { key: 0 }, [
          Pe(ue(m.value) + " / " + ue(e.total), 1)
        ], 64)) : (f(), P(he, { key: 1 }, [
          Pe(ue(m.value) + "-" + ue(Math.min(s(u) * Number(e.perPage), e.total)) + " / " + ue(e.total), 1)
        ], 64))
      ], 2)) : (f(), P("ul", {
        key: 1,
        class: M(s(W))
      }, [
        v.value ? (f(), P("li", {
          key: 0,
          class: M(s(S))
        }, [
          _(w.$slots, "default", Ot(Pt(y(1))), () => [
            me(Mt, be(y(1), {
              "link-class": s(G),
              "link-current-class": s(E)
            }), null, 16, ["link-class", "link-current-class"])
          ])
        ], 2)) : J("", !0),
        p.value ? (f(), P("li", {
          key: 1,
          class: M(s(S))
        }, [
          le("span", {
            class: M(s(D))
          }, "…", 2)
        ], 2)) : J("", !0),
        (f(!0), P(he, null, xe(g.value, (N) => (f(), P("li", {
          key: N.number,
          class: M(s(S))
        }, [
          _(w.$slots, "default", Ot(Pt(N)), () => [
            me(Mt, be(N, {
              "link-class": s(G),
              "link-current-class": s(E)
            }), null, 16, ["link-class", "link-current-class"])
          ])
        ], 2))), 128)),
        B.value ? (f(), P("li", {
          key: 2,
          class: M(s(S))
        }, [
          le("span", {
            class: M(s(D))
          }, "…", 2)
        ], 2)) : J("", !0),
        C.value ? (f(), P("li", {
          key: 3,
          class: M(s(S))
        }, [
          _(w.$slots, "default", Ot(Pt(y(d.value))), () => [
            me(Mt, be(y(d.value), {
              "link-class": s(G),
              "link-current-class": s(E)
            }), null, 16, ["link-class", "link-current-class"])
          ])
        ], 2)) : J("", !0)
      ], 2))
    ], 2));
  }
}), Fo = {
  install(e) {
    Ae(e, tl);
  }
}, Ao = ["aria-checked"], wo = ["disabled", "required", "name", "autocomplete", "value", "aria-labelledby"], Do = ["id"], xo = /* @__PURE__ */ ye({
  isOruga: !0,
  name: "ORadio",
  configField: "radio",
  inheritAttrs: !1,
  __name: "Radio",
  props: {
    /** Override existing theme classes completely */
    override: { type: Boolean, default: void 0 },
    /** @model */
    modelValue: { type: [String, Number, Boolean], default: void 0 },
    /**
     * Color of the control
     * @values primary, info, success, warning, danger, and any other custom color
     */
    variant: {
      type: String,
      default: () => r("radio.variant")
    },
    /**
     * Size of the control
     * @values small, medium, large
     */
    size: {
      type: String,
      default: () => r("radio.size")
    },
    /** Input label, unnecessary when default slot is used */
    label: { type: String, default: void 0 },
    /** Same as native value */
    nativeValue: { type: [String, Number, Boolean], default: void 0 },
    /** Same as native disabled */
    disabled: { type: Boolean, default: !1 },
    /** Same as native required */
    required: { type: Boolean, default: !1 },
    /** Same as native name */
    name: { type: String, default: void 0 },
    /** Accessibility label to establish relationship between the checkbox and control label */
    ariaLabelledby: { type: String, default: () => Ye() },
    /** Same as native autocomplete options to use in HTML5 validation */
    autocomplete: {
      type: String,
      default: () => r("radio.autocomplete", "off")
    },
    /** Enable html 5 native validation */
    useHtml5Validation: {
      type: Boolean,
      default: () => r("useHtml5Validation", !0)
    },
    // class props (will not be displayed in the docs)
    /** Class of the root element */
    rootClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class when radio is disabled */
    disabledClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the root element when checked */
    checkedClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the native input element */
    inputClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the native input element when checked */
    inputCheckedClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the radio label */
    labelClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the radio size */
    sizeClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the radio variant */
    variantClass: {
      type: [String, Array, Function],
      default: void 0
    }
  },
  emits: ["update:modelValue", "input", "focus", "blur", "invalid"],
  setup(e, { expose: n, emit: a }) {
    const t = e, o = a, i = L(), { onBlur: u, onFocus: d, onInvalid: m, setFocus: c } = rt(
      i,
      o,
      t
    ), v = dt(t, o), p = l(() => v.value === t.nativeValue);
    function C(y) {
      o("input", v.value, y);
    }
    const B = h(
      ["rootClass", "o-radio"],
      ["checkedClass", "o-radio--checked", null, p],
      [
        "sizeClass",
        "o-radio--",
        l(() => t.size),
        l(() => !!t.size)
      ],
      [
        "disabledClass",
        "o-radio--disabled",
        null,
        l(() => t.disabled)
      ],
      [
        "variantClass",
        "o-radio--",
        l(() => t.variant),
        l(() => !!t.variant)
      ]
    ), A = h(
      ["inputClass", "o-radio__input"],
      ["inputCheckedClass", "o-radio__input--checked", null, p]
    ), g = h(["labelClass", "o-radio__label"]);
    return n({ focus: c }), (y, I) => (f(), P("label", {
      ref: "label",
      class: M(s(B)),
      "data-oruga": "radio",
      role: "radio",
      "aria-checked": p.value,
      onClick: I[5] || (I[5] = ve(
        //@ts-ignore
        (...k) => s(c) && s(c)(...k),
        ["stop"]
      )),
      onKeydown: I[6] || (I[6] = Ce(ve(
        //@ts-ignore
        (...k) => s(c) && s(c)(...k),
        ["prevent"]
      ), ["enter"]))
    }, [
      $e(le("input", be(y.$attrs, {
        ref_key: "inputRef",
        ref: i,
        "onUpdate:modelValue": I[0] || (I[0] = (k) => Ke(v) ? v.value = k : null),
        type: "radio",
        "data-oruga-input": "radio",
        class: s(A),
        disabled: e.disabled,
        required: e.required,
        name: e.name,
        autocomplete: e.autocomplete,
        value: e.nativeValue,
        "aria-labelledby": e.ariaLabelledby,
        onClick: I[1] || (I[1] = ve(() => {
        }, ["stop"])),
        onBlur: I[2] || (I[2] = //@ts-ignore
        (...k) => s(u) && s(u)(...k)),
        onFocus: I[3] || (I[3] = //@ts-ignore
        (...k) => s(d) && s(d)(...k)),
        onInvalid: I[4] || (I[4] = //@ts-ignore
        (...k) => s(m) && s(m)(...k)),
        onInput: C
      }), null, 16, wo), [
        [Vl, s(v)]
      ]),
      e.label || y.$slots.default ? (f(), P("span", {
        key: 0,
        id: e.ariaLabelledby,
        class: M(s(g))
      }, [
        _(y.$slots, "default", {}, () => [
          Pe(ue(e.label), 1)
        ])
      ], 10, Do)) : J("", !0)
    ], 42, Ao));
  }
}), $o = {
  install(e) {
    Ae(e, xo);
  }
}, Bo = {
  install(e) {
    Ae(e, mt);
  }
}, Oo = /* @__PURE__ */ ye({
  isOruga: !0,
  name: "OSkeleton",
  configField: "skeleton",
  __name: "Skeleton",
  props: {
    /** Override existing theme classes completely */
    override: { type: Boolean, default: void 0 },
    /** Show or hide loader	 */
    active: { type: Boolean, default: !0 },
    /** Show a loading animation */
    animated: {
      type: Boolean,
      default: () => r("skeleton.animated", !0)
    },
    /** Custom width */
    width: { type: [Number, String], default: void 0 },
    /** Custom height */
    height: { type: [Number, String], default: void 0 },
    /** Show a circle shape */
    circle: { type: Boolean, default: !1 },
    /** Enable rounded style */
    rounded: {
      type: Boolean,
      default: () => r("skeleton.rounded", !0)
    },
    /** Number of shapes to display */
    count: { type: Number, default: 1 },
    /**
     * Size of skeleton
     * @values small, medium, large
     */
    size: { type: String, default: void 0 },
    /**
     * Skeleton position in relation to the element
     * @values left, centered, right
     */
    position: {
      type: String,
      default: "left",
      validator: (e) => ["left", "centered", "right"].indexOf(e) > -1
    },
    // class props (will not be displayed in the docs)
    /** Class of the root element */
    rootClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the skeleton animation */
    animationClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the skeleton position */
    positionClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the skeleton item */
    itemClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the skeleton item rounded */
    itemRoundedClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the skeleton size */
    sizeClass: {
      type: [String, Array, Function],
      default: void 0
    }
  },
  setup(e) {
    const n = e, a = l(() => ({
      height: Ft(n.height),
      width: Ft(n.width),
      borderRadius: n.circle ? "50%" : null
    })), t = h(
      ["rootClass", "o-sklt"],
      [
        "positionClass",
        "o-sklt--",
        l(() => n.position),
        l(() => !!n.position)
      ]
    ), o = h(
      ["itemClass", "o-sklt__item"],
      [
        "itemRoundedClass",
        "o-sklt__item--rounded",
        null,
        l(() => n.rounded)
      ],
      [
        "animationClass",
        "o-sklt__item--animated",
        null,
        l(() => n.animated)
      ],
      [
        "sizeClass",
        "o-sklt__item--",
        l(() => n.size),
        l(() => !!n.size)
      ]
    );
    return (i, u) => e.active ? (f(), P("div", {
      key: 0,
      "data-oruga": "skeleton",
      class: M(s(t))
    }, [
      (f(!0), P(he, null, xe(e.count, (d) => (f(), P("div", {
        key: d,
        class: M(s(o)),
        style: _e(a.value)
      }, null, 6))), 128))
    ], 2)) : J("", !0);
  }
}), Po = {
  install(e) {
    Ae(e, Oo);
  }
}, al = /* @__PURE__ */ ye({
  isOruga: !0,
  name: "OSidebar",
  configField: "sidebar",
  inheritAttrs: !1,
  __name: "Sidebar",
  props: {
    /** Override existing theme classes completely */
    override: { type: Boolean, default: void 0 },
    /** Whether siedbar is active or not, use v-model:active to make it two-way binding. */
    active: { type: Boolean, default: !1 },
    /**
     * Color of the sidebar
     * @values primary, info, success, warning, danger, and any other custom color
     */
    variant: {
      type: String,
      default: () => r("sidebar.variant")
    },
    /** Show an overlay like modal */
    overlay: { type: Boolean, default: r("sidebar.overlay", !1) },
    /** Display the Sidebear inline */
    inline: { type: Boolean, default: !1 },
    /**
     * Sidebar position
     * @values top, right, bottom, left
     */
    position: {
      type: String,
      default: () => r("sidebar.position", "left")
    },
    /** Show sidebar in fullheight */
    fullheight: {
      type: Boolean,
      default: r("sidebar.fullheight", !1)
    },
    /** Show sidebar in fullwidth */
    fullwidth: {
      type: Boolean,
      default: r("sidebar.fullwidth", !1)
    },
    /** Show a small sidebar */
    reduce: { type: Boolean, default: r("sidebar.reduce", !1) },
    /**
     * Custom layout on mobile
     * @values fullwidth, reduced, hidden
     */
    mobile: {
      type: String,
      default: r("sidebar.mobile"),
      validator: (e) => ["fullwidth", "reduced", "hidden"].indexOf(e) >= 0
    },
    /** Expand sidebar on hover when reduced or mobile is reduce */
    expandOnHover: {
      type: Boolean,
      default: r("sidebar.expandOnHover", !1)
    },
    /** Custom animation (transition name) */
    animation: {
      type: String,
      default: () => r("sidebar.animation")
    },
    /**
     * Is Sidebar cancleable by pressing escape or clicking outside.
     * @values escape, outside, true, false
     */
    cancelable: {
      type: [Array, Boolean],
      default: () => r("sidebar.cancelable", ["escape", "outside"])
    },
    /** Callback function to call after user canceled (pressed escape / clicked outside) */
    onCancel: { type: Function, default: () => {
    } },
    /** Callback function to call after close (programmatically close or user canceled) */
    onClose: { type: Function, default: () => {
    } },
    /**
     * Use `clip` to remove the body scrollbar, `keep` to have a non scrollable scrollbar to avoid shifting background,
     * but will set body to position fixed, might break some layouts.
     * @values keep, clip
     */
    scroll: {
      type: String,
      default: () => r("sidebar.scroll", "clip"),
      validator: (e) => ["clip", "keep"].indexOf(e) >= 0
    },
    /** Destroy sidebar on hide */
    destroyOnHide: {
      type: Boolean,
      default: () => r("sidebar.destroyOnHide", !1)
    },
    /** Mobile breakpoint as max-width value */
    mobileBreakpoint: {
      type: String,
      default: () => r("sidebar.mobileBreakpoint")
    },
    /**
     * Append the component to another part of the DOM.
     * Set `true` to append the component to the body.
     * In addition, any CSS selector string or an actual DOM node can be used.
     */
    teleport: {
      type: [Boolean, String, Object],
      default: () => r("sidebar.teleport", !1)
    },
    /**
     * Component to be injected, used to open a component sidebar programmatically.
     * Close sidebar within the component by emitting a 'close' event — emits('close')
     */
    component: {
      type: [Object, Function],
      default: void 0
    },
    /** Props to be binded to the injected component. */
    props: { type: Object, default: void 0 },
    /** Events to be binded to the injected component. */
    events: { type: Object, default: () => ({}) },
    /** DOM element where the sidebar component will be created on (for programmatic usage). */
    container: {
      type: [Object, String],
      default: () => r("sidebar.container", "body")
    },
    /**
     * This is used internally for programmatic usage.
     * @ignore
     */
    programmatic: {
      type: Object,
      default: void 0
    },
    /**
     * This is used internally for programmatic usage.
     * @ignore
     */
    promise: { type: Promise, default: void 0 },
    // class props (will not be displayed in the docs)
    /** Class of the root element */
    rootClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of sidebar component when its active */
    activeClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of sidebar when teleported */
    teleportClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the sidebar overlay */
    overlayClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the sidebar content */
    contentClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the sidebar position */
    positionClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the sidebar when is fullheight */
    fullheightClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the sidebar when is fullwidth */
    fullwidthClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the sidebar when its inlined */
    inlineClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the sidebar when reduced */
    reduceClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the sidebar when expanded on hover */
    expandOnHoverClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the sidebar variant */
    variantClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of sidebar component when on mobile */
    mobileClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the body when sidebar clipped */
    crollClipClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the body when sidebar is not clipped */
    noScrollClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the sidebar content when sidebar is hidden */
    hiddenClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the sidebar content when sidebar is visible */
    visibleClass: {
      type: [String, Array, Function],
      default: void 0
    }
  },
  emits: ["update:active", "close"],
  setup(e, { expose: n, emit: a }) {
    const t = e, o = a, i = L(), u = L(), { isActive: d, close: m, cancel: c } = Jt(
      i,
      t,
      o,
      {
        destroyOnHide: t.destroyOnHide,
        cancelOptions: r("sidebar.cancelable", ["escape", "outside"])
      }
    ), { isMobile: v } = ct(t.mobileBreakpoint), p = L(null), C = L(!t.active);
    ce(d, (G) => {
      t.overlay && R(), G ? I() : k();
    });
    const B = l(
      () => typeof t.teleport == "boolean" ? { to: "body", disabled: !t.teleport } : { to: t.teleport, disabled: !1 }
    ), A = l(() => {
      if (t.animation)
        return t.animation;
      const G = t.position === "top" || t.position === "bottom";
      return (t.position === "right" ? !d.value : d.value) ? G ? "slide-down" : "slide-next" : G ? "slide-up" : "slide-prev";
    }), g = l(
      () => t.mobile === "hidden" && v.value
    );
    st(() => {
      t.active && I();
    }), It(() => {
      if (k(), Be && t.overlay) {
        const G = p.value ? p.value : document.documentElement.scrollTop;
        W.value && (document.body.classList.remove(...W.value), document.documentElement.classList.remove(...W.value)), document.documentElement.scrollTop = G, document.body.style.top = null;
      }
    });
    let y = null;
    function I() {
      Be && !t.overlay && (y = fa(u, z));
    }
    function k() {
      y !== null && y();
    }
    function z(G) {
      t.inline || !d.value || C.value || ((t.overlay || !G.composedPath().includes(u.value)) && G.preventDefault(), c("outside"));
    }
    function R() {
      var G;
      if (Be) {
        if (t.scroll === "clip") {
          (G = W.value) != null && G.length && (d.value ? document.documentElement.classList.add(...W.value) : document.documentElement.classList.remove(...W.value));
          return;
        }
        if (p.value = p.value ? p.value : document.documentElement.scrollTop, W.value && (d.value ? document.body.classList.add(...W.value) : document.body.classList.remove(...W.value)), d.value) {
          document.body.style.top = `-${p.value}px`;
          return;
        }
        document.documentElement.scrollTop = p.value, document.body.style.top = null, p.value = null;
      }
    }
    function H() {
      C.value = !1;
    }
    function j() {
      C.value = !0;
    }
    const U = h(
      ["rootClass", "o-side"],
      ["mobileClass", "o-side--mobile", null, v],
      ["activeClass", "o-side--active", null, d],
      [
        "teleportClass",
        "o-side--teleport",
        null,
        l(() => !!t.teleport)
      ],
      ["inlineClass", "o-side--inline", null, l(() => t.inline)]
    ), Q = h(["overlayClass", "o-side__overlay"]), V = h(
      ["contentClass", "o-side__content"],
      [
        "variantClass",
        "o-side__content--",
        l(() => t.variant),
        l(() => !!t.variant)
      ],
      [
        "positionClass",
        "o-side__content--",
        l(() => t.position),
        l(() => !!t.position)
      ],
      [
        "fullheightClass",
        "o-side__content--fullheight",
        null,
        l(() => t.fullheight)
      ],
      [
        "fullwidthClass",
        "o-side__content--fullwidth",
        null,
        l(
          () => t.fullwidth || t.mobile === "fullwidth" && v.value
        )
      ],
      [
        "reduceClass",
        "o-side__content--reduced",
        null,
        l(
          () => t.reduce || t.mobile === "reduced" && v.value
        )
      ],
      [
        "expandOnHoverClass",
        "o-side__content--reduced-expand",
        null,
        l(
          () => t.expandOnHover && (!v.value || t.mobile !== "fullwidth")
        )
      ],
      ["visibleClass", "o-side__content--visible", null, d],
      [
        "hiddenClass",
        "o-side__content--hidden",
        null,
        l(() => !d.value)
      ]
    ), b = h(["scrollClipClass", "o-clipped"]), D = h(["noScrollClass", "o-noscroll"]), W = l(
      () => Ee(
        t.scroll === "clip" ? b.value : D.value
      )
    );
    return W.value, n({ close: m, promise: t.promise }), (G, E) => (f(), ne(ua, {
      to: B.value.to,
      disabled: B.value.disabled
    }, [
      $e(le("div", be({
        ref_key: "rootRef",
        ref: i
      }, G.$attrs, {
        class: s(U),
        "data-oruga": "sidebar"
      }), [
        e.overlay && s(d) ? (f(), P("div", {
          key: 0,
          class: M(s(Q)),
          tabindex: -1,
          "aria-hidden": "true",
          onClick: E[0] || (E[0] = (S) => z(S))
        }, null, 2)) : J("", !0),
        me(et, {
          name: A.value,
          onAfterEnter: H,
          onBeforeLeave: j
        }, {
          default: se(() => [
            $e(le("div", {
              ref_key: "sidebarContent",
              ref: u,
              class: M(s(V))
            }, [
              _(G.$slots, "default", { close: s(m) }, () => [
                e.component ? (f(), ne(Ge(e.component), be({ key: 0 }, G.$props.props, ca(G.$props.events), { onClose: s(m) }), null, 16, ["onClose"])) : J("", !0)
              ])
            ], 2), [
              [ze, s(d)]
            ])
          ]),
          _: 3
        }, 8, ["name"])
      ], 16), [
        [ze, !g.value]
      ])
    ], 8, ["to", "disabled"]));
  }
}), Ma = new Qt(), Mo = {
  open(e) {
    const a = yt({
      programmatic: { instances: Ma },
      active: !0
      // set the active state to true
    }, e);
    a.promise = new Promise((i, u) => {
      a.programmatic.resolve = i, a.programmatic.reject = u;
    });
    const t = zt, o = me(al, a);
    return o.appContext = t._context, Xt(o, document.createElement("div")), o.component.exposed;
  },
  closeAll(...e) {
    Ma.walk((n) => n.exposed.close(...e));
  }
}, Ro = Mo, Vo = {
  install(e) {
    Ae(e, al), Ht(e, "sidebar", Ro);
  }
}, ll = /* @__PURE__ */ ye({
  isOruga: !0,
  name: "OTooltip",
  configField: "tooltip",
  __name: "Tooltip",
  props: {
    /** Override existing theme classes completely */
    override: { type: Boolean, default: void 0 },
    /** Whether tooltip is active or not, use v-model:active to make it two-way binding */
    active: { type: Boolean, default: !1 },
    /** Tooltip text, unnecessary when content slot is used */
    label: { type: String, default: void 0 },
    /**
     * Color of the tooltip
     * @values primary, info, success, warning, danger, and any other custom color
     */
    variant: {
      type: String,
      default: () => r("tooltip.variant")
    },
    /**
     * Position of the Tooltip relative to the trigger
     * @values auto, top, bottom, left, right, top-right, top-left, bottom-left, bottom-right
     */
    position: {
      type: String,
      default: () => r("tooltip.position", "auto"),
      validator: (e) => [
        "auto",
        "top",
        "bottom",
        "left",
        "right",
        "top-right",
        "top-left",
        "bottom-left",
        "bottom-right"
      ].indexOf(e) > -1
    },
    /** Tooltip will be always active */
    always: { type: Boolean, default: !1 },
    /** Tooltip will be disabled */
    disabled: { type: Boolean, default: !1 },
    /** Tooltip default animation */
    animation: {
      type: String,
      default: () => r("tooltip.animation", "fade")
    },
    /** Tooltip will be multilined */
    multiline: { type: Boolean, default: !1 },
    /** Tooltip trigger tag name */
    triggerTag: {
      type: [String, Object, Function],
      default: () => r("tooltip.triggerTag", "div")
    },
    /**
     * Tooltip trigger events
     * @values hover, click, focus, contextmenu
     */
    triggers: {
      type: Array,
      default: () => r("tooltip.triggers", ["hover"]),
      validator: (e) => e.filter(
        (n) => ["click", "hover", "contextmenu", "focus"].indexOf(n) > -1
      ).length === e.length
    },
    /** Tooltip delay before it appears (number in ms) */
    delay: { type: Number, default: void 0 },
    /**
     * Tooltip auto close options (pressing escape, clicking the content or outside)
     * @values true, false, content, outside, escape
     */
    closeable: {
      type: [Array, Boolean],
      default: () => r("tooltip.closeable", ["escape", "outside", "content"])
    },
    /**
     * Append the component to another part of the DOM.
     * Set `true` to append the component to the body.
     * In addition, any CSS selector string or an actual DOM node can be used.
     */
    teleport: {
      type: [Boolean, String, Object],
      default: () => r("dropdown.teleport", !1)
    },
    // class props (will not be displayed in the docs)
    /** Class of the root element */
    rootClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class when the dropdown is teleported */
    teleportClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the tooltip content */
    contentClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the tooltip trigger position */
    positionClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the tooltip trigger */
    triggerClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the tooltip content when is multiline */
    multilineClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the tooltip trigger when is always visible */
    alwaysClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the tooltip variant */
    variantClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the tooltip arrow */
    arrowClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the tooltip arrow position */
    arrowPositionClass: {
      type: [String, Array, Function],
      default: void 0
    }
  },
  emits: ["update:active", "close", "open"],
  setup(e, { emit: n }) {
    const a = e, t = n, o = qe("active", a, t, {
      passive: !0
    });
    ce(o, (U) => {
      t(U ? "open" : "close");
    });
    const i = L(), u = L(a.position);
    ce(
      () => a.position,
      (U) => u.value = U
    );
    const d = L(), m = L(), c = L([]);
    ce(o, (U) => {
      U && Be ? setTimeout(() => {
        v.value.indexOf("outside") >= 0 && c.value.push(
          fa(d, p, [m])
        ), v.value.indexOf("escape") >= 0 && c.value.push(
          Ze("keyup", C, document, {
            immediate: !0
          })
        );
      }) : U || (c.value.forEach((Q) => Q()), c.value.length = 0);
    });
    const v = l(
      () => typeof a.closeable == "boolean" ? a.closeable ? ["escape", "outside", "content"] : [] : a.closeable
    );
    function p() {
      !o.value || a.always || v.value.indexOf("outside") < 0 || (o.value = !1);
    }
    function C(U) {
      if (o.value && (U.key === "Escape" || U.key === "Esc")) {
        if (v.value.indexOf("escape") < 0)
          return;
        o.value = !1;
      }
    }
    function B() {
      a.triggers.indexOf("click") < 0 || De(() => setTimeout(() => I()));
    }
    function A(U) {
      a.triggers.indexOf("contextmenu") < 0 || (U.preventDefault(), I());
    }
    function g() {
      a.triggers.indexOf("focus") < 0 || I();
    }
    function y() {
      a.triggers.indexOf("hover") < 0 || I();
    }
    function I() {
      a.disabled || (a.delay ? i.value = setTimeout(() => {
        o.value = !0, i.value = null;
      }, a.delay) : o.value = !0);
    }
    function k() {
      v.value.indexOf("content") < 0 || (o.value = !a.closeable, i.value && a.closeable && clearTimeout(i.value));
    }
    const z = h(
      ["rootClass", "o-tip"],
      [
        "teleportClass",
        "o-tip--teleport",
        null,
        l(() => !!a.teleport)
      ]
    ), R = h(["triggerClass", "o-tip__trigger"]), H = h(
      ["arrowClass", "o-tip__arrow"],
      [
        "arrowPositionClass",
        "o-tip__arrow--",
        u,
        l(() => !!u.value)
      ],
      [
        "variantArrowClass",
        "o-tip__arrow--",
        l(() => a.variant),
        l(() => !!a.variant)
      ]
    ), j = h(
      ["contentClass", "o-tip__content"],
      [
        "positionClass",
        "o-tip__content--",
        u,
        l(() => !!u.value)
      ],
      [
        "variantClass",
        "o-tip__content--",
        l(() => a.variant),
        l(() => !!a.variant)
      ],
      [
        "multilineClass",
        "o-tip__content--multiline",
        null,
        l(() => a.multiline)
      ],
      [
        "alwaysClass",
        "o-tip__content--always",
        null,
        l(() => a.always)
      ]
    );
    return (U, Q) => (f(), P("div", {
      class: M(s(z)),
      "data-oruga": "tooltip"
    }, [
      me(qa, {
        position: u.value,
        "onUpdate:position": Q[0] || (Q[0] = (V) => u.value = V),
        teleport: e.teleport,
        class: M(s(z)),
        trigger: m.value,
        content: d.value,
        "default-position": "top",
        disabled: !s(o)
      }, {
        default: se(() => [
          me(et, { name: e.animation }, {
            default: se(() => [
              $e(le("div", {
                ref_key: "contentRef",
                ref: d,
                class: M(s(j))
              }, [
                le("span", {
                  class: M(s(H))
                }, null, 2),
                _(U.$slots, "content", {}, () => [
                  Pe(ue(e.label), 1)
                ])
              ], 2), [
                [ze, s(o) || e.always && !e.disabled]
              ])
            ]),
            _: 3
          }, 8, ["name"])
        ]),
        _: 3
      }, 8, ["position", "teleport", "class", "trigger", "content", "disabled"]),
      (f(), ne(Ge(e.triggerTag), {
        ref_key: "triggerRef",
        ref: m,
        class: M(s(R)),
        "aria-haspopup": "true",
        onClick: B,
        onContextmenu: A,
        onMouseenter: y,
        onFocusCapture: g,
        onBlurCapture: k,
        onMouseleave: k
      }, {
        default: se(() => [
          _(U.$slots, "default", { active: s(o) })
        ]),
        _: 3
      }, 40, ["class"]))
    ], 2));
  }
}), To = ["tabindex", "aria-label", "aria-valuenow", "aria-valuemin", "aria-valuemax", "aria-disabled", "onKeydown"], Io = { key: 0 }, Ra = /* @__PURE__ */ ye({
  isOruga: !0,
  name: "OSliderThumb",
  configField: "slider",
  inheritAttrs: !1,
  __name: "SliderThumb",
  props: {
    /** parent slider component props  */
    sliderProps: { type: Object, required: !0 },
    modelValue: { type: Number, required: !0 },
    sliderSize: { type: Function, required: !0 },
    thumbWrapperClasses: {
      type: Array,
      required: !0
    },
    thumbClasses: {
      type: Array,
      required: !0
    }
  },
  emits: ["update:modelValue", "change", "dragstart", "dragend"],
  setup(e, { expose: n, emit: a }) {
    const t = e, o = a, i = l(() => t.sliderProps), u = L(!1), d = L(!1), m = L(0), c = L(0), v = L(null), p = L(t.modelValue), C = l(() => i.value.tooltip), B = l(() => i.value.tooltipAlways), A = l(() => i.value.disabled), g = l(() => i.value.max), y = l(() => i.value.min), I = l(() => i.value.step), k = l(() => i.value.indicator), z = l(
      () => Array.isArray(i.value.ariaLabel) ? i.value.ariaLabel[0] : i.value.ariaLabel
    ), R = l(() => {
      const O = [y.value, g.value, I.value].map((x) => {
        const K = ("" + x).split(".")[1];
        return K ? K.length : 0;
      });
      return Math.max(...O);
    }), H = l(
      () => i.value.tooltipVariant ? i.value.tooltipVariant : i.value.variant
    ), j = l(
      () => `${(t.modelValue - y.value) / (g.value - y.value) * 100}%`
    ), U = l(() => ({ left: j.value })), Q = l(() => typeof i.value.customFormatter < "u" ? i.value.customFormatter(t.modelValue) : i.value.format === "percent" ? new Intl.NumberFormat(i.value.locale, {
      style: "percent"
    }).format((t.modelValue - y.value) / (g.value - y.value)) : new Intl.NumberFormat(i.value.locale).format(t.modelValue));
    function V() {
      u.value = !0;
    }
    function b() {
      u.value = !1;
    }
    function D(O) {
      A.value || (O.preventDefault(), w(O), Be && (document.addEventListener("mousemove", $), document.addEventListener("touchmove", $), document.addEventListener("mouseup", N), document.addEventListener("touchend", N), document.addEventListener("contextmenu", N)));
    }
    function W() {
      A.value || t.modelValue === y.value || (v.value = parseFloat(j.value) - I.value / (g.value - y.value) * 100, ae(v.value), o("change"));
    }
    function G() {
      A.value || t.modelValue === g.value || (v.value = parseFloat(j.value) + I.value / (g.value - y.value) * 100, ae(v.value), o("change"));
    }
    function E() {
      A.value || t.modelValue === y.value || (v.value = 0, ae(v.value), o("change"));
    }
    function S() {
      A.value || t.modelValue === g.value || (v.value = 100, ae(v.value), o("change"));
    }
    function w(O) {
      d.value = !0, o("dragstart"), O.type === "touchstart" && (O.clientX = O.touches[0].clientX), m.value = O.clientX, c.value = parseFloat(j.value), v.value = c.value;
    }
    function $(O) {
      if (d.value) {
        O.type === "touchmove" && (O.clientX = O.touches[0].clientX);
        const x = (O.clientX - m.value) / t.sliderSize() * 100;
        v.value = c.value + x, ae(v.value);
      }
    }
    function N() {
      d.value = !1, o("dragend"), t.modelValue !== p.value && o("change"), ae(v.value), Be && (document.removeEventListener("mousemove", $), document.removeEventListener("touchmove", $), document.removeEventListener("mouseup", N), document.removeEventListener("touchend", N), document.removeEventListener("contextmenu", N));
    }
    function ae(O) {
      if (O === null || isNaN(O))
        return;
      O < 0 ? O = 0 : O > 100 && (O = 100);
      const x = 100 / ((g.value - y.value) / I.value);
      let ie = Math.round(O / x) * x / 100 * (g.value - y.value) + y.value;
      ie = parseFloat(ie.toFixed(R.value)), o("update:modelValue", ie), !d.value && ie !== p.value && (p.value = ie);
    }
    return n({ setPosition: ae }), (O, x) => (f(), P("div", {
      class: M(e.thumbWrapperClasses),
      style: _e(U.value),
      "data-oruga": "slider-thumb"
    }, [
      me(ll, {
        label: Q.value,
        variant: H.value,
        disabled: A.value || !C.value,
        always: B.value || d.value || u.value
      }, {
        default: se(() => [
          le("div", be(O.$attrs, {
            class: e.thumbClasses,
            tabindex: A.value ? null : 0,
            role: "slider",
            "aria-label": z.value,
            "aria-valuenow": e.modelValue,
            "aria-valuemin": y.value,
            "aria-valuemax": g.value,
            "aria-disabled": A.value,
            "aria-orientation": "horizontal",
            onMousedown: D,
            onTouchstart: D,
            onFocus: V,
            onBlur: b,
            onKeydown: [
              Ce(ve(W, ["prevent"]), ["left"]),
              Ce(ve(G, ["prevent"]), ["right"]),
              Ce(ve(W, ["prevent"]), ["down"]),
              Ce(ve(G, ["prevent"]), ["up"]),
              Ce(ve(E, ["prevent"]), ["home"]),
              Ce(ve(S, ["prevent"]), ["end"])
            ]
          }), [
            k.value ? (f(), P("span", Io, ue(Q.value), 1)) : J("", !0)
          ], 16, To)
        ]),
        _: 1
      }, 8, ["label", "variant", "disabled", "always"])
    ], 6));
  }
}), nl = /* @__PURE__ */ ye({
  isOruga: !0,
  name: "OSliderTick",
  configField: "slider",
  __name: "SliderTick",
  props: {
    /** Override existing theme classes completely */
    override: { type: Boolean, default: void 0 },
    /** Value of single tick */
    value: { type: Number, required: !0 },
    /** Tick label */
    label: { type: String, default: void 0 },
    tickClass: {
      type: [String, Function, Array],
      default: void 0
    },
    /** Class when slider tick is hidden */
    tickHiddenClass: {
      type: [String, Function, Array],
      default: void 0
    },
    /** Class of tick label */
    tickLabelClass: {
      type: [String, Function, Array],
      default: void 0
    }
  },
  setup(e) {
    const n = e, { parent: a } = gt(), t = l(() => {
      const m = (n.value - a.value.min) / (a.value.max - a.value.min) * 100;
      return m >= 0 && m <= 100 ? m : 0;
    }), o = l(
      () => n.value === a.value.min || n.value === a.value.max
    ), i = l(() => ({ left: t.value + "%" })), u = h(
      ["tickClass", "o-slide__tick"],
      ["tickHiddenClass", "o-slide__tick--hidden", null, o]
    ), d = h([
      "tickLabelClass",
      "o-slide__tick-label"
    ]);
    return (m, c) => (f(), P("div", {
      class: M(s(u)),
      style: _e(i.value),
      "data-oruga": "slider-tick"
    }, [
      m.$slots.default ? (f(), P("span", {
        key: 0,
        class: M(s(d))
      }, [
        _(m.$slots, "default", {}, () => [
          Pe(ue(e.label), 1)
        ])
      ], 2)) : J("", !0)
    ], 6));
  }
}), zo = /* @__PURE__ */ ye({
  isOruga: !0,
  name: "OSlider",
  configField: "slider",
  __name: "Slider",
  props: {
    /** Override existing theme classes completely */
    override: { type: Boolean, default: void 0 },
    /** @model */
    modelValue: {
      type: [Number, Array],
      default: 0
    },
    /** Minimum value */
    min: { type: Number, default: 0 },
    /** Maximum  value */
    max: { type: Number, default: 100 },
    /** Step interval of ticks */
    step: { type: Number, default: 1 },
    /**
     * Color of the slider
     * @values primary, info, success, warning, danger, and any other custom color
     */
    variant: {
      type: String,
      default: () => r("slider.variant")
    },
    /**
     * Vertical size of slider
     * @values small, medium, large
     */
    size: {
      type: String,
      default: () => r("slider.size")
    },
    /** Show tick marks */
    ticks: { type: Boolean, default: !1 },
    /** Show tooltip when thumb is being dragged */
    tooltip: {
      type: Boolean,
      default: () => r("slider.tooltip", !0)
    },
    /**
     * Color of the tooltip
     * @values primary, info, success, warning, danger, and any other custom color
     */
    tooltipVariant: {
      type: String,
      default: () => r("slider.tooltipVariant")
    },
    /** Tooltip displays always */
    tooltipAlways: { type: Boolean, default: !1 },
    /** Rounded thumb */
    rounded: {
      type: Boolean,
      default: () => r("slider.rounded", !1)
    },
    /** Slider will be disabled */
    disabled: { type: Boolean, default: !1 },
    /** Update v-model only when dragging is finished */
    lazy: { type: Boolean, default: !1 },
    /** Function to format the tooltip label for display */
    customFormatter: { type: Function, default: void 0 },
    /** Increases slider size on focus */
    biggerSliderFocus: { type: Boolean, default: !1 },
    /** Show indicators */
    indicator: { type: Boolean, default: !1 },
    /**
     * Define v-model format
     * @values row, percent
     */
    format: {
      type: String,
      default: () => r("slider.format", "raw"),
      validator: (e) => ["raw", "percent"].indexOf(e) >= 0
    },
    /** Date format locale */
    locale: {
      type: [String, Array],
      default: () => r("locale")
    },
    /** Accessibility aria-label to to be passed to the slider thumb element. */
    ariaLabel: {
      type: [String, Array],
      default: () => r("slider.ariaLabel")
    },
    // class props (will not be displayed in the docs)
    /** Class of the root element */
    rootClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the vertical slider size */
    sizeClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the slider track */
    trackClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the filled part of the slider */
    fillClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class when the slider is rounded */
    thumbRoundedClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class when the thumb gets dragged */
    thumbDraggingClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class when slider is disabled */
    disabledClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the thumb wrapper */
    thumbWrapperClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the thumb */
    thumbClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the slider variant */
    variantClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of slider tick */
    tickClass: {
      type: [String, Function, Array],
      default: void 0
    },
    /** Class when slider tick is hidden */
    tickHiddenClass: {
      type: [String, Function, Array],
      default: void 0
    },
    /** Class of tick label */
    tickLabelClass: {
      type: [String, Function, Array],
      default: void 0
    },
    /** Class to display on the wrapper element when the slider is dragged */
    thumbWrapperDraggingClass: {
      type: [String, Function, Array],
      default: void 0
    }
  },
  emits: ["update:modelValue", "change", "dragging", "dragstart", "dragend"],
  setup(e, { emit: n }) {
    const a = e, t = n;
    function o(w) {
      const $ = C.value ? [y.value, I.value] : c.value || 0;
      t(w, $);
    }
    const i = l(() => ({
      max: a.max,
      min: a.min
    }));
    bt(void 0, { data: i });
    const u = L(), d = L(), m = L(), c = L(null), v = L(null), p = L(!1), C = L(!1), B = L(), A = L();
    H(a.modelValue), ce([c, v], () => j()), ce(
      [() => a.min, () => a.max, () => a.modelValue],
      () => H(a.modelValue)
    );
    const g = l(() => {
      if (!a.ticks || a.min > a.max || a.step === 0)
        return [];
      const w = [];
      for (let $ = a.min + a.step; $ < a.max; $ = $ + a.step)
        w.push($);
      return w;
    }), y = l(() => Math.min(c.value, v.value)), I = l(() => Math.max(c.value, v.value)), k = l(
      () => C.value ? `${100 * (I.value - y.value) / (a.max - a.min)}%` : `${100 * (c.value - a.min) / (a.max - a.min)}%`
    ), z = l(
      () => C.value ? `${100 * (y.value - a.min) / (a.max - a.min)}%` : "0%"
    ), R = l(() => ({
      width: k.value,
      left: z.value
    }));
    function H(w) {
      if (!(a.min > a.max))
        if (Array.isArray(w)) {
          C.value = !0;
          const $ = typeof w[0] != "number" || isNaN(w[0]) ? a.min : Math.min(Math.max(a.min, w[0]), a.max), N = typeof w[1] != "number" || isNaN(w[1]) ? a.max : Math.max(Math.min(a.max, w[1]), a.min);
          c.value = B.value ? N : $, v.value = B.value ? $ : N;
        } else
          C.value = !1, c.value = isNaN(w) ? a.min : Math.min(a.max, Math.max(a.min, w)), v.value = null;
    }
    function j() {
      C.value && (B.value = c.value > v.value), (!a.lazy || !p.value) && o("update:modelValue"), p.value && o("dragging");
    }
    function U() {
      return u.value.getBoundingClientRect().width;
    }
    function Q(w) {
      if (a.disabled || A.value)
        return;
      const $ = u.value.getBoundingClientRect().left, N = (w.clientX - $) / U() * 100, ae = a.min + N * (a.max - a.min) / 100, O = Math.abs(ae - c.value);
      if (C.value) {
        const x = Math.abs(ae - v.value);
        if (O <= x) {
          if (O < a.step / 2)
            return;
          d.value.setPosition(N);
        } else {
          if (x < a.step / 2)
            return;
          m.value.setPosition(N);
        }
      } else {
        if (O < a.step / 2)
          return;
        d.value.setPosition(N);
      }
      o("change");
    }
    function V() {
      p.value = !0, t("dragstart");
    }
    function b() {
      A.value = !0, setTimeout(() => A.value = !1), p.value = !1, t("dragend"), a.lazy && o("update:modelValue");
    }
    const D = h(
      ["rootClass", "o-slide"],
      [
        "sizeClass",
        "o-slide--",
        l(() => a.size),
        l(() => !!a.size)
      ],
      [
        "disabledClass",
        "o-slide--disabled",
        null,
        l(() => a.disabled)
      ]
    ), W = h(["trackClass", "o-slide__track"]), G = h(
      ["fillClass", "o-slide__fill"],
      [
        "variantClass",
        "o-slide__fill--",
        l(() => a.variant),
        l(() => !!a.variant)
      ]
    ), E = h(
      ["thumbClass", "o-slide__thumb"],
      ["thumbDraggingClass", "o-slide__thumb--dragging", null, p],
      [
        "thumbRoundedClass",
        "o-slide__thumb--rounded",
        null,
        l(() => a.rounded)
      ]
    ), S = h(
      ["thumbWrapperClass", "o-slide__thumb-wrapper"],
      [
        "thumbWrapperDraggingClass",
        "o-slide__thumb-wrapper--dragging",
        null,
        p
      ]
    );
    return (w, $) => (f(), P("div", {
      class: M(s(D)),
      "data-oruga": "slider",
      onClick: Q
    }, [
      le("div", {
        ref_key: "sliderRef",
        ref: u,
        class: M(s(W))
      }, [
        le("div", {
          class: M(s(G)),
          style: _e(R.value)
        }, null, 6),
        e.ticks ? (f(!0), P(he, { key: 0 }, xe(g.value, (N, ae) => (f(), ne(nl, {
          key: ae,
          value: N,
          "tick-class": e.tickClass,
          "tick-hidden-class": e.tickHiddenClass,
          "tick-label-class": e.tickLabelClass
        }, null, 8, ["value", "tick-class", "tick-hidden-class", "tick-label-class"]))), 128)) : J("", !0),
        _(w.$slots, "default"),
        me(Ra, {
          ref_key: "thumbStartRef",
          ref: d,
          modelValue: c.value,
          "onUpdate:modelValue": $[0] || ($[0] = (N) => c.value = N),
          "slider-props": a,
          "slider-size": U,
          "thumb-classes": s(E),
          "thumb-wrapper-classes": s(S),
          onChange: $[1] || ($[1] = (N) => o("change")),
          onDragstart: V,
          onDragend: b
        }, null, 8, ["modelValue", "slider-props", "thumb-classes", "thumb-wrapper-classes"]),
        C.value ? (f(), ne(Ra, {
          key: 1,
          ref_key: "thumbEndRef",
          ref: m,
          modelValue: v.value,
          "onUpdate:modelValue": $[2] || ($[2] = (N) => v.value = N),
          "slider-props": a,
          "slider-size": U,
          "thumb-classes": s(E),
          "thumb-wrapper-classes": s(S),
          onChange: $[3] || ($[3] = (N) => o("change")),
          onDragstart: V,
          onDragend: b
        }, null, 8, ["modelValue", "slider-props", "thumb-classes", "thumb-wrapper-classes"])) : J("", !0)
      ], 2)
    ], 2));
  }
}), Ho = {
  install(e) {
    Ae(e, zo), Ae(e, nl);
  }
}, Lo = ["aria-orientation"], No = ["aria-selected"], Eo = { key: 1 }, jo = /* @__PURE__ */ ye({
  isOruga: !0,
  name: "OSteps",
  configField: "steps",
  __name: "Steps",
  props: /* @__PURE__ */ Ue({
    /** Override existing theme classes completely */
    override: { type: Boolean, default: void 0 },
    /** @model */
    modelValue: { type: [String, Number], default: void 0 },
    /**
     * Color of the control
     * @values primary, info, success, warning, danger, and any other custom color
     */
    variant: {
      type: String,
      default: () => r("steps.variant")
    },
    /**
     * Tab size
     * @values small, medium, large
     */
    size: {
      type: String,
      default: () => r("steps.size")
    },
    /** Show tab in vertical layout */
    vertical: { type: Boolean, default: !1 },
    /**
     * Position of the tab
     * @values left, centered, right
     */
    position: {
      type: String,
      default: void 0,
      validator: (e) => ["left", "centered", "right"].indexOf(e) >= 0
    },
    /**
     * Icon pack to use for the navigation
     * @values mdi, fa, fas and any other custom icon pack
     */
    iconPack: {
      type: String,
      default: () => r("steps.iconPack")
    },
    /** Icon to use for navigation button */
    iconPrev: {
      type: String,
      default: () => r("steps.iconPrev", "chevron-left")
    },
    /** Icon to use for navigation button */
    iconNext: {
      type: String,
      default: () => r("steps.iconNext", "chevron-right")
    },
    /**
     * Next and previous buttons below the component. You can use this property if you want to use your own custom navigation items.
     */
    hasNavigation: { type: Boolean, default: !0 },
    /** Step navigation is animated */
    animated: {
      type: Boolean,
      default: () => r("steps.animated", !0)
    },
    /**
     * Transition animation name
     * @values [next, prev], [right, left, down, up]
     */
    animation: {
      type: Array,
      default: () => r("tabs.animation", [
        "slide-next",
        "slide-prev",
        "slide-down",
        "slide-up"
      ]),
      validator: (e) => e.length === 2 || e.length === 4
    },
    /** Apply animation on the initial render */
    animateInitially: {
      type: Boolean,
      default: () => r("steps.animateInitially", !1)
    },
    /**
     * Position of the marker label
     * @values bottom, right, left
     */
    labelPosition: {
      type: String,
      default: () => r("steps.labelPosition", "bottom"),
      validator: (e) => ["bottom", "right", "left"].indexOf(e) > -1
    },
    /** Rounded step markers */
    rounded: { type: Boolean, default: !0 },
    /** Mobile breakpoint as max-width value */
    mobileBreakpoint: {
      type: String,
      default: () => r("steps.mobileBreakpoint")
    },
    /** Accessibility next button aria label */
    ariaNextLabel: {
      type: String,
      default: () => r("steps.ariaNextLabel")
    },
    /** Accessibility previous button aria label  */
    ariaPreviousLabel: {
      type: String,
      default: () => r("steps.ariaPreviousLabel")
    },
    // class props (will not be displayed in the docs)
    /** Class of the root element */
    rootClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Size of the steps */
    sizeClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the tooltip trigger */
    verticalClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the Steps component when is vertical and its position changes */
    positionClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the steps container */
    stepsClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of Steps component when animation gets triggered */
    animatedClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the Steps markers trigger when are rounded */
    stepMarkerRoundedClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the Steps component dividers */
    stepDividerClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the Steps component marker */
    stepMarkerClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the Steps component content */
    stepContentClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the Steps component content when transition is happening */
    stepContentTransitioningClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the Steps component navigation element */
    stepNavigationClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the Steps component link */
    stepLinkClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the Steps component link when clickable */
    stepLinkClickableClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the Step component link label */
    stepLinkLabelClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the Step component link label when positioned */
    stepLinkLabelPositionClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of steps component when on mobile */
    mobileClass: {
      type: [String, Array, Function],
      default: void 0
    }
  }, {
    modelValue: {},
    modelModifiers: {}
  }),
  emits: /* @__PURE__ */ Ue(["update:modelValue", "change"], ["update:modelValue"]),
  setup(e, { emit: n }) {
    const a = e, t = n, { isMobile: o } = ct(a.mobileBreakpoint), i = L(), u = l(() => ({
      activeValue: c.value,
      vertical: a.vertical,
      animated: a.animated,
      animation: a.animation,
      animateInitially: a.animateInitially
    })), { sortedItems: d } = bt(i, {
      data: u
    }), m = l(
      () => d.value.map((E) => ({
        index: E.index,
        identifier: E.identifier,
        ...pt(E.data)
      }))
    ), c = it(e, "modelValue");
    ce(
      () => a.modelValue,
      (E) => {
        c.value !== E && R(E);
      }
    );
    const v = l(
      () => ot(c.value) && m.value.find((E) => E.value === c.value) || m.value[0]
    ), p = l(
      () => m.value.some((E) => E.isTransitioning)
    ), C = l(() => !!A.value), B = l(() => !!g.value), A = l(() => {
      if (!v.value)
        return null;
      let E = null;
      for (let S = m.value.indexOf(v.value) - 1; S >= 0; S--)
        if (m.value[S].visible) {
          E = m.value[S];
          break;
        }
      return E;
    }), g = l(() => {
      let E = null, S = v.value ? m.value.indexOf(v.value) + 1 : 0;
      for (; S < m.value.length; S++)
        if (m.value[S].visible) {
          E = m.value[S];
          break;
        }
      return E;
    });
    function y(E) {
      var S;
      return E.clickable === void 0 ? E.index < ((S = v.value) == null ? void 0 : S.index) : E.clickable;
    }
    function I() {
      C.value && z(A.value);
    }
    function k() {
      B.value && z(g.value);
    }
    function z(E) {
      c.value !== E.value && R(E.value);
    }
    function R(E) {
      const S = v.value.value, w = v.value, $ = m.value.find((N) => N.value === E) || m.value[0];
      w && $ && (w.deactivate($.index), $.activate(w.index)), De(() => {
        c.value = E, t("change", E, S);
      });
    }
    const H = h(
      ["rootClass", "o-steps__wrapper"],
      [
        "sizeClass",
        "o-steps--",
        l(() => a.size),
        l(() => !!a.size)
      ],
      [
        "verticalClass",
        "o-steps__wrapper-vertical",
        null,
        l(() => a.vertical)
      ],
      [
        "positionClass",
        "o-steps__wrapper-position-",
        l(() => a.position),
        l(() => a.position && a.vertical)
      ],
      ["mobileClass", "o-steps--mobile", null, o]
    ), j = h(
      ["stepsClass", "o-steps"],
      [
        "animatedClass",
        "o-steps--animated",
        null,
        l(() => a.animated)
      ]
    ), U = h([
      "stepDividerClass",
      "o-steps__divider"
    ]), Q = h(
      ["stepMarkerClass", "o-steps__marker"],
      [
        "stepMarkerRoundedClass",
        "o-steps__marker--rounded",
        null,
        l(() => a.rounded)
      ]
    ), V = h(
      ["stepContentClass", "o-steps__content"],
      [
        "stepContentTransitioningClass",
        "o-steps__content-transitioning",
        null,
        p
      ]
    ), b = h([
      "stepNavigationClass",
      "o-steps__navigation"
    ]), D = h([
      "stepLinkLabelClass",
      "o-steps__title"
    ]);
    function W(E) {
      return h(
        ["stepLinkClass", "o-steps__link"],
        [
          "stepLinkLabelPositionClass",
          "o-steps__link-label-",
          a.labelPosition,
          !!a.labelPosition
        ],
        [
          "stepLinkClickableClass",
          "o-steps__link-clickable",
          null,
          y(E)
        ]
      ).value;
    }
    function G(E) {
      const S = h(
        ["itemHeaderClass", "o-steps__nav-item"],
        [
          "itemHeaderVariantClass",
          "o-steps__nav-item--",
          E.variant || a.variant,
          !!E.variant || !!a.variant
        ],
        [
          "itemHeaderActiveClass",
          "o-steps__nav-item-active",
          null,
          E.value === v.value.value
        ],
        [
          "itemHeaderPreviousClass",
          "o-steps__nav-item-previous",
          null,
          v.value.index > E.index
        ]
      );
      return [{ [E.headerClass || ""]: !0 }, ...S.value];
    }
    return (E, S) => (f(), P("div", {
      class: M(s(H)),
      "data-oruga": "steps"
    }, [
      le("ol", {
        class: M(s(j)),
        "aria-orientation": e.vertical ? "vertical" : "horizontal"
      }, [
        (f(!0), P(he, null, xe(m.value, (w, $) => $e((f(), P("li", {
          key: w.value,
          class: M(G(w)),
          "aria-selected": w.value === v.value.value
        }, [
          $ > 0 ? (f(), P("span", {
            key: 0,
            class: M(s(U))
          }, null, 2)) : J("", !0),
          (f(), ne(Ge(w.tag), {
            role: "button",
            tabindex: y(w) ? 0 : null,
            class: M(W(w)),
            onClick: (N) => y(w) && z(w),
            onKeydown: Ce((N) => y(w) && z(w), ["enter"])
          }, {
            default: se(() => [
              le("div", {
                class: M(s(Q))
              }, [
                w.icon ? (f(), ne(Re, {
                  key: 0,
                  icon: w.icon,
                  pack: w.iconPack,
                  size: e.size
                }, null, 8, ["icon", "pack", "size"])) : w.step ? (f(), P("span", Eo, ue(w.step), 1)) : J("", !0)
              ], 2),
              le("div", {
                class: M(s(D))
              }, ue(w.label), 3)
            ]),
            _: 2
          }, 1064, ["tabindex", "class", "onClick", "onKeydown"]))
        ], 10, No)), [
          [ze, w.visible]
        ])), 128))
      ], 10, Lo),
      le("section", {
        class: M(s(V))
      }, [
        _(E.$slots, "default")
      ], 2),
      _(E.$slots, "navigation", {
        previous: { disabled: !C.value, action: I },
        next: { disabled: !B.value, action: k }
      }, () => [
        e.hasNavigation ? (f(), P("nav", {
          key: 0,
          class: M(s(b))
        }, [
          me(wt, {
            role: "button",
            "icon-left": e.iconPrev,
            "icon-pack": e.iconPack,
            "icon-both": "",
            disabled: !C.value,
            "aria-label": e.ariaPreviousLabel,
            onClick: ve(I, ["prevent"])
          }, null, 8, ["icon-left", "icon-pack", "disabled", "aria-label"]),
          me(wt, {
            role: "button",
            "icon-left": e.iconNext,
            "icon-pack": e.iconPack,
            "icon-both": "",
            disabled: !B.value,
            "aria-label": e.ariaNextLabel,
            onClick: ve(k, ["prevent"])
          }, null, 8, ["icon-left", "icon-pack", "disabled", "aria-label"])
        ], 2)) : J("", !0)
      ])
    ], 2));
  }
}), Wo = ["data-id", "tabindex", "role"], Yo = /* @__PURE__ */ ye({
  isOruga: !0,
  name: "OStepItem",
  configField: "steps",
  __name: "StepItem",
  props: {
    /** Override existing theme classes completely */
    override: { type: Boolean, default: void 0 },
    /** Item value (it will be used as v-model of wrapper component) */
    value: { type: [String, Number], default: () => Ye() },
    /** Item label */
    label: { type: String, default: void 0 },
    /** Step marker content (when there is no icon) */
    step: { type: [String, Number], default: void 0 },
    /**
     * Default style for the step.
     * This will override parent type.
     * Could be used to set a completed step to "success" for example
     */
    variant: { type: String, default: void 0 },
    /**
     * Item can be used directly to navigate.
     * If undefined, previous steps are clickable while the others are not
     */
    clickable: { type: Boolean, default: void 0 },
    /** Show/hide item */
    visible: { type: Boolean, default: !0 },
    /** Icon on the left */
    icon: {
      type: String,
      default: () => r("steps.icon")
    },
    /** Icon pack */
    iconPack: {
      type: String,
      default: () => r("steps.iconPack")
    },
    /** Step item tag name */
    tag: {
      type: [String, Object, Function],
      default: () => r("steps.itemTag", "button")
    },
    /** Role attribute to be passed to the div wrapper for better accessibility */
    ariaRole: {
      type: String,
      default: () => r("steps.ariaRole", "tab")
    },
    /** Sets a class to the item header */
    headerClass: { type: String, default: void 0 },
    // class props (will not be displayed in the docs)
    /** Class of the content item */
    itemClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the nav item */
    itemHeaderClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the nav item when active */
    itemHeaderActiveClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the nav item behind the active one */
    itemHeaderPreviousClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the nav item with variant (default value by parent steps component) */
    itemHeaderVariantClass: {
      type: [String, Array, Function],
      default: void 0
    }
  },
  emits: ["activate", "deactivate"],
  setup(e, { emit: n }) {
    const a = e, t = n, o = xt(), i = l(() => ({
      ...We(a),
      $slots: o,
      isTransitioning: v.value,
      activate: B,
      deactivate: A
    })), { parent: u, item: d } = gt({
      data: i
    }), m = L(), c = l(() => Tt(a.value, u.value.activeValue)), v = L(!1), p = l(() => {
      const k = u.value.vertical && u.value.animation.length === 4 ? 2 : 0;
      return u.value.animation[k];
    }), C = l(() => {
      const k = u.value.vertical && u.value.animation.length === 4 ? 3 : 1;
      return u.value.animation[k];
    });
    function B(k) {
      m.value = d.value.index < k ? p.value : C.value, t("activate");
    }
    function A(k) {
      m.value = k < d.value.index ? p.value : C.value, t("deactivate");
    }
    function g() {
      v.value = !0;
    }
    function y() {
      v.value = !0;
    }
    const I = h(["itemClass", "o-steps__item"]);
    return (k, z) => (f(), ne(et, {
      disabled: !s(u).animated,
      name: m.value,
      appear: s(u).animateInitially,
      onAfterEnter: g,
      onBeforeLeave: y
    }, {
      default: se(() => [
        $e(le("div", {
          ref: "rootRef",
          class: M(s(I)),
          "data-id": `steps-${s(d).identifier}`,
          "data-oruga": "steps-item",
          tabindex: c.value ? 0 : -1,
          role: e.ariaRole,
          "aria-roledescription": "item"
        }, [
          _(k.$slots, "default")
        ], 10, Wo), [
          [ze, c.value && e.visible]
        ])
      ]),
      _: 3
    }, 8, ["disabled", "name", "appear"]));
  }
}), Ko = {
  install(e) {
    Ae(e, jo), Ae(e, Yo);
  }
}, Uo = ["aria-checked"], qo = ["disabled", "required", "name", "autocomplete", "value", "true-value", "false-value", "aria-labelledby"], Xo = ["id"], Go = /* @__PURE__ */ ye({
  isOruga: !0,
  name: "OSwitch",
  configField: "switch",
  inheritAttrs: !1,
  __name: "Switch",
  props: {
    /** Override existing theme classes completely */
    override: { type: Boolean, default: void 0 },
    /** @model */
    modelValue: { type: [String, Number, Boolean], default: void 0 },
    /**
     * Color of the control
     * @values primary, info, success, warning, danger, and any other custom color
     */
    variant: {
      type: String,
      default: () => r("switch.variant")
    },
    /**
     * Color of the switch when is passive
     * @values primary, info, success, warning, danger, and any other custom color
     */
    passiveVariant: {
      type: String,
      default: () => r("switch.passiveVariant")
    },
    /**
     * Size of the control
     * @values small, medium, large
     */
    size: {
      type: String,
      default: () => r("switch.size")
    },
    /** Input label, unnecessary when default slot is used */
    label: { type: String, default: void 0 },
    /** Same as native value */
    nativeValue: { type: [String, Number, Boolean], default: void 0 },
    /** Same as native disabled */
    disabled: { type: Boolean, default: !1 },
    /** Same as native required */
    required: { type: Boolean, default: !1 },
    /** Name attribute on native checkbox */
    name: { type: String, default: void 0 },
    /** Overrides the returned value when it's checked */
    trueValue: { type: [String, Number, Boolean], default: !0 },
    /** Overrides the returned value when it's not checked */
    falseValue: { type: [String, Number, Boolean], default: !1 },
    /** Rounded style */
    rounded: { type: Boolean, default: !0 },
    /** Label position */
    position: { type: String, default: "right" },
    /** Accessibility label to establish relationship between the switch and control label' */
    ariaLabelledby: { type: String, default: () => Ye() },
    /** Same as native autocomplete options to use in HTML5 validation */
    autocomplete: {
      type: String,
      default: () => r("switch.autocomplete", "off")
    },
    /** Enable html 5 native validation */
    useHtml5Validation: {
      type: Boolean,
      default: () => r("useHtml5Validation", !0)
    },
    // class props (will not be displayed in the docs)
    /** Class of the root element */
    rootClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class when switch is disabled */
    disabledClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the outer switch check */
    switchClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the outer switch check when checked */
    switchCheckedClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the inner switch check */
    switchCheckClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the switch when rounded */
    roundedClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the switch passive variant */
    passiveVariantClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of switch label position */
    positionClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Root class of the native input checkbox */
    inputClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the native input element when checked */
    inputCheckedClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the switch label */
    labelClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the switch size */
    sizeClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the switch variant */
    variantClass: {
      type: [String, Array, Function],
      default: void 0
    }
  },
  emits: ["update:modelValue", "input", "focus", "blur", "invalid"],
  setup(e, { expose: n, emit: a }) {
    const t = e, o = a, i = L(), { onBlur: u, onFocus: d, onInvalid: m, setFocus: c } = rt(
      i,
      o,
      t
    ), v = dt(t, o, {
      passive: !0
    }), p = l(
      () => v.value === t.trueValue || Array.isArray(v.value) && v.value.includes(t.nativeValue)
    );
    function C(k) {
      o("input", v.value, k);
    }
    const B = h(
      ["rootClass", "o-switch"],
      [
        "sizeClass",
        "o-switch--",
        l(() => t.size),
        l(() => !!t.size)
      ],
      [
        "disabledClass",
        "o-switch--disabled",
        null,
        l(() => t.disabled)
      ],
      [
        "variantClass",
        "o-switch--",
        l(() => t.variant),
        l(() => !!t.variant)
      ],
      [
        "positionClass",
        "o-switch--",
        l(() => t.position),
        l(() => !!t.position)
      ],
      [
        "passiveVariantClass",
        "o-switch--",
        l(() => t.passiveVariant + "-passive"),
        l(() => !!t.passiveVariant)
      ]
    ), A = h(
      ["inputClass", "o-switch__input"],
      ["inputCheckedClass", "o-switch__input--checked", null, p]
    ), g = h(
      ["switchClass", "o-switch__check"],
      ["switchCheckedClass", "o-switch__check--checked", null, p],
      ["roundedClass", "o-switch--rounded", null, l(() => t.rounded)]
    ), y = h(
      ["switchCheckClass", "o-switch__check-switch"],
      ["roundedClass", "o-switch--rounded", null, l(() => t.rounded)]
    ), I = h(["labelClass", "o-switch__label"]);
    return n({ focus: c }), (k, z) => (f(), P("label", {
      ref: "label",
      class: M(s(B)),
      "data-oruga": "switch",
      role: "switch",
      "aria-checked": p.value,
      onClick: z[5] || (z[5] = //@ts-ignore
      (...R) => s(c) && s(c)(...R)),
      onKeydown: z[6] || (z[6] = Ce(ve(
        //@ts-ignore
        (...R) => s(c) && s(c)(...R),
        ["prevent"]
      ), ["enter"]))
    }, [
      $e(le("input", be(k.$attrs, {
        ref_key: "inputRef",
        ref: i,
        "onUpdate:modelValue": z[0] || (z[0] = (R) => Ke(v) ? v.value = R : null),
        type: "checkbox",
        role: "switch",
        "data-oruga-input": "switch",
        class: s(A),
        disabled: e.disabled,
        required: e.required,
        name: e.name,
        autocomplete: e.autocomplete,
        value: e.nativeValue,
        "true-value": e.trueValue,
        "false-value": e.falseValue,
        "aria-labelledby": e.ariaLabelledby,
        onClick: z[1] || (z[1] = ve(() => {
        }, ["stop"])),
        onBlur: z[2] || (z[2] = //@ts-ignore
        (...R) => s(u) && s(u)(...R)),
        onFocus: z[3] || (z[3] = //@ts-ignore
        (...R) => s(d) && s(d)(...R)),
        onInvalid: z[4] || (z[4] = //@ts-ignore
        (...R) => s(m) && s(m)(...R)),
        onInput: C
      }), null, 16, qo), [
        [La, s(v)]
      ]),
      le("span", {
        class: M(s(g))
      }, [
        le("span", {
          class: M(s(y))
        }, null, 2)
      ], 2),
      e.label || k.$slots.default ? (f(), P("span", {
        key: 0,
        id: e.ariaLabelledby,
        class: M(s(I))
      }, [
        _(k.$slots, "default", {}, () => [
          Pe(ue(e.label), 1)
        ])
      ], 10, Xo)) : J("", !0)
    ], 42, Uo));
  }
}), Jo = {
  install(e) {
    Ae(e, Go);
  }
}, Vt = ye({
  name: "OSlotComponent",
  props: {
    /** Component to be get the slot from */
    component: { type: Object, required: !0 },
    /** Slot name */
    name: { type: String, default: "default" },
    /** Props passed to the slot */
    props: { type: Object, default: () => {
    } },
    /** Tag name of the slot wrapper element */
    tag: {
      type: [String, Object, Function],
      default: "div"
    }
  },
  render() {
    const e = this.component.$slots[this.name] ? this.component.$slots[this.name](this.props) : {};
    return na(this.tag, {}, e);
  }
}), Qo = ["value"], Zo = /* @__PURE__ */ ye({
  isOruga: !0,
  name: "OTableMobileSort",
  configField: "table",
  __name: "TableMobileSort",
  props: {
    currentSortColumn: {
      type: Object,
      default: void 0
    },
    columns: {
      type: Array,
      default: void 0
    },
    placeholder: { type: String, default: void 0 },
    iconPack: { type: String, default: void 0 },
    sortIcon: { type: String, default: "arrow-up" },
    sortIconSize: { type: String, default: "small" },
    isAsc: { type: Boolean, default: !1 },
    mobileSortClasses: { type: Array, required: !0 }
  },
  emits: ["sort"],
  setup(e, { emit: n }) {
    const a = e, t = n, o = L(
      Me(a.currentSortColumn, "identifier")
    ), i = l(
      () => !a.columns || !a.columns.some(
        (c) => Me(c, "identifier") === o.value
      )
    ), u = l(
      () => a.columns ? a.columns.filter((c) => c.sortable) : []
    ), d = l(
      () => Me(a.currentSortColumn, "identifier") === o.value
    );
    ce(o, (c) => {
      a.currentSortColumn.identifier !== c && m();
    }), ce(
      () => a.currentSortColumn,
      (c) => {
        o.value = Me(c, "identifier");
      }
    );
    function m(c) {
      const v = u.value.filter(
        (p) => Me(p, "identifier") === o.value
      )[0];
      t("sort", v, c);
    }
    return (c, v) => (f(), P("div", {
      class: M(e.mobileSortClasses)
    }, [
      me(Ka, null, {
        default: se(() => [
          me(mt, {
            modelValue: o.value,
            "onUpdate:modelValue": v[0] || (v[0] = (p) => o.value = p),
            expanded: ""
          }, {
            default: se(() => [
              e.placeholder ? $e((f(), P("option", {
                key: 0,
                value: {},
                selected: "",
                disabled: "",
                hidden: ""
              }, ue(e.placeholder), 513)), [
                [ze, i.value]
              ]) : J("", !0),
              (f(!0), P(he, null, xe(u.value, (p, C) => (f(), P("option", {
                key: C,
                value: p.identifier
              }, ue(p.label), 9, Qo))), 128))
            ]),
            _: 1
          }, 8, ["modelValue"]),
          me(wt, {
            onClick: v[1] || (v[1] = (p) => m(p))
          }, {
            default: se(() => [
              $e(me(Re, {
                icon: e.sortIcon,
                pack: e.iconPack,
                size: e.sortIconSize,
                both: "",
                rotation: e.isAsc ? 0 : 180
              }, null, 8, ["icon", "pack", "size", "rotation"]), [
                [ze, d.value]
              ])
            ]),
            _: 1
          })
        ]),
        _: 1
      })
    ], 2));
  }
}), _o = ["data-id"], ol = /* @__PURE__ */ ye({
  isOruga: !0,
  name: "OTableColumn",
  configField: "table",
  __name: "TableColumn",
  props: {
    /** Define the column label */
    label: { type: String, default: void 0 },
    /** Define an object property key if data is an object */
    field: { type: String, default: void 0 },
    /** Define a column sub heading  */
    subheading: { type: String, default: void 0 },
    /** Add addtional meta information for the column for custom purpose*/
    meta: {
      type: [String, Number, Boolean, Function, Object, Array],
      default: void 0
    },
    /** Column fixed width */
    width: { type: [Number, String], default: void 0 },
    /** Define column value as number */
    numeric: { type: Boolean, default: !1 },
    /**
     * Position of the column content
     * @values left, centered, right
     */
    position: {
      type: String,
      default: void 0,
      validator: (e) => ["left", "centered", "right"].indexOf(e) > -1
    },
    /** Enable an additional searchbar below the column header */
    searchable: { type: Boolean, default: !1 },
    /** Enable column sortability */
    sortable: { type: Boolean, default: !1 },
    /** Define whether the column is visible or not */
    visible: { type: Boolean, default: !0 },
    /** Define a custom sort function */
    customSort: {
      type: Function,
      default: void 0
    },
    /** Define a custom funtion for the filter search */
    customSearch: {
      type: Function,
      default: void 0
    },
    /** Whether the column is sticky or not */
    sticky: { type: Boolean, default: !1 },
    /** Make header selectable */
    headerSelectable: { type: Boolean, default: !1 },
    /** Adds native attributes to th */
    thAttrs: {
      type: Function,
      default: () => ({})
    },
    /** Adds native attributes to td */
    tdAttrs: {
      type: Function,
      default: () => ({})
    }
  },
  setup(e) {
    const n = e, a = l(() => ({
      width: Ft(n.width)
    })), t = l(
      () => !n.headerSelectable && n.sortable
    ), o = Dt(), i = l(() => ({
      ...We(n),
      $el: o.proxy,
      $slots: o.slots,
      style: a.value,
      isHeaderUnselectable: t.value
    })), { item: u } = gt({ data: i });
    return (d, m) => (f(), P("span", {
      "data-id": s(u).identifier,
      "data-oruga": "table-column"
    }, [
      Pe(ue(e.label) + " ", 1),
      J("", !0)
    ], 8, _o));
  }
}), Va = /* @__PURE__ */ ye({
  isOruga: !0,
  name: "OTablePagination",
  configField: "table",
  __name: "TablePagination",
  props: {
    current: { type: Number, default: void 0 },
    paginated: { type: Boolean, default: !1 },
    rootClass: {
      type: [String, Array, Object],
      default: void 0
    }
  },
  emits: ["update:current", "change"],
  setup(e, { emit: n }) {
    const a = e, t = n, o = qe("current", a, t);
    function i(u) {
      const d = u > 0 ? u : 1;
      o.value = d, t("change", d);
    }
    return (u, d) => (f(), P("div", {
      class: M(e.rootClass)
    }, [
      le("div", null, [
        _(u.$slots, "default")
      ]),
      le("div", null, [
        e.paginated ? (f(), ne(tl, be({ key: 0 }, u.$attrs, {
          current: s(o),
          onChange: i
        }), null, 16, ["current"])) : J("", !0)
      ])
    ], 2));
  }
}), ei = ["tabindex"], ti = { key: 0 }, ai = { key: 1 }, li = ["draggable", "onClick", "onDragstart", "onDragend", "onDrop", "onDragover", "onDragleave"], ni = { key: 1 }, oi = { key: 0 }, ii = { key: 1 }, si = { key: 2 }, ri = { key: 1 }, ui = { key: 1 }, di = { key: 2 }, ci = ["draggable", "onClick", "onDblclick", "onMouseenter", "onMouseleave", "onContextmenu", "onDragstart", "onDragend", "onDrop", "onDragover", "onDragleave"], fi = ["colspan"], vi = { key: 0 }, pi = ["colspan"], mi = { key: 2 }, yi = ["colspan"], gi = /* @__PURE__ */ ye({
  isOruga: !0,
  name: "OTable",
  configField: "table",
  inheritAttrs: !1,
  __name: "Table",
  props: {
    /** Override existing theme classes completely */
    override: { type: Boolean, default: void 0 },
    /** Table data */
    data: { type: Array, default: () => [] },
    /** Table columns */
    columns: { type: Array, default: () => [] },
    /** Border to all cells */
    bordered: {
      type: Boolean,
      default: () => r("table.bordered", !1)
    },
    /** Whether table is striped */
    striped: {
      type: Boolean,
      default: () => r("table.striped", !1)
    },
    /** Makes the cells narrower */
    narrowed: {
      type: Boolean,
      default: () => r("table.narrowed", !1)
    },
    /** Rows are highlighted when hovering */
    hoverable: {
      type: Boolean,
      default: () => r("table.hoverable", !1)
    },
    /** Enable loading state */
    loading: { type: Boolean, default: !1 },
    /** Allow row details  */
    detailed: { type: Boolean, default: !1 },
    /** Rows can be checked (multiple) */
    checkable: { type: Boolean, default: !1 },
    /** Show check/uncheck all checkbox in table header when checkable */
    headerCheckable: { type: Boolean, default: !0 },
    /**
     * Position of the checkbox when checkable
     * @values left, right
     */
    checkboxPosition: {
      type: String,
      default: () => r("table.checkboxPosition", "left"),
      validator: (e) => ["left", "right"].indexOf(e) >= 0
    },
    /**
     * Color of the checkbox when checkable
     * @values primary, info, success, warning, danger, and any other custom color
     */
    checkboxVariant: {
      type: String,
      default: () => r("table.checkboxVariant")
    },
    /** Set which row is selected, use v-model:selected to make it two-way binding */
    selected: { type: Object, default: void 0 },
    /** Custom method to verify if a row is selectable, works when is selected. */
    isRowSelectable: { type: Function, default: () => !0 },
    /** Table can be focused and user can navigate with keyboard arrows (require selected) and rows are highlighted when hovering */
    focusable: { type: Boolean, default: !1 },
    /** Custom method to verify if row is checked, works when is checkable. Useful for backend pagination */
    customIsChecked: {
      type: Function,
      default: void 0
    },
    /** Custom method to verify if a row is checkable, works when is checkable */
    isRowCheckable: {
      type: Function,
      default: (e) => (
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        r("table.isRowCheckable", (n) => !0)(e)
      )
    },
    /** Set which rows are checked, use v-model:checkedRows to make it two-way binding */
    checkedRows: { type: Array, default: () => [] },
    /** Rows appears as cards on mobile (collapse rows) */
    mobileCards: {
      type: Boolean,
      default: () => r("table.mobileCards", !0)
    },
    /** Sets the default sort column and order — e.g. ['first_name', 'desc'] */
    defaultSort: {
      type: [String, Array],
      default: () => r("table.defaultSort")
    },
    /**
     * Sets the default sort column direction on the first click
     * @values asc, desc
     */
    defaultSortDirection: {
      type: String,
      default: () => r("table.defaultSortDirection", "asc")
    },
    /** Sets the header sorting icon */
    sortIcon: {
      type: String,
      default: () => r("table.sortIcon", "arrow-up")
    },
    /**
     * Sets the size of the sorting icon
     * @values small, medium, large
     */
    sortIconSize: {
      type: String,
      default: () => r("table.sortIconSize", "small")
    },
    /**
     * Icon pack to use
     * @values mdi, fa, fas and any other custom icon pack
     */
    iconPack: {
      type: String,
      default: () => r("table.iconPack")
    },
    /** Columns won't be sorted with Javascript, use with sort event to sort in your backend */
    backendSorting: {
      type: Boolean,
      default: () => r("table.backendSorting", !1)
    },
    /** Columns won't be filtered with Javascript, use with searchable prop to the columns to filter in your backend */
    backendFiltering: {
      type: Boolean,
      default: () => r("table.backendFiltering", !1)
    },
    /** Add a class to row based on the return */
    rowClass: {
      type: Function,
      default: (e, n) => (
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        r("table.rowClass", (a, t) => "")(e, n)
      )
    },
    /** Allow pre-defined opened details. Ideal to open details via vue-router. (A unique key is required; check detail-key prop) */
    openedDetailed: { type: Array, default: () => [] },
    /** Controls the visibility of the trigger that toggles the detailed rows. */
    hasDetailedVisible: {
      type: Function,
      default: (e) => (
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        r("table.hasDetailedVisible", (n) => !0)(e)
      )
    },
    /** Use a unique key of your data Object when use detailed or opened detailed. (id recommended) */
    detailKey: {
      type: String,
      default: () => r("table.detailKey")
    },
    /** Allow chevron icon and column to be visible */
    showDetailIcon: {
      type: Boolean,
      default: () => r("table.showDetailIcon", !0)
    },
    /** Icon name of detail action */
    detailIcon: {
      type: String,
      default: () => r("table.detailIcon", "chevron-right")
    },
    /** Custom style on details */
    customDetailRow: { type: Boolean, default: !1 },
    /* Transition name to use when toggling row details. */
    detailTransition: {
      type: String,
      default: () => r("table.detailTransition", "slide")
    },
    /** Text when nothing is selected */
    mobileSortPlaceholder: {
      type: String,
      default: () => r("table.mobileSortPlaceholder")
    },
    /** Use a unique key of your data Object for each row. Useful if your data prop has dynamic indices. (id recommended) */
    customRowKey: {
      type: String,
      default: () => r("table.customRowKey")
    },
    /** Allows rows to be draggable */
    draggable: { type: Boolean, default: !1 },
    /** Allows columns to be draggable */
    draggableColumn: { type: Boolean, default: !1 },
    /** Add a horizontal scrollbar when table is too wide */
    scrollable: { type: Boolean, default: void 0 },
    /** Show a sticky table header */
    stickyHeader: { type: Boolean, default: !1 },
    /** Table fixed height */
    height: { type: [Number, String], default: void 0 },
    /** Add a native event to filter */
    filtersEvent: { type: String, default: "" },
    /** Filtering debounce time (in milliseconds) */
    debounceSearch: { type: Number, default: void 0 },
    /** Show header */
    showHeader: {
      type: Boolean,
      default: () => r("table.showHeader", !0)
    },
    /** Make the checkbox column sticky when checkable */
    stickyCheckbox: { type: Boolean, default: !1 },
    /** Adds pagination to the table */
    paginated: {
      type: Boolean,
      default: () => r("table.paginated", !1)
    },
    /** Rows won't be paginated with Javascript, use with page-change event to paginate in your backend */
    backendPagination: { type: Boolean, default: !1 },
    /** Total number of table data if backend-pagination is enabled */
    total: { type: Number, default: 0 },
    /** Current page of table data (if paginated), use v-model:currentPage to make it two-way binding */
    currentPage: { type: Number, default: 1 },
    /** How many rows per page (if paginated) */
    perPage: {
      type: [Number, String],
      default: () => r("table.perPage", 20)
    },
    /**
     * Pagination position (if paginated)
     * @values bottom, top, both
     */
    paginationPosition: {
      type: String,
      default: () => r("table.paginationPosition", "bottom"),
      validator: (e) => ["bottom", "top", "both"].indexOf(e) >= 0
    },
    /** Rounded pagination if paginated */
    paginationRounded: {
      type: Boolean,
      default: () => r("table.paginationRounded", !1)
    },
    /** Size of pagination if paginated */
    paginationSize: {
      type: String,
      default: () => r("table.paginationSize", "small")
    },
    /** Enable simple style pagination if paginated */
    paginationSimple: {
      type: Boolean,
      default: () => r("table.paginationSimple", !1)
    },
    /**
     * Pagination buttons order if paginated
     * @values centered, right, left
     */
    paginationOrder: {
      type: String,
      default: () => r("table.paginationOrder"),
      validator: (e) => ["centered", "right", "left"].indexOf(e) >= 0
    },
    /** Mobile breakpoint as max-width value */
    mobileBreakpoint: {
      type: String,
      default: () => r("table.mobileBreakpoint")
    },
    /** Accessibility label for the pagination next page button. */
    ariaNextLabel: {
      type: String,
      default: () => r("table.ariaNextLabel")
    },
    /** Accessibility label for the pagination previous page button. */
    ariaPreviousLabel: {
      type: String,
      default: () => r("table.ariaPreviousLabel")
    },
    /** Accessibility label for the pagination page button. */
    ariaPageLabel: {
      type: String,
      default: () => r("table.ariaPageLabel")
    },
    /** Accessibility label for the pagination current page button. */
    ariaCurrentLabel: {
      type: String,
      default: () => r("table.ariaCurrentLabel")
    },
    // class props (will not be displayed in the docs)
    /** Class of the root element */
    rootClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the Table */
    tableClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the Table wrapper */
    wrapperClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the Table footer */
    footerClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the Table when it is empty */
    emptyClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the Table row detail */
    detailedClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the Table when is bordered */
    borderedClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the Table when rows are striped */
    stripedClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the Table when rows are narrowed */
    narrowedClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the Table when is hoverable */
    hoverableClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the Table wrapper when header is sticky */
    stickyHeaderClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the Table wrapper when its content is scrollable */
    scrollableClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the Table row when selected */
    trSelectedClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the Table row when checkable and checked */
    trCheckedClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the Table `th` element */
    thClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the Table `th` element when component is positioned */
    thPositionClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the Table `th` element when component is sticky" */
    thStickyClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the Table `th` element when is checkable */
    thCheckboxClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the Table `th` element currently sorted */
    thCurrentSortClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the sortable Table `th` element */
    thSortableClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the Table `th` element that is unsortable */
    thUnselectableClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the Table sort icon in the header */
    thSortIconClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the Table `th` element of the detail column of triggers */
    thDetailedClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the Table `th` subheading element */
    thSubheadingClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the Table `td` element */
    tdClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the Table `td` element when component is positioned */
    tdPositionClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the Table `td` element when component is sticky */
    tdStickyClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the Table `td` element when is checkable */
    tdCheckboxClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the Table `td` element that contains the chevron to trigger details */
    tdDetailedChevronClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the sortable form wrapper on mobile */
    mobileSortClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the Table pagination wrapper */
    paginationWrapperClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the Table component when on mobile */
    mobileClass: {
      type: [String, Array, Function],
      default: void 0
    }
  },
  emits: ["update:currentPage", "page-change", "update:selected", "select", "check", "check-all", "update:checkedRows", "sort", "filters-change", "filters-event", "update:openedDetailed", "details-open", "details-close", "click", "dblclick", "contextmenu", "mouseenter", "mouseleave", "cell-click", "dragstart", "dragend", "drop", "dragleave", "dragover", "columndragstart", "columndragend", "columndrop", "columndragleave", "columndragover"],
  setup(e, { emit: n }) {
    const a = e, t = n, { isMobile: o } = ct(a.mobileBreakpoint), i = l(() => a.mobileCards && o.value), u = L(), d = L(), m = bt(d), c = l(
      () => m.sortedItems.value.map((F) => ({
        index: F.index,
        identifier: F.identifier,
        ...pt(F.data),
        thAttrsData: {},
        tdAttrsData: []
      }))
    ), v = l(() => {
      var F;
      return (F = a.data) != null && F.length ? a.data.map(
        (Y) => !a.customRowKey && typeof Y == "object" ? Object.assign({ __rowKey: Ye() }, Y) : Y
      ) : [...a.data];
    }), p = L(v.value), C = L(
      a.backendPagination ? a.total : v.value.length
    ), B = qe("currentPage", a, t, {
      passive: !0
    });
    ce(
      () => v.value,
      (F) => {
        a.backendFiltering ? p.value = [...F] : p.value = F.filter((Y) => E(Y)), a.backendSorting || x(S.value, !0), a.backendPagination || (C.value = p.value.length);
      },
      { deep: !0 }
    ), ce(
      () => a.total,
      (F) => {
        a.backendPagination && (C.value = F);
      }
    );
    const A = l(() => ({
      height: Ft(a.height)
    })), g = l(() => {
      if (!a.paginated)
        return p.value;
      const F = B.value, Y = Number(a.perPage);
      if (p.value.length <= Y)
        return p.value;
      {
        const oe = (F - 1) * Y, Ie = oe + Y;
        return p.value.slice(oe, Ie);
      }
    }), y = l(() => c.value ? c.value.filter(
      (F) => F.visible || F.visible === void 0
    ) : []);
    ce([g, y], () => {
      if (y.value.length && g.value.length)
        for (let F = 0; F < y.value.length; F++) {
          const Y = y.value[F];
          Y.thAttrsData = typeof Y.thAttrs == "function" ? Y.thAttrs(Y) : {}, Y.tdAttrsData = g.value.map(
            (oe) => typeof Y.tdAttrs == "function" ? Y.tdAttrs(oe, Y) : {}
          );
        }
    });
    const I = l(() => {
      let F = y.value.length;
      return F += a.checkable ? 1 : 0, F += a.detailed && a.showDetailIcon ? 1 : 0, F;
    }), k = l(
      () => c.value.some((F) => F.searchable)
    ), z = l(() => a.scrollable ? !0 : c.value ? c.value.some((F) => F.sticky) : !1), R = xt(), H = l(() => R.subheading ? !0 : c.value.some((F) => !!F.subheading));
    function j() {
      if (R.footer) {
        const F = R.footer();
        if (F.length > 1)
          return !0;
        const Y = F[0].tag;
        if (Y !== "th" && Y !== "td")
          return !1;
      }
      return !0;
    }
    function U(F, Y) {
      if (!g.value.length)
        return;
      let oe = g.value.indexOf(a.selected) + F;
      oe = oe < 0 ? 0 : oe > g.value.length - 1 ? g.value.length - 1 : oe;
      const Ie = g.value[oe];
      if (a.isRowSelectable(Ie))
        Q(Ie, oe, Y);
      else {
        let q = null;
        if (F > 0)
          for (let re = oe; re < g.value.length && q === null; re++)
            a.isRowSelectable(g.value[re]) && (q = re);
        else
          for (let re = oe; re >= 0 && q === null; re--)
            a.isRowSelectable(g.value[re]) && (q = re);
        q >= 0 && Q(g.value[q], oe, Y);
      }
    }
    function Q(F, Y, oe) {
      t("click", F, Y, oe), a.selected !== F && a.isRowSelectable(F) && (t("select", F, a.selected), t("update:selected", F));
    }
    function V(F, Y) {
      return Y ? b(F) === b(Y) : !1;
    }
    function b(F) {
      return a.customRowKey ? F[a.customRowKey] : typeof F == "object" ? F.__rowKey : F;
    }
    const D = L({});
    ce(
      D.value,
      (F) => {
        a.debounceSearch ? ia(() => G(F), a.debounceSearch) : G(F);
      },
      { deep: !0 }
    );
    function W(F) {
      t("filters-event", a.filtersEvent, D.value, F);
    }
    function G(F) {
      a.backendFiltering ? t("filters-change", F) : (p.value = a.data.filter((Y) => E(Y)), a.backendPagination || (C.value = p.value.length), a.backendSorting || Object.keys(S.value).length > 0 && K(S.value));
    }
    function E(F) {
      for (const Y in D.value) {
        if (!D.value[Y])
          continue;
        const oe = D.value[Y], Ie = c.value.filter((q) => q.field === Y)[0];
        if (typeof (Ie == null ? void 0 : Ie.customSearch) == "function") {
          if (!Ie.customSearch(F, oe))
            return !1;
        } else {
          const q = Me(F, Y);
          if (q == null)
            return !1;
          if (Number.isInteger(q)) {
            if (q !== Number(oe))
              return !1;
          } else {
            const re = new RegExp(Ll(oe), "i");
            if (Array.isArray(q)) {
              if (!q.some(
                (Fe) => re.test(Aa(Fe)) || re.test(Fe)
              ))
                return !1;
            } else if (!re.test(Aa(q)) && !re.test(q))
              return !1;
          }
        }
      }
      return !0;
    }
    const S = L(), w = L(!0);
    st(() => De(() => ae()));
    const $ = l(
      () => c.value.some((F) => F.sortable)
    );
    function N(F) {
      var Y;
      return ((Y = S.value) == null ? void 0 : Y.identifier) === F.identifier;
    }
    function ae() {
      if (c.value.length && !S.value)
        O();
      else if (c.value.length && S.value && Object.keys(S.value).length > 0) {
        for (let F = 0; F < c.value.length; F++)
          if (S.value.field === c.value[F].field) {
            S.value = c.value[F];
            break;
          }
      }
    }
    function O() {
      if (!a.defaultSort)
        return;
      let F = "", Y = a.defaultSortDirection;
      Array.isArray(a.defaultSort) ? (F = a.defaultSort[0], a.defaultSort[1] && (Y = a.defaultSort[1])) : F = a.defaultSort;
      const oe = c.value.filter(
        (Ie) => Ie.field === F
      )[0];
      oe && (w.value = Y.toLowerCase() !== "desc", x(oe, !0));
    }
    function x(F, Y = !1, oe) {
      !F || !F.sortable || (Y || (w.value = N(F) ? !w.value : a.defaultSortDirection.toLowerCase() !== "desc"), S.value && t("sort", F, w.value ? "asc" : "desc", oe), a.backendSorting || K(F), S.value = F);
    }
    function K(F) {
      p.value = ie(
        p.value,
        F.field,
        F.customSort,
        w.value
      );
    }
    function ie(F, Y, oe, Ie) {
      let q = [];
      return oe && typeof oe == "function" ? q = [...F].sort((re, ge) => oe(re, ge, Ie)) : q = [...F].sort((re, ge) => {
        let Fe = Me(re, Y), je = Me(ge, Y);
        return typeof Fe == "boolean" && typeof je == "boolean" ? Ie ? Fe > je ? 1 : -1 : Fe > je ? -1 : 1 : !Fe && Fe !== 0 ? 1 : !je && je !== 0 ? -1 : Fe === je ? 0 : (Fe = typeof Fe == "string" ? Fe.toUpperCase() : Fe, je = typeof je == "string" ? je.toUpperCase() : je, Ie ? Fe > je ? 1 : -1 : Fe > je ? -1 : 1);
      }), q;
    }
    const fe = L([...a.checkedRows]), He = L(null);
    ce(
      () => a.checkedRows,
      (F) => {
        fe.value = [...F];
      },
      { deep: !0 }
    );
    const Ve = l(() => {
      const F = g.value.filter(
        (oe) => a.isRowCheckable(oe)
      );
      return F.length === 0 ? !1 : !F.some(
        (oe) => ea(
          fe.value,
          oe,
          a.customIsChecked
        ) < 0
      );
    }), Se = l(() => g.value.filter(
      (Y) => a.isRowCheckable(Y)
    ).length === 0);
    function Te(F) {
      return ea(fe.value, F, a.customIsChecked) >= 0;
    }
    function tt(F) {
      const Y = ea(fe.value, F, a.customIsChecked);
      Y >= 0 && fe.value.splice(Y, 1);
    }
    function Je() {
      const F = Ve.value;
      g.value.forEach((Y) => {
        a.isRowCheckable(Y) && tt(Y), F || a.isRowCheckable(Y) && fe.value.push(Y);
      }), t("check", fe.value), t("check-all", fe.value), t("update:checkedRows", fe.value);
    }
    function lt(F, Y) {
      a.isRowCheckable(F) && (He.value, He.value = Y, Te(F) ? tt(F) : fe.value.push(F), t("check", fe.value, F), t("update:checkedRows", fe.value));
    }
    const Qe = L(a.openedDetailed), nt = l(
      () => a.detailed && a.showDetailIcon
    );
    ce(
      () => a.openedDetailed,
      (F) => {
        Qe.value = F;
      }
    );
    function ft(F) {
      T(F) ? (Z(F), t("details-close", F)) : (ee(F), t("details-open", F)), t("update:openedDetailed", Qe.value);
    }
    function ee(F) {
      const Y = Le(F);
      Qe.value.push(Y);
    }
    function Z(F) {
      const Y = Le(F), oe = Qe.value.indexOf(Y);
      oe >= 0 && Qe.value.splice(oe, 1);
    }
    function T(F) {
      const Y = Le(F);
      return Qe.value.indexOf(Y) >= 0;
    }
    function de(F) {
      return a.detailed && !a.customDetailRow && T(F);
    }
    function ke(F) {
      return a.detailed && a.customDetailRow && T(F);
    }
    function Le(F) {
      const Y = a.detailKey;
      return !(Y != null && Y.length) || !F ? F : F[Y];
    }
    const X = L(!1), te = L(!1), pe = l(() => a.draggable && !te.value), we = l(
      () => a.draggableColumn && !X.value
    );
    function Oe(F, Y, oe) {
      a.draggable && t("dragstart", F, Y, oe);
    }
    function Ne(F, Y, oe) {
      a.draggable && t("dragend", F, Y, oe);
    }
    function Ct(F, Y, oe) {
      a.draggable && t("drop", F, Y, oe);
    }
    function $t(F, Y, oe) {
      a.draggable && t("dragover", F, Y, oe);
    }
    function Bt(F, Y, oe) {
      a.draggable && t("dragleave", F, Y, oe);
    }
    function Zt(F, Y, oe) {
      we.value && (te.value = !0, t("columndragstart", F, Y, oe));
    }
    function il(F, Y, oe) {
      we.value && (te.value = !1, t("columndragend", F, Y, oe));
    }
    function sl(F, Y, oe) {
      we.value && t("columndrop", F, Y, oe);
    }
    function rl(F, Y, oe) {
      we.value && t("columndragover", F, Y, oe);
    }
    function ul(F, Y, oe) {
      we.value && t("columndragleave", F, Y, oe);
    }
    const dl = h(
      ["rootClass", "o-table__root"],
      ["mobileClass", "o-table__wrapper--mobile", null, i]
    ), cl = h(
      ["tableClass", "o-table"],
      [
        "borderedClass",
        "o-table--bordered",
        null,
        l(() => a.bordered)
      ],
      ["stripedClass", "o-table--striped", null, l(() => a.striped)],
      [
        "narrowedClass",
        "o-table--narrowed",
        null,
        l(() => a.narrowed)
      ],
      [
        "hoverableClass",
        "o-table--hoverable",
        null,
        l(
          () => (a.hoverable || a.focusable) && !!g.value.length
        )
      ],
      [
        "emptyClass",
        "o-table--table__empty",
        null,
        l(() => !g.value.length)
      ]
    ), fl = h(
      ["wrapperClass", "o-table__wrapper"],
      [
        "stickyHeaderClass",
        "o-table__wrapper--sticky-header",
        null,
        l(() => a.stickyHeader)
      ],
      ["scrollableClass", "o-table__wrapper--scrollable", null, z],
      ["mobileClass", "o-table__wrapper--mobile", null, i]
    ), vl = h(["footerClass", "o-table__footer"]), ut = h(["thClass", "o-table__th"]), ga = h(["tdClass", "o-table__td"]), ba = h([
      "thCheckboxClass",
      "o-table__th-checkbox"
    ]), _t = h([
      "thDetailedClass",
      "o-table__th--detailed"
    ]), pl = h(["thSubheadingClass", "o-table__th"]), Ca = h(
      ["tdCheckboxClass", "o-table__td-checkbox"],
      [
        "thStickyClass",
        "o-table__th--sticky",
        null,
        l(() => a.stickyCheckbox)
      ]
    ), ml = h(["detailedClass", "o-table__detail"]), yl = h([
      "tdDetailedChevronClass",
      "o-table__td-chevron"
    ]), gl = h([
      "mobileSortClass",
      "o-table__mobile-sort"
    ]), bl = h([
      "paginationWrapperClass",
      "o-table__pagination"
    ]), ha = l(
      () => Ee(bl.value)
    ), Cl = h([
      "thSortIconClass",
      "o-table__th__sort-icon"
    ]);
    function ka(F) {
      const Y = h(
        [
          "thCurrentSortClass",
          "o-table__th-current-sort",
          null,
          N(F)
        ],
        ["thSortableClass", "o-table__th--sortable", null, F.sortable],
        [
          "thUnselectableClass",
          "o-table__th--unselectable",
          null,
          F.isHeaderUnselectable
        ],
        [
          "thPositionClass",
          "o-table__th--",
          F.position,
          !!F.position
        ],
        ["thStickyClass", "o-table__th--sticky", null, F.sticky]
      );
      return [...ut.value, ...Y.value];
    }
    function hl(F, Y) {
      const oe = h(
        [
          "trSelectedClass",
          "o-table__tr--selected",
          null,
          V(F, a.selected)
        ],
        ["trCheckedClass", "o-table__tr--checked", null, Te(F)]
      ), Ie = a.rowClass(F, Y);
      return [...oe.value, { [Ie]: !0 }];
    }
    function kl(F, Y) {
      const oe = h(
        [
          "tdPositionClass",
          "o-table__td--",
          Y.position,
          !!Y.position
        ],
        ["tdStickyClass", "o-table__td--sticky", null, Y.sticky]
      );
      return [...ga.value, ...oe.value];
    }
    return (F, Y) => {
      var oe, Ie;
      return f(), P("div", {
        ref_key: "rootRef",
        ref: u,
        class: M(s(dl)),
        "data-oruga": "table"
      }, [
        le("div", {
          ref_key: "slotRef",
          ref: d,
          style: { display: "none" }
        }, [
          _(F.$slots, "default", {}, () => {
            var q;
            return [
              (q = e.columns) != null && q.length ? (f(!0), P(he, { key: 0 }, xe(e.columns, (re, ge) => (f(), ne(ol, be({ key: ge }, re), {
                default: se(({ row: Fe }) => [
                  Pe(ue(re.field ? Fe[re.field] : Fe), 1)
                ]),
                _: 2
              }, 1040))), 128)) : J("", !0)
            ];
          })
        ], 512),
        i.value && $.value ? (f(), ne(Zo, {
          key: 0,
          "current-sort-column": S.value,
          columns: c.value,
          placeholder: e.mobileSortPlaceholder,
          "icon-pack": e.iconPack,
          "sort-icon": e.sortIcon,
          "sort-icon-size": e.sortIconSize,
          "is-asc": w.value,
          "mobile-sort-classes": s(gl),
          onSort: Y[0] || (Y[0] = (q, re) => x(q, null, re))
        }, null, 8, ["current-sort-column", "columns", "placeholder", "icon-pack", "sort-icon", "sort-icon-size", "is-asc", "mobile-sort-classes"])) : J("", !0),
        e.paginated && (e.paginationPosition === "top" || e.paginationPosition === "both") ? _(F.$slots, "pagination", {
          key: 1,
          current: s(B),
          perPage: e.perPage,
          total: C.value,
          change: (q) => B.value = q
        }, () => [
          me(Va, be(F.$attrs, {
            current: s(B),
            "onUpdate:current": Y[1] || (Y[1] = (q) => Ke(B) ? B.value = q : null),
            paginated: e.paginated,
            "per-page": e.perPage,
            total: C.value,
            rounded: e.paginationRounded,
            size: e.paginationSize,
            order: e.paginationOrder,
            simple: e.paginationSimple,
            "icon-pack": e.iconPack,
            "aria-next-label": e.ariaNextLabel,
            "aria-previous-label": e.ariaPreviousLabel,
            "aria-page-label": e.ariaPageLabel,
            "aria-current-label": e.ariaCurrentLabel,
            "root-class": ha.value,
            onChange: Y[2] || (Y[2] = (q) => F.$emit("page-change", q))
          }), {
            default: se(() => [
              _(F.$slots, "top-left")
            ]),
            _: 3
          }, 16, ["current", "paginated", "per-page", "total", "rounded", "size", "order", "simple", "icon-pack", "aria-next-label", "aria-previous-label", "aria-page-label", "aria-current-label", "root-class"])
        ]) : J("", !0),
        le("div", {
          class: M(s(fl)),
          style: _e(A.value)
        }, [
          le("table", {
            class: M(s(cl)),
            tabindex: e.focusable ? 0 : null,
            onKeydown: [
              Y[3] || (Y[3] = Ce(ve((q) => U(-1, q), ["self", "prevent"]), ["up"])),
              Y[4] || (Y[4] = Ce(ve((q) => U(1, q), ["self", "prevent"]), ["down"]))
            ]
          }, [
            F.$slots.caption ? (f(), P("caption", ti, [
              _(F.$slots, "caption")
            ])) : J("", !0),
            c.value.length && e.showHeader ? (f(), P("thead", ai, [
              _(F.$slots, "preheader"),
              le("tr", null, [
                nt.value ? (f(), P("th", {
                  key: 0,
                  class: M([...s(ut), ...s(_t)])
                }, null, 2)) : J("", !0),
                e.checkable && e.checkboxPosition === "left" ? (f(), P("th", {
                  key: 1,
                  class: M([...s(ut), ...s(ba)])
                }, [
                  _(F.$slots, "check-all", {
                    isAllChecked: Ve.value,
                    isAllUncheckable: Se.value,
                    checkAll: Je
                  }, () => [
                    e.headerCheckable ? (f(), ne(Rt, {
                      key: 0,
                      "model-value": Ve.value,
                      autocomplete: "off",
                      variant: e.checkboxVariant,
                      disabled: Se.value,
                      "onUpdate:modelValue": Je
                    }, null, 8, ["model-value", "variant", "disabled"])) : J("", !0)
                  ])
                ], 2)) : J("", !0),
                (f(!0), P(he, null, xe(y.value, (q, re) => {
                  var ge;
                  return f(), P("th", be({
                    key: q.identifier + ":" + re + "header"
                  }, q.thAttrsData, {
                    class: ka(q),
                    style: i.value ? {} : q.style,
                    draggable: we.value,
                    onClick: ve((Fe) => x(q, null, Fe), ["stop"]),
                    onDragstart: (Fe) => Zt(q, re, Fe),
                    onDragend: (Fe) => il(q, re, Fe),
                    onDrop: (Fe) => sl(q, re, Fe),
                    onDragover: (Fe) => rl(q, re, Fe),
                    onDragleave: (Fe) => ul(q, re, Fe)
                  }), [
                    (ge = q.$slots) != null && ge.header ? (f(), ne(s(Vt), {
                      key: 0,
                      component: q.$el,
                      name: "header",
                      tag: "span",
                      props: { column: q, index: re }
                    }, null, 8, ["component", "props"])) : (f(), P("span", ni, [
                      Pe(ue(q.label) + " ", 1),
                      $e(le("span", {
                        class: M(s(Cl))
                      }, [
                        me(Re, {
                          icon: e.sortIcon,
                          pack: e.iconPack,
                          both: "",
                          size: e.sortIconSize,
                          rotation: w.value ? 0 : 180
                        }, null, 8, ["icon", "pack", "size", "rotation"])
                      ], 2), [
                        [
                          ze,
                          q.sortable && N(q)
                        ]
                      ])
                    ]))
                  ], 16, li);
                }), 128)),
                e.checkable && e.checkboxPosition === "right" ? (f(), P("th", {
                  key: 2,
                  class: M([...s(ut), ...s(ba)])
                }, [
                  e.headerCheckable ? _(F.$slots, "check-all", {
                    key: 0,
                    isAllChecked: Ve.value,
                    isAllUncheckable: Se.value,
                    checkAll: Je
                  }, () => [
                    me(Rt, {
                      "model-value": Ve.value,
                      autocomplete: "off",
                      variant: e.checkboxVariant,
                      disabled: Se.value,
                      "onUpdate:modelValue": Je
                    }, null, 8, ["model-value", "variant", "disabled"])
                  ]) : J("", !0)
                ], 2)) : J("", !0)
              ]),
              k.value ? (f(), P("tr", oi, [
                nt.value ? (f(), P("th", {
                  key: 0,
                  class: M([...s(ut), ...s(_t)])
                }, null, 2)) : J("", !0),
                e.checkable && e.checkboxPosition === "left" ? (f(), P("th", ii)) : J("", !0),
                (f(!0), P(he, null, xe(y.value, (q, re) => {
                  var ge;
                  return f(), P("th", be({
                    key: q.identifier + ":" + re + "searchable"
                  }, q.thAttrsData, {
                    class: ka(q),
                    style: i.value ? {} : q.style
                  }), [
                    q.searchable ? (f(), P(he, { key: 0 }, [
                      (ge = q.$slots) != null && ge.searchable ? (f(), ne(s(Vt), {
                        key: 0,
                        component: q.$el,
                        name: "searchable",
                        tag: "span",
                        props: { column: q, index: re, filters: D.value }
                      }, null, 8, ["component", "props"])) : (f(), ne(At, be({
                        key: 1,
                        modelValue: D.value[q.field],
                        "onUpdate:modelValue": (Fe) => D.value[q.field] = Fe,
                        type: q.numeric ? "number" : "text"
                      }, { [Tl(e.filtersEvent)]: W }), null, 16, ["modelValue", "onUpdate:modelValue", "type"]))
                    ], 64)) : J("", !0)
                  ], 16);
                }), 128)),
                e.checkable && e.checkboxPosition === "right" ? (f(), P("th", si)) : J("", !0)
              ])) : J("", !0),
              H.value ? (f(), P("tr", ri, [
                nt.value ? (f(), P("th", {
                  key: 0,
                  class: M([...s(ut), ...s(_t)])
                }, null, 2)) : J("", !0),
                e.checkable && e.checkboxPosition === "left" ? (f(), P("th", ui)) : J("", !0),
                (f(!0), P(he, null, xe(y.value, (q, re) => {
                  var ge;
                  return f(), P("th", {
                    key: q.identifier + ":" + re + "subheading",
                    style: _e(i.value ? {} : q.style),
                    class: M([...s(ut), ...s(pl)])
                  }, [
                    (ge = q.$slots) != null && ge.subheading ? (f(), ne(s(Vt), {
                      key: 0,
                      component: q.$el,
                      name: "subheading",
                      tag: "span",
                      props: { column: q, index: re }
                    }, null, 8, ["component", "props"])) : (f(), P(he, { key: 1 }, [
                      Pe(ue(q.subheading), 1)
                    ], 64))
                  ], 6);
                }), 128)),
                e.checkable && e.checkboxPosition === "right" ? (f(), P("th", di)) : J("", !0)
              ])) : J("", !0)
            ])) : J("", !0),
            le("tbody", null, [
              (f(!0), P(he, null, xe(g.value, (q, re) => (f(), P(he, {
                key: b(q) + "row"
              }, [
                le("tr", {
                  class: M(hl(q, re)),
                  draggable: pe.value,
                  onClick: (ge) => Q(q, re, ge),
                  onDblclick: (ge) => F.$emit("dblclick", q, re, ge),
                  onMouseenter: (ge) => F.$emit("mouseenter", q, re, ge),
                  onMouseleave: (ge) => F.$emit("mouseleave", q, re, ge),
                  onContextmenu: (ge) => F.$emit("contextmenu", q, re, ge),
                  onDragstart: (ge) => Oe(q, re, ge),
                  onDragend: (ge) => Ne(q, re, ge),
                  onDrop: (ge) => Ct(q, re, ge),
                  onDragover: (ge) => $t(q, re, ge),
                  onDragleave: (ge) => Bt(q, re, ge)
                }, [
                  nt.value ? (f(), P("td", {
                    key: 0,
                    class: M([
                      ...s(ga),
                      ...s(yl)
                    ])
                  }, [
                    e.hasDetailedVisible(q) ? (f(), ne(Re, {
                      key: 0,
                      icon: e.detailIcon,
                      pack: e.iconPack,
                      rotation: T(q) ? 90 : 0,
                      role: "button",
                      clickable: "",
                      both: "",
                      onClick: ve((ge) => ft(q), ["stop"])
                    }, null, 8, ["icon", "pack", "rotation", "onClick"])) : J("", !0)
                  ], 2)) : J("", !0),
                  e.checkable && e.checkboxPosition === "left" ? (f(), P("td", {
                    key: 1,
                    class: M([
                      ...s(ut),
                      ...s(Ca)
                    ])
                  }, [
                    me(Rt, {
                      "model-value": Te(q),
                      autocomplete: "off",
                      variant: e.checkboxVariant,
                      disabled: !e.isRowCheckable(q),
                      "onUpdate:modelValue": (ge) => lt(q, re)
                    }, null, 8, ["model-value", "variant", "disabled", "onUpdate:modelValue"])
                  ], 2)) : J("", !0),
                  (f(!0), P(he, null, xe(y.value, (ge, Fe) => (f(), ne(s(Vt), be({
                    key: ge.identifier + re + ":" + Fe
                  }, ge.tdAttrsData[re], {
                    component: ge.$el,
                    name: "default",
                    tag: "td",
                    class: kl(q, ge),
                    style: i.value ? {} : ge.style,
                    "data-label": ge.label,
                    props: {
                      row: q,
                      column: ge,
                      index: re,
                      colindex: Fe,
                      toggleDetails: ft
                    },
                    onClick: (je) => F.$emit(
                      "cell-click",
                      q,
                      ge,
                      re,
                      Fe,
                      je
                    )
                  }), null, 16, ["component", "class", "style", "data-label", "props", "onClick"]))), 128)),
                  e.checkable && e.checkboxPosition === "right" ? (f(), P("td", {
                    key: 2,
                    class: M([
                      ...s(ut),
                      ...s(Ca)
                    ])
                  }, [
                    me(Rt, {
                      "model-value": Te(q),
                      autocomplete: "off",
                      variant: e.checkboxVariant,
                      disabled: !e.isRowCheckable(q),
                      "onUpdate:modelValue": (ge) => lt(q, re)
                    }, null, 8, ["model-value", "variant", "disabled", "onUpdate:modelValue"])
                  ], 2)) : J("", !0)
                ], 42, ci),
                me(et, { name: e.detailTransition }, {
                  default: se(() => [
                    de(q) ? (f(), P("tr", {
                      key: b(q) + "detail",
                      class: M(s(ml))
                    }, [
                      le("td", { colspan: I.value }, [
                        _(F.$slots, "detail", {
                          row: q,
                          index: re
                        })
                      ], 8, fi)
                    ], 2)) : J("", !0)
                  ]),
                  _: 2
                }, 1032, ["name"]),
                ke(q) ? _(F.$slots, "detail", {
                  key: 0,
                  row: q,
                  index: re
                }) : J("", !0)
              ], 64))), 128)),
              g.value.length ? J("", !0) : (f(), P("tr", vi, [
                le("td", { colspan: I.value }, [
                  _(F.$slots, "empty")
                ], 8, pi)
              ]))
            ]),
            F.$slots.footer ? (f(), P("tfoot", mi, [
              le("tr", {
                class: M(s(vl))
              }, [
                j() ? _(F.$slots, "footer", {
                  key: 0,
                  columnCount: I.value,
                  rowCount: (oe = g.value) == null ? void 0 : oe.length
                }) : (f(), P("th", {
                  key: 1,
                  colspan: I.value
                }, [
                  _(F.$slots, "footer", {
                    columnCount: I.value,
                    rowCount: (Ie = g.value) == null ? void 0 : Ie.length
                  })
                ], 8, yi))
              ], 2)
            ])) : J("", !0)
          ], 42, ei),
          _(F.$slots, "loading", { loading: e.loading }, () => [
            me(ya, {
              "full-page": !1,
              active: e.loading
            }, null, 8, ["active"])
          ])
        ], 6),
        e.checkable && F.$slots["bottom-left"] || e.paginated && (e.paginationPosition === "bottom" || e.paginationPosition === "both") ? _(F.$slots, "pagination", {
          key: 2,
          current: s(B),
          perPage: e.perPage,
          total: C.value,
          change: (q) => B.value = q
        }, () => [
          me(Va, be(F.$attrs, {
            current: s(B),
            "onUpdate:current": Y[5] || (Y[5] = (q) => Ke(B) ? B.value = q : null),
            paginated: e.paginated,
            "per-page": e.perPage,
            total: C.value,
            rounded: e.paginationRounded,
            size: e.paginationSize,
            order: e.paginationOrder,
            simple: e.paginationSimple,
            "icon-pack": e.iconPack,
            "aria-next-label": e.ariaNextLabel,
            "aria-previous-label": e.ariaPreviousLabel,
            "aria-page-label": e.ariaPageLabel,
            "aria-current-label": e.ariaCurrentLabel,
            "root-class": ha.value,
            onChange: Y[6] || (Y[6] = (q) => F.$emit("page-change", q))
          }), {
            default: se(() => [
              _(F.$slots, "bottom-left")
            ]),
            _: 3
          }, 16, ["current", "paginated", "per-page", "total", "rounded", "size", "order", "simple", "icon-pack", "aria-next-label", "aria-previous-label", "aria-page-label", "aria-current-label", "root-class"])
        ]) : J("", !0)
      ], 2);
    };
  }
}), bi = {
  install(e) {
    Ae(e, gi), Ae(e, ol);
  }
}, Ci = ["aria-orientation"], hi = ["aria-controls", "aria-selected"], ki = /* @__PURE__ */ ye({
  isOruga: !0,
  name: "OTabs",
  configField: "tabs",
  __name: "Tabs",
  props: /* @__PURE__ */ Ue({
    /** Override existing theme classes completely */
    override: { type: Boolean, default: void 0 },
    /** @model */
    modelValue: { type: [String, Number], default: 0 },
    /**
     * Color of the control
     * @values primary, info, success, warning, danger, and any other custom color
     */
    variant: {
      type: String,
      default: () => r("tabs.variant")
    },
    /**
     * Tab size
     * @values small, medium, large
     */
    size: {
      type: String,
      default: () => r("tabs.size")
    },
    /** Show tab in vertical layout */
    vertical: {
      type: Boolean,
      default: () => r("tabs.vertical", !1)
    },
    /**
     * Position of the tabs
     * @values left, centered, right
     */
    position: {
      type: String,
      default: void 0,
      validator: (e) => ["left", "centered", "right"].indexOf(e) >= 0
    },
    /**
     * Tab type
     * @values boxed, toggle
     */
    type: { type: String, default: () => r("tabs.type", "default") },
    /** Tabs will be expanded (full-width) */
    expanded: { type: Boolean, default: !1 },
    /** Tab will have an animation */
    animated: {
      type: Boolean,
      default: () => r("tabs.animated", !0)
    },
    /**
     * Transition animation name
     * @values [next, prev], [right, left, down, up]
     */
    animation: {
      type: Array,
      default: () => r("tabs.animation", [
        "slide-next",
        "slide-prev",
        "slide-down",
        "slide-up"
      ]),
      validator: (e) => e.length === 2 || e.length === 4
    },
    /** Apply animation on the initial render */
    animateInitially: {
      type: Boolean,
      default: () => r("tabs.animateInitially", !1)
    },
    /** Show tab items multiline when there is no space */
    multiline: { type: Boolean, default: !1 },
    // class props (will not be displayed in the docs)
    /** Class of the root element */
    rootClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of Tabs component when when is vertical and its position changes */
    positionClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of Tabs component when expanded */
    expandedClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of Tabs component when vertical */
    verticalClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of Tabs component when multiline */
    multilineClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the Tabs component nav tabs */
    navTabsClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Size of the navigation */
    navSizeClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the Tabs component nav position */
    navPositionClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Type of the navigation */
    navTypeClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the tab content */
    contentClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the tab content when transitioning */
    transitioningClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the tab item wrapper */
    itemWrapperClass: {
      type: [String, Array, Function],
      default: void 0
    }
  }, {
    modelValue: {},
    modelModifiers: {}
  }),
  emits: /* @__PURE__ */ Ue(["update:modelValue", "change"], ["update:modelValue"]),
  setup(e, { emit: n }) {
    const a = e, t = n, o = L(), i = l(() => ({
      activeValue: m.value,
      type: a.type,
      vertical: a.vertical,
      animated: a.animated,
      animation: a.animation,
      animateInitially: a.animateInitially
    })), { sortedItems: u } = bt(o, {
      data: i
    }), d = l(
      () => u.value.map((V) => ({
        index: V.index,
        identifier: V.identifier,
        ...pt(V.data)
      }))
    ), m = it(e, "modelValue");
    ce(
      () => a.modelValue,
      (V) => {
        m.value !== V && z(V);
      }
    );
    const c = l(
      () => ot(m.value) && d.value.find((V) => V.value === m.value) || d.value[0]
    ), v = l(() => c.value.index);
    function p(V) {
      return V.value === c.value.value;
    }
    const C = l(
      () => d.value.some((V) => V.isTransitioning)
    );
    function B(V) {
      m.value !== V.value && z(V.value);
    }
    function A() {
      const V = Yt(v.value + 1, d.value.length);
      k(V, !0);
    }
    function g() {
      const V = Yt(v.value - 1, d.value.length);
      k(V, !1);
    }
    function y() {
      d.value.length < 1 || k(0, !0);
    }
    function I() {
      d.value.length < 1 || k(d.value.length - 1, !1);
    }
    function k(V, b) {
      const D = b ? 1 : -1;
      let W = V;
      for (; W !== v.value && !(d.value[W].visible && !d.value[W].disabled); W = Yt(W + D, d.value.length))
        ;
      B(d.value[W]);
    }
    function z(V) {
      const b = m.value, D = c.value, W = d.value.find((G) => G.value === V) || d.value[0];
      D && W && (D.deactivate(W.index), W.activate(D.index)), De(() => {
        m.value = V, t("change", V, b);
      });
    }
    const R = h(
      ["rootClass", "o-tabs"],
      [
        "positionClass",
        "o-tabs--",
        l(() => a.position),
        l(() => a.position && a.vertical)
      ],
      [
        "expandedClass",
        "o-tabs--fullwidth",
        null,
        l(() => a.expanded)
      ],
      ["verticalClass", "o-tabs--vertical", null, l(() => a.vertical)],
      [
        "multilineClass",
        "o-tabs--multiline",
        null,
        l(() => a.multiline)
      ]
    ), H = h([
      "itemWrapperClass",
      "o-tabs__nav-item-wrapper"
    ]), j = h(
      ["navTabsClass", "o-tabs__nav"],
      [
        "navSizeClass",
        "o-tabs__nav--",
        l(() => a.size),
        l(() => !!a.size)
      ],
      [
        "navPositionClass",
        "o-tabs__nav--",
        l(() => a.position),
        l(() => a.position && !a.vertical)
      ],
      [
        "navTypeClass",
        "o-tabs__nav--",
        l(() => a.type),
        l(() => !!a.type)
      ]
    ), U = h(
      ["contentClass", "o-tabs__content"],
      [
        "transitioningClass",
        "o-tabs__content--transitioning",
        null,
        C
      ]
    );
    function Q(V) {
      const b = h(
        ["itemHeaderClass", "o-tabs__nav-item"],
        ["itemHeaderTypeClass", "o-tabs__nav-item-", a.type, !!a.type],
        [
          "itemHeaderActiveClass",
          "o-tabs__nav-item-{*}--active",
          a.type,
          p(V)
        ],
        [
          "itemHeaderDisabledClass",
          "o-tabs__nav-item-{*}--disabled",
          a.type,
          V.disabled
        ]
      );
      return [{ [V.headerClass || ""]: !0 }, ...b.value];
    }
    return (V, b) => (f(), P("div", {
      ref_key: "rootRef",
      ref: o,
      class: M(s(R)),
      "data-oruga": "tabs"
    }, [
      le("nav", {
        class: M(s(j)),
        role: "tablist",
        "aria-orientation": e.vertical ? "vertical" : "horizontal"
      }, [
        _(V.$slots, "start"),
        (f(!0), P(he, null, xe(d.value, (D) => $e((f(), P("div", {
          key: D.value,
          class: M(s(H)),
          role: "tab",
          "aria-controls": `${D.value}-content`,
          "aria-selected": p(D) ? "true" : "false"
        }, [
          D.$slots.header ? (f(), ne(s(Vt), {
            key: 0,
            component: D,
            tag: D.tag,
            name: "header",
            class: M(Q(D)),
            onClick: (W) => B(D),
            onKeydown: [
              Ce((W) => B(D), ["enter"]),
              Ce(ve(g, ["prevent"]), ["left"]),
              Ce(ve(A, ["prevent"]), ["right"]),
              Ce(ve(g, ["prevent"]), ["up"]),
              Ce(ve(A, ["prevent"]), ["down"]),
              Ce(ve(y, ["prevent"]), ["home"]),
              Ce(ve(I, ["prevent"]), ["end"])
            ]
          }, null, 8, ["component", "tag", "class", "onClick", "onKeydown"])) : (f(), ne(Ge(D.tag), {
            key: 1,
            role: "button",
            tabindex: 0,
            class: M(Q(D)),
            onClick: (W) => B(D),
            onKeydown: [
              Ce((W) => B(D), ["enter"]),
              Ce(ve(g, ["prevent"]), ["left"]),
              Ce(ve(A, ["prevent"]), ["right"]),
              Ce(ve(g, ["prevent"]), ["up"]),
              Ce(ve(A, ["prevent"]), ["down"]),
              Ce(ve(y, ["prevent"]), ["home"]),
              Ce(ve(I, ["prevent"]), ["end"])
            ]
          }, {
            default: se(() => [
              D.icon ? (f(), ne(Re, {
                key: 0,
                "root-class": s(Ee)(D.headerIconClasses),
                icon: D.icon,
                pack: D.iconPack,
                size: e.size
              }, null, 8, ["root-class", "icon", "pack", "size"])) : J("", !0),
              le("span", {
                class: M(D.headerTextClasses)
              }, ue(D.label), 3)
            ]),
            _: 2
          }, 1064, ["class", "onClick", "onKeydown"]))
        ], 10, hi)), [
          [ze, D.visible]
        ])), 128)),
        _(V.$slots, "end")
      ], 10, Ci),
      le("section", {
        class: M(s(U))
      }, [
        _(V.$slots, "default")
      ], 2)
    ], 2));
  }
}), Si = ["data-id", "tabindex", "role"], Fi = /* @__PURE__ */ ye({
  isOruga: !0,
  name: "OTabItem",
  configField: "tabs",
  __name: "TabItem",
  props: {
    /** Override existing theme classes completely */
    override: { type: Boolean, default: void 0 },
    /** Item value (it will be used as v-model of wrapper component) */
    value: { type: [String, Number], default: () => Ye() },
    /** Item label */
    label: { type: String, default: void 0 },
    /** Item will be disabled */
    disabled: { type: Boolean, default: !1 },
    /** Icon on the left */
    icon: {
      type: String,
      default: () => r("tabs.icon")
    },
    /** Icon pack */
    iconPack: {
      type: String,
      default: () => r("tabs.iconPack")
    },
    /** Show/hide item */
    visible: { type: Boolean, default: !0 },
    /** Tabs item tag name */
    tag: {
      type: [String, Object, Function],
      default: () => r("tabs.itemTag", "button")
    },
    /** Role attribute to be passed to the div wrapper for better accessibility. */
    ariaRole: {
      type: String,
      default: () => r("tabs.ariaRole", "tab")
    },
    /** Sets a class to the item header */
    headerClass: { type: String, default: void 0 },
    // class props (will not be displayed in the docs)
    /** Class of the tab item */
    itemClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the tab item header */
    itemHeaderClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the tab item header when active */
    itemHeaderActiveClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the tab item header when disabled */
    itemHeaderDisabledClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the tab item header type */
    itemHeaderTypeClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the tab item header icon */
    itemHeaderIconClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the tab item header text */
    itemHeaderTextClass: {
      type: [String, Array, Function],
      default: void 0
    }
  },
  emits: ["activate", "deactivate"],
  setup(e, { emit: n }) {
    const a = e, t = n, o = xt(), i = l(() => ({
      ...We(a),
      $slots: o,
      headerIconClasses: k.value,
      headerTextClasses: z.value,
      isTransitioning: v.value,
      activate: B,
      deactivate: A
    })), { parent: u, item: d } = gt({
      data: i
    }), m = L(), c = l(() => Tt(a.value, u.value.activeValue)), v = L(!1), p = l(() => {
      const R = u.value.vertical && u.value.animation.length === 4 ? 2 : 0;
      return u.value.animation[R];
    }), C = l(() => {
      const R = u.value.vertical && u.value.animation.length === 4 ? 3 : 1;
      return u.value.animation[R];
    });
    function B(R) {
      m.value = d.value.index < R ? p.value : C.value, t("activate");
    }
    function A(R) {
      m.value = R < d.value.index ? p.value : C.value, t("deactivate");
    }
    function g() {
      v.value = !0;
    }
    function y() {
      v.value = !0;
    }
    const I = h(["itemClass", "o-tab-item__content"]), k = h([
      "itemHeaderIconClass",
      "o-tabs__nav-item-icon"
    ]), z = h([
      "itemHeaderTextClass",
      "o-tabs__nav-item-text"
    ]);
    return (R, H) => (f(), ne(et, {
      disabled: !s(u).animated,
      name: m.value,
      appear: s(u).animateInitially,
      onAfterEnter: g,
      onBeforeLeave: y
    }, {
      default: se(() => [
        $e(le("div", {
          ref: "rootRef",
          class: M(s(I)),
          "data-id": `tabs-${s(d).identifier}`,
          "data-oruga": "tabs-item",
          tabindex: c.value ? 0 : -1,
          role: e.ariaRole,
          "aria-roledescription": "item"
        }, [
          _(R.$slots, "default")
        ], 10, Si), [
          [ze, c.value && e.visible]
        ])
      ]),
      _: 3
    }, 8, ["disabled", "name", "appear"]));
  }
}), Ai = {
  install(e) {
    Ae(e, ki), Ae(e, Fi);
  }
}, wi = /* @__PURE__ */ ye({
  isOruga: !0,
  name: "OTaginput",
  configField: "taginput",
  inheritAttrs: !1,
  __name: "Taginput",
  props: {
    /** Override existing theme classes completely */
    override: { type: Boolean, default: void 0 },
    /** @model */
    modelValue: { type: Array, default: () => [] },
    /** Items data */
    data: { type: Array, default: () => [] },
    /** Property of the object (if data is array of objects) to use as display text */
    field: { type: String, default: "value" },
    /** Property of the object (if `data` is array of objects) to use as display text of group */
    groupField: { type: String, default: void 0 },
    /** Property of the object (if `data` is array of objects) to use as key to get items array of each group */
    groupOptions: { type: String, default: void 0 },
    /**
     * Vertical size of the input control
     * @values small, medium, large
     */
    size: {
      type: String,
      default: () => r("taginput.size")
    },
    /**
     * Color of the each item
     * @values primary, info, success, warning, danger, and any other custom color
     */
    variant: {
      type: String,
      default: () => r("taginput.variant")
    },
    /** Limits the number of items, plus item counter */
    maxitems: { type: Number, default: void 0 },
    /** Same as native maxlength, plus character counter */
    maxlength: { type: Number, default: void 0 },
    /** Show counter when maxlength or maxtags props are passed */
    counter: {
      type: Boolean,
      default: () => r("taginput.counter", !0)
    },
    /** Opens a dropdown with choices when the input field is focused */
    openOnFocus: { type: Boolean, default: !1 },
    /** Keep open dropdown list after select */
    keepOpen: {
      type: Boolean,
      default: () => r("autocomplete.keepOpen", !1)
    },
    /** Input placeholder */
    placeholder: { type: String, default: void 0 },
    /** Makes input full width when inside a grouped or addon field */
    expanded: { type: Boolean, default: !1 },
    /** Same as native input disabled */
    disabled: { type: Boolean, default: !1 },
    /**
     * Array of keys
     * (https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key/Key_Values)
     * which will add a item when typing
     */
    confirmKeys: {
      type: Array,
      default: () => r("taginput.confirmKeys", [",", "Tab", "Enter"])
    },
    /** Array of chars used to split when pasting a new string */
    separators: {
      type: Array,
      default: () => r("taginput.separators", [","])
    },
    /** The first option will always be pre-selected (easier to just hit enter or tab) */
    keepFirst: { type: Boolean, default: !1 },
    /** When autocomplete, it allow to add new items */
    allowNew: { type: Boolean, default: !1 },
    /** Allows adding the same item multiple time */
    allowDuplicates: { type: Boolean, default: !1 },
    /** Add autocomplete feature (if true, any Autocomplete props may be used too) */
    allowAutocomplete: { type: Boolean, default: !1 },
    /** Allow removing last item when pressing given keys, if input is empty */
    removeOnKeys: {
      type: Array,
      default: () => r("taginput.removeOnKeys", ["Backspace"])
    },
    /** Function to validate the value of the item before adding */
    beforeAdding: {
      type: Function,
      default: () => !0
    },
    /** Function to create a new item to push into v-model (items) */
    createItem: {
      type: Function,
      default: (e) => e
    },
    /** Makes the component check if list reached scroll start or end and emit scroll events. */
    checkScroll: {
      type: Boolean,
      default: () => r("taginput.checkScroll", !1)
    },
    /** Add close/delete button to the item */
    closable: {
      type: Boolean,
      default: () => r("taginput.closable", !0)
    },
    /**
     * Icon pack to use
     * @values mdi, fa, fas and any other custom icon pack
     */
    iconPack: {
      type: String,
      default: () => r("taginput.iconPack")
    },
    /** Icon to be shown */
    icon: {
      type: String,
      default: () => r("taginput.icon")
    },
    /** Icon name of close icon on selected item */
    closeIcon: {
      type: String,
      default: () => r("taginput.closeIcon", "close")
    },
    /** Accessibility label for the close button */
    ariaCloseLabel: {
      type: String,
      default: () => r("taginput.ariaCloseLabel")
    },
    /** Native options to use in HTML5 validation */
    autocomplete: {
      type: String,
      default: () => r("taginput.autocomplete", "off")
    },
    /** Enable html 5 native validation */
    useHtml5Validation: {
      type: Boolean,
      default: () => r("useHtml5Validation", !0)
    },
    /** The message which is shown when a validation error occurs */
    validationMessage: { type: String, default: void 0 },
    /**
     * Append the component to another part of the DOM.
     * Set `true` to append the component to the body.
     * In addition, any CSS selector string or an actual DOM node can be used.
     */
    teleport: {
      type: [Boolean, String, Object],
      default: () => r("taginput.teleport", !1)
    },
    // class props (will not be displayed in the docs)
    /** Class of the root element */
    rootClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of input when expanded */
    expandedClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the input container */
    containerClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the input container size */
    sizeClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the entered item variant */
    variantClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the close button of entered item */
    closeClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the entered item */
    itemClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the counter element */
    counterClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /**
     * Class configuration for the underlying autocomplete component
     * @ignore
     */
    autocompleteClasses: {
      type: Object,
      default: () => r("taginput.autocompleteClasses", {})
    }
  },
  emits: ["update:modelValue", "input", "add", "remove", "focus", "blur", "invalid", "icon-click", "icon-right-click", "scroll-start", "scroll-end"],
  setup(e, { expose: n, emit: a }) {
    const t = e, o = a, i = L(), u = dt(t, o, {
      passive: !0,
      deep: !0
    }), { setFocus: d, onFocus: m, onBlur: c, onInvalid: v } = rt(
      i,
      o,
      t
    ), p = L(""), C = L(!1), B = l(() => p.value.trim().length), A = l(() => u.value.length);
    ce(
      () => t.modelValue,
      ($) => {
        u.value = Array.isArray($) ? $.slice(0) : $ || [];
      }
    );
    const g = l(
      () => t.maxitems == null || A.value < t.maxitems
    );
    ce(
      () => g.value,
      () => {
        g.value || c();
      }
    );
    const y = l(
      () => t.separators.length ? new RegExp(
        t.separators.map(
          ($) => $ ? $.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&") : null
        ).join("|"),
        "g"
      ) : null
    );
    function I($) {
      return typeof $ == "object" && ($ = Me($, t.field)), `${$}`;
    }
    function k($) {
      if ($ = $ || p.value.trim(), $) {
        if (!t.allowAutocomplete) {
          const O = y.value;
          if (O && $.match(O)) {
            $.split(O).map((x) => x.trim()).filter((x) => x.length !== 0).map(k);
            return;
          }
        }
        const N = t.createItem($);
        (t.allowDuplicates ? !0 : u.value.indexOf(N) === -1) && t.beforeAdding($) && (u.value.push(N), o("add", N));
      }
      requestAnimationFrame(() => {
        p.value = "", o("input", p.value);
      });
    }
    function z($, N) {
      const ae = u.value.splice($, 1)[0];
      o("remove", ae), N && N.stopPropagation(), t.openOnFocus && i.value && d();
    }
    function R($) {
      $ && (k($), De(() => p.value = ""));
    }
    function H($) {
      var N;
      if (t.removeOnKeys.indexOf($.key) !== -1 && !((N = p.value) != null && N.length) && A.value > 0 && z(A.value - 1), !(t.allowAutocomplete && !t.allowNew) && t.confirmKeys.indexOf($.key) >= 0) {
        if ($.key !== "Tab" && $.preventDefault(), $.key === "Enter" && C.value)
          return;
        k();
      }
    }
    function j($) {
      o("input", String($).trim());
    }
    function U($) {
      t.allowAutocomplete || k(), c($);
    }
    const Q = da(), V = h([
      "autocompleteClasses.rootClass",
      "o-taginput__autocomplete"
    ]), b = h([
      "autocompleteClasses.inputClasses.inputClass",
      "o-taginput__input"
    ]), D = l(() => ({
      ...Q,
      "root-class": Ee(V.value),
      "input-classes": {
        "input-class": Ee(b.value)
      },
      ...t.autocompleteClasses
    })), W = h(
      ["rootClass", "o-taginput"],
      [
        "expandedClass",
        "o-taginput--expanded",
        null,
        l(() => t.expanded)
      ]
    ), G = h(
      ["containerClass", "o-taginput__container"],
      [
        "sizeClass",
        "o-taginput__container--",
        l(() => t.size),
        l(() => !!t.size)
      ]
    ), E = h(
      ["itemClass", "o-taginput__item"],
      [
        "variantClass",
        "o-taginput__item--",
        l(() => t.variant),
        l(() => !!t.variant)
      ]
    ), S = h(["closeClass", "o-taginput__item__close"]), w = h(["counterClass", "o-taginput__counter"]);
    return n({ focus: d }), ($, N) => (f(), P("div", {
      "data-oruga": "taginput",
      class: M(s(W))
    }, [
      le("div", {
        class: M(s(G)),
        onFocus: N[8] || (N[8] = //@ts-ignore
        (...ae) => s(m) && s(m)(...ae)),
        onBlur: N[9] || (N[9] = //@ts-ignore
        (...ae) => s(c) && s(c)(...ae))
      }, [
        _($.$slots, "selected", { items: s(u) }, () => [
          (f(!0), P(he, null, xe(s(u), (ae, O) => (f(), P("span", {
            key: I(ae) + O,
            class: M(s(E))
          }, [
            le("span", null, ue(I(ae)), 1),
            e.closable ? (f(), ne(Re, {
              key: 0,
              class: M(s(S)),
              clickable: "",
              pack: e.iconPack,
              icon: e.closeIcon,
              "aria-label": e.ariaCloseLabel,
              both: "",
              onClick: (x) => z(O, x)
            }, null, 8, ["class", "pack", "icon", "aria-label", "onClick"])) : J("", !0)
          ], 2))), 128))
        ]),
        $e(me(Ja, be({
          ref_key: "autocompleteRef",
          ref: i,
          modelValue: p.value,
          "onUpdate:modelValue": N[0] || (N[0] = (ae) => p.value = ae)
        }, D.value, {
          data: e.data,
          field: e.field,
          icon: e.icon,
          "icon-pack": e.iconPack,
          maxlength: e.maxlength,
          size: e.size,
          disabled: e.disabled,
          autocomplete: e.autocomplete,
          "open-on-focus": e.openOnFocus,
          "keep-first": e.keepFirst,
          "keep-open": e.keepOpen,
          "group-field": e.groupField,
          "group-options": e.groupOptions,
          "has-counter": !1,
          "use-html5-validation": e.useHtml5Validation,
          "check-scroll": e.checkScroll,
          teleport: e.teleport,
          "confirm-keys": e.confirmKeys,
          placeholder: e.placeholder,
          "validation-message": e.validationMessage,
          expanded: e.expanded,
          onInput: j,
          onFocus: s(m),
          onBlur: U,
          onInvalid: s(v),
          onKeydown: H,
          onCompositionstart: N[1] || (N[1] = (ae) => C.value = !0),
          onCompositionend: N[2] || (N[2] = (ae) => C.value = !1),
          onSelect: N[3] || (N[3] = (ae) => R(ae)),
          onScrollStart: N[4] || (N[4] = (ae) => $.$emit("scroll-start")),
          onScrollEnd: N[5] || (N[5] = (ae) => $.$emit("scroll-end")),
          onIconClick: N[6] || (N[6] = (ae) => $.$emit("icon-click", ae)),
          onIconRightClick: N[7] || (N[7] = (ae) => $.$emit("icon-right-click", ae))
        }), qt({ _: 2 }, [
          $.$slots.header ? {
            name: "header",
            fn: se(() => [
              _($.$slots, "header")
            ]),
            key: "0"
          } : void 0,
          $.$slots.default ? {
            name: "default",
            fn: se((ae) => [
              _($.$slots, "default", {
                option: ae.option,
                index: ae.index,
                value: ae.value
              })
            ]),
            key: "1"
          } : void 0,
          $.$slots.empty ? {
            name: "empty",
            fn: se(() => [
              _($.$slots, "empty")
            ]),
            key: "2"
          } : void 0,
          $.$slots.footer ? {
            name: "footer",
            fn: se(() => [
              _($.$slots, "footer")
            ]),
            key: "3"
          } : void 0
        ]), 1040, ["modelValue", "data", "field", "icon", "icon-pack", "maxlength", "size", "disabled", "autocomplete", "open-on-focus", "keep-first", "keep-open", "group-field", "group-options", "use-html5-validation", "check-scroll", "teleport", "confirm-keys", "placeholder", "validation-message", "expanded", "onFocus", "onInvalid"]), [
          [ze, g.value]
        ])
      ], 34),
      e.counter && (e.maxitems || e.maxlength) ? (f(), P("small", {
        key: 0,
        class: M(s(w))
      }, [
        e.maxlength && B.value > 0 ? _($.$slots, "counter", {
          key: 0,
          items: B.value,
          total: e.maxlength
        }, () => [
          Pe(ue(B.value) + " / " + ue(e.maxlength), 1)
        ]) : e.maxitems ? _($.$slots, "counter", {
          key: 1,
          items: A.value,
          total: e.maxitems
        }, () => [
          Pe(ue(A.value) + " / " + ue(e.maxitems), 1)
        ]) : J("", !0)
      ], 2)) : J("", !0)
    ], 2));
  }
}), Di = {
  install(e) {
    Ae(e, wi);
  }
}, xi = {
  install(e) {
    Ae(e, _a);
  }
}, $i = {
  install(e) {
    Ae(e, ll);
  }
}, Bi = ["id"], Oi = ["multiple", "accept", "disabled", "aria-labelledby"], Pi = /* @__PURE__ */ ye({
  isOruga: !0,
  name: "OUpload",
  configField: "upload",
  inheritAttrs: !1,
  __name: "Upload",
  props: /* @__PURE__ */ Ue({
    /** Override existing theme classes completely */
    override: { type: Boolean, default: void 0 },
    /** @model */
    modelValue: {
      type: [Object, Array],
      default: void 0
    },
    /** Same as native, also push new item to v-model instead of replacing */
    multiple: { type: Boolean, default: !1 },
    /**
     * Color of the control
     * @values primary, info, success, warning, danger, and any other custom color
     */
    variant: {
      type: String,
      default: () => r("upload.variant")
    },
    /** Same as native disabled */
    disabled: { type: Boolean, default: !1 },
    /** Same as native accept */
    accept: { type: String, default: void 0 },
    /** Accepts drag & drop and change its style */
    dragDrop: { type: Boolean, default: !1 },
    /** Upload will be expanded (full-width) */
    expanded: { type: Boolean, default: !1 },
    /** Replace last chosen files every time (like native file input element) */
    native: { type: Boolean, default: !0 },
    /** Accessibility label to establish relationship between the input and control label */
    ariaLabelledby: { type: String, default: () => Ye() },
    /** Enable html 5 native validation */
    useHtml5Validation: {
      type: Boolean,
      default: () => r("useHtml5Validation", !0)
    },
    /** The message which is shown when a validation error occurs */
    validationMessage: { type: String, default: void 0 },
    // class props (will not be displayed in the docs)
    /** Class of the root element */
    rootClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the Upload when draggable */
    draggableClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the Upload variant */
    variantClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the Upload when expanded */
    expandedClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the Upload when disabled */
    disabledClass: {
      type: [String, Array, Function],
      default: void 0
    },
    /** Class of the Upload when hovered */
    hoveredClass: {
      type: [String, Array, Function],
      default: void 0
    }
  }, {
    modelValue: {},
    modelModifiers: {}
  }),
  emits: /* @__PURE__ */ Ue(["update:modelValue", "focus", "blur", "invalid"], ["update:modelValue"]),
  setup(e, { expose: n, emit: a }) {
    const t = e, o = a, i = L(), u = it(e, "modelValue"), { checkHtml5Validity: d, onFocus: m, onBlur: c, isValid: v, setFocus: p } = rt(i, o, t), C = L(!1);
    ce(u, (R) => {
      (!R || Array.isArray(R) && R.length === 0) && (i.value.value = null), !v.value && !t.dragDrop && d();
    });
    function B(R) {
      if (t.disabled)
        return;
      t.dragDrop && g(!1);
      const H = R.target.files || R.dataTransfer.files;
      if (H.length === 0) {
        if (!u.value)
          return;
        t.native && (u.value = null);
      }
      if (t.multiple) {
        const j = t.native || !u.value || !Array.isArray(u.value) ? [] : [...u.value];
        for (let U = 0; U < H.length; U++) {
          const Q = H[U];
          y(Q) && j.push(Q);
        }
        u.value = j;
      } else {
        if (t.dragDrop && H.length !== 1)
          return;
        {
          const j = H[0];
          if (y(j))
            u.value = j;
          else if (u.value)
            u.value = null, A();
          else {
            A(), d();
            return;
          }
        }
      }
      t.dragDrop || d();
    }
    function A() {
      i.value.value = null;
    }
    function g(R) {
      t.disabled || (C.value = R);
    }
    function y(R) {
      if (!t.accept)
        return !0;
      const H = t.accept.split(",");
      if (H.length === 0)
        return !0;
      for (let j = 0; j < H.length; j++) {
        const U = H[j].trim();
        if (U) {
          if (U.substring(0, 1) === ".") {
            if (R.name.toLowerCase().slice(-U.length) === U.toLowerCase())
              return !0;
          } else if (R.type.match(U))
            return !0;
        }
      }
      return !1;
    }
    function I(R) {
      t.disabled || t.dragDrop || (R.preventDefault(), i.value.click());
    }
    const k = h(
      ["rootClass", "o-upl"],
      ["expandedClass", "o-upl--expanded", null, l(() => t.expanded)],
      ["disabledClass", "o-upl--disabled", null, l(() => t.disabled)]
    ), z = h(
      ["draggableClass", "o-upl__draggable"],
      [
        "hoveredClass",
        "o-upl__draggable--hovered",
        null,
        l(() => !t.variant && C.value)
      ],
      [
        "variantClass",
        "o-upl__draggable--hovered-",
        l(() => t.variant),
        l(() => t.variant && C.value)
      ]
    );
    return n({ focus: p }), (R, H) => (f(), P("label", {
      id: e.ariaLabelledby,
      class: M(s(k)),
      "data-oruga": "upload"
    }, [
      e.dragDrop ? (f(), P("div", {
        key: 1,
        class: M(s(z)),
        role: "button",
        tabindex: "0",
        onMouseenter: H[0] || (H[0] = (j) => g(!0)),
        onMouseleave: H[1] || (H[1] = (j) => g(!1)),
        onDragover: H[2] || (H[2] = ve((j) => g(!0), ["prevent"])),
        onDragleave: H[3] || (H[3] = ve((j) => g(!1), ["prevent"])),
        onDragenter: H[4] || (H[4] = ve((j) => g(!0), ["prevent"])),
        onDrop: ve(B, ["prevent"])
      }, [
        _(R.$slots, "default")
      ], 34)) : _(R.$slots, "default", {
        key: 0,
        onclick: I
      }),
      le("input", be(R.$attrs, {
        ref_key: "inputRef",
        ref: i,
        type: "file",
        "data-oruga-input": "file",
        multiple: e.multiple,
        accept: e.accept,
        disabled: e.disabled,
        "aria-labelledby": e.ariaLabelledby,
        onChange: B,
        onFocus: H[5] || (H[5] = //@ts-ignore
        (...j) => s(m) && s(m)(...j)),
        onBlur: H[6] || (H[6] = //@ts-ignore
        (...j) => s(c) && s(c)(...j))
      }), null, 16, Oi)
    ], 10, Bi));
  }
}), Mi = {
  install(e) {
    Ae(e, Pi);
  }
}, Ta = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Autocomplete: fn,
  Button: vn,
  Carousel: bn,
  Checkbox: Sn,
  Collapse: wn,
  Datepicker: Wn,
  Datetimepicker: Qn,
  Dropdown: Zn,
  Field: _n,
  Icon: eo,
  Input: to,
  Loading: no,
  Menu: uo,
  Modal: mo,
  Notification: So,
  Pagination: Fo,
  Radio: $o,
  Select: Bo,
  Sidebar: Vo,
  Skeleton: Po,
  Slider: Ho,
  Steps: Ko,
  Switch: Jo,
  Table: bi,
  Tabs: Ai,
  Taginput: Di,
  Timepicker: xi,
  Tooltip: $i,
  Upload: Mi
}, Symbol.toStringTag, { value: "Module" })), Ti = {
  install(e, n = {}) {
    e.use(Kl, n);
    for (const a in Ta)
      jl(e, Ta[a]);
    Ht(e, "config", Yl);
  }
};
export {
  fn as Autocomplete,
  vn as Button,
  bn as Carousel,
  Sn as Checkbox,
  wn as Collapse,
  Kl as ConfigPlugin,
  Yl as ConfigProgrammatic,
  Wn as Datepicker,
  Qn as Datetimepicker,
  Zn as Dropdown,
  _n as Field,
  eo as Icon,
  to as Input,
  no as Loading,
  lo as LoadingProgrammatic,
  uo as Menu,
  mo as Modal,
  po as ModalProgrammatic,
  So as Notification,
  ko as NotificationProgrammatic,
  Ja as OAutocomplete,
  wt as OButton,
  mn as OCarousel,
  gn as OCarouselItem,
  Rt as OCheckbox,
  An as OCollapse,
  Za as ODatepicker,
  Jn as ODatetimepicker,
  va as ODropdown,
  ht as ODropdownItem,
  Ka as OField,
  Re as OIcon,
  At as OInput,
  ya as OLoading,
  io as OMenu,
  ro as OMenuItem,
  el as OModal,
  bo as ONotification,
  tl as OPagination,
  xo as ORadio,
  mt as OSelect,
  al as OSidebar,
  Oo as OSkeleton,
  zo as OSlider,
  nl as OSliderTick,
  Yo as OStepItem,
  jo as OSteps,
  Go as OSwitch,
  Fi as OTabItem,
  gi as OTable,
  ol as OTableColumn,
  ki as OTabs,
  wi as OTaginput,
  _a as OTimepicker,
  ll as OTooltip,
  Pi as OUpload,
  Ti as Oruga,
  Fo as Pagination,
  $o as Radio,
  Bo as Select,
  Vo as Sidebar,
  Ro as SidebarProgrammatic,
  Po as Skeleton,
  Ho as Slider,
  Ko as Steps,
  Jo as Switch,
  bi as Table,
  Ai as Tabs,
  Di as Taginput,
  xi as Timepicker,
  $i as Tooltip,
  Mi as Upload,
  Ti as default,
  El as useOruga
};
//# sourceMappingURL=oruga.mjs.map
